package fs

import (
	"context"
	"strings"
	"testing"
	"time"

	"github.com/sharedcode/sop"
	"github.com/sharedcode/sop/common/mocks"
)

// TestLockKeyNamespacing verifies that lock keys generated by hashmap are namespaced
// by the active base folder to prevent collisions between different SOP instances
// sharing the same Redis server.
func TestLockKeyNamespacing(t *testing.T) {
	// 1. Setup Mock Redis
	// We need to cast to the concrete type to access stringStore for verification,
	// but since mockRedis is internal to mocks package, we might need to rely on
	// the fact that DualLock sets keys.
	// Actually, we can just wrap the mock or use a custom one since we are in the same module
	// but different package. Wait, mocks is in common/mocks.
	// I can't access mockRedis struct fields if they are not exported.
	// But I can use IsLockedByOthers to check if a key exists.

	// Let's define a capturing mock cache in this test file to be sure.
	capturingCache := &capturingMockCache{
		capturedKeys: make([]string, 0),
		mock:         mocks.NewMockClient(),
	}

	ctx := context.Background()

	// 2. Setup Two Replication Trackers with different base paths
	path1 := "/tmp/app1"
	path2 := "/tmp/app2"

	rt1, err := NewReplicationTracker(ctx, []string{path1}, false, capturingCache)
	if err != nil {
		t.Fatalf("Failed to create rt1: %v", err)
	}
	rt2, err := NewReplicationTracker(ctx, []string{path2}, false, capturingCache)
	if err != nil {
		t.Fatalf("Failed to create rt2: %v", err)
	}

	// 3. Create Hashmaps
	// newHashmap is internal to fs, so we can call it since we are in package fs
	hm1 := newHashmap(true, 250, rt1, capturingCache)
	hm2 := newHashmap(true, 250, rt2, capturingCache)

	// 4. Trigger Lock Key Generation
	// We can call formatLockKey directly since it's internal and we are in package fs
	filename := "user_store"
	offset := int64(1024)

	key1 := hm1.formatLockKey(filename, offset)
	key2 := hm2.formatLockKey(filename, offset)

	// 5. Verify Keys are Different and Namespaced
	t.Logf("Key 1: %s", key1)
	t.Logf("Key 2: %s", key2)

	if key1 == key2 {
		t.Errorf("Lock keys collided! Both are: %s", key1)
	}

	if !strings.Contains(key1, path1) {
		t.Errorf("Key 1 does not contain base path %s. Got: %s", path1, key1)
	}
	if !strings.Contains(key2, path2) {
		t.Errorf("Key 2 does not contain base path %s. Got: %s", path2, key2)
	}

	// Also verify preallocateFileLockKey if possible, but that's a constant in hashmap.go
	// The fix for preallocateFileLockKey involved appending the filename, which is now namespaced?
	// Wait, preallocateFileLockKey was "infs_reg".
	// In setupNewFile:
	// lk := hm.cache.CreateLockKeys([]string{preallocateFileLockKey + filename})
	// Since filename passed to setupNewFile should be the full path (or relative?), let's check setupNewFile usage.
	// In findOneFileRegion:
	// relativeSegmentPath := fmt.Sprintf("%s%c%s", filename, os.PathSeparator, segmentFilename)
	// fn := hm.replicationTracker.formatActiveFolderEntity(relativeSegmentPath)
	// setupNewFile(..., fn, ...)
	// So 'fn' passed to setupNewFile IS the full path (namespaced).
	// So preallocateFileLockKey + fn will be namespaced.
}

// capturingMockCache wraps a real/mock cache to capture lock keys
type capturingMockCache struct {
	capturedKeys []string
	mock         sop.L2Cache
}

func (c *capturingMockCache) GetType() sop.L2CacheType {
	return sop.Redis
}

func (c *capturingMockCache) FormatLockKey(k string) string {
	// The default implementation might just return k or prefix it.
	// We want to see what hashmap passes to it.
	return c.mock.FormatLockKey(k)
}

func (c *capturingMockCache) CreateLockKeys(keys []string) []*sop.LockKey {
	c.capturedKeys = append(c.capturedKeys, keys...)
	return c.mock.CreateLockKeys(keys)
}

func (c *capturingMockCache) CreateLockKeysForIDs(ids []sop.Tuple[string, sop.UUID]) []*sop.LockKey {
	for _, item := range ids {
		c.capturedKeys = append(c.capturedKeys, item.First)
	}
	return c.mock.CreateLockKeysForIDs(ids)
}

// Delegate other methods
func (c *capturingMockCache) Set(ctx context.Context, key string, value string, duration time.Duration) error {
	return c.mock.Set(ctx, key, value, duration)
}
func (c *capturingMockCache) Get(ctx context.Context, key string) (bool, string, error) {
	return c.mock.Get(ctx, key)
}
func (c *capturingMockCache) GetEx(ctx context.Context, key string, duration time.Duration) (bool, string, error) {
	return c.mock.GetEx(ctx, key, duration)
}
func (c *capturingMockCache) GetStruct(ctx context.Context, key string, target interface{}) (bool, error) {
	return c.mock.GetStruct(ctx, key, target)
}
func (c *capturingMockCache) GetStructEx(ctx context.Context, key string, target interface{}, duration time.Duration) (bool, error) {
	return c.mock.GetStructEx(ctx, key, target, duration)
}
func (c *capturingMockCache) SetStruct(ctx context.Context, key string, value interface{}, duration time.Duration) error {
	return c.mock.SetStruct(ctx, key, value, duration)
}
func (c *capturingMockCache) Delete(ctx context.Context, keys []string) (bool, error) {
	return c.mock.Delete(ctx, keys)
}
func (c *capturingMockCache) Ping(ctx context.Context) error {
	return c.mock.Ping(ctx)
}
func (c *capturingMockCache) DualLock(ctx context.Context, duration time.Duration, lockKeys []*sop.LockKey) (bool, sop.UUID, error) {
	return c.mock.DualLock(ctx, duration, lockKeys)
}
func (c *capturingMockCache) Lock(ctx context.Context, duration time.Duration, lockKeys []*sop.LockKey) (bool, sop.UUID, error) {
	return c.mock.Lock(ctx, duration, lockKeys)
}
func (c *capturingMockCache) Unlock(ctx context.Context, lockKeys []*sop.LockKey) error {
	return c.mock.Unlock(ctx, lockKeys)
}
func (c *capturingMockCache) IsLocked(ctx context.Context, lockKeys []*sop.LockKey) (bool, error) {
	return c.mock.IsLocked(ctx, lockKeys)
}
func (c *capturingMockCache) IsLockedTTL(ctx context.Context, duration time.Duration, lockKeys []*sop.LockKey) (bool, error) {
	return c.mock.IsLockedTTL(ctx, duration, lockKeys)
}
func (c *capturingMockCache) IsLockedByOthers(ctx context.Context, lockKeyNames []string) (bool, error) {
	return c.mock.IsLockedByOthers(ctx, lockKeyNames)
}
func (c *capturingMockCache) IsLockedByOthersTTL(ctx context.Context, lockKeyNames []string, duration time.Duration) (bool, error) {
	return c.mock.IsLockedByOthersTTL(ctx, lockKeyNames, duration)
}
func (c *capturingMockCache) IsRestarted(ctx context.Context) bool {
	return c.mock.IsRestarted(ctx)
}
func (c *capturingMockCache) Clear(ctx context.Context) error {
	return c.mock.Clear(ctx)
}
