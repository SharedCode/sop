package cassandra

import (
	"context"
	"fmt"
	"strings"

	"github.com/gocql/gocql"

	"github.com/SharedCode/sop"
)

type TransactionLog interface {
	// Get or fetch a blob given an Id.
	GetOne(ctx context.Context, blobTable string, blobId sop.UUID, target interface{}) error
	// Add blobs to store.
	Add(ctx context.Context, blobs ...BlobsPayload[sop.KeyValuePair[sop.UUID, interface{}]]) error
	// Remove blobs in store with given Ids.
	Remove(ctx context.Context, blobsIds ...BlobsPayload[sop.UUID]) error
}

type blobStore struct{}

// NewBlobStore instantiates a new BlobStore instance.
func NewBlobStore() BlobStore {
	return &blobStore{}
}

// GetOne fetches a blob from blob table.
func (b *blobStore) GetOne(ctx context.Context, blobTable string, blobId sop.UUID, target interface{}) error {
	if connection == nil {
		return fmt.Errorf("Cassandra connection is closed, 'call GetConnection(config) to open it")
	}
	selectStatement := fmt.Sprintf("SELECT node FROM %s.%s WHERE id in (?);", connection.Config.Keyspace, blobTable)
	qry := connection.Session.Query(selectStatement, gocql.UUID(blobId)).WithContext(ctx)
	if connection.Config.ConsistencyBook.BlobStoreGet > gocql.Any {
		qry.Consistency(connection.Config.ConsistencyBook.BlobStoreGet)
	}
	iter := qry.Iter()
	var ba []byte
	for iter.Scan(&ba) {
	}
	if err := iter.Close(); err != nil {
		return err
	}
	return Marshaler.Unmarshal(ba, target)
}

// Add blob(s) to the Blob store.
func (b *blobStore) Add(ctx context.Context, storesblobs ...BlobsPayload[sop.KeyValuePair[sop.UUID, interface{}]]) error {
	if connection == nil {
		return fmt.Errorf("Cassandra connection is closed, 'call GetConnection(config) to open it")
	}
	for i := range storesblobs {
		for ii := range storesblobs[i].Blobs {
			ba, err := Marshaler.Marshal(storesblobs[i].Blobs[ii].Value)
			if err != nil {
				return err
			}
			insertStatement := fmt.Sprintf("INSERT INTO %s.%s (id, node) VALUES(?,?);",
				connection.Config.Keyspace, storesblobs[i].BlobTable)
			qry := connection.Session.Query(insertStatement, gocql.UUID(storesblobs[i].Blobs[ii].Key), ba).WithContext(ctx)
			if connection.Config.ConsistencyBook.BlobStoreAdd > gocql.Any {
				qry.Consistency(connection.Config.ConsistencyBook.BlobStoreAdd)
			}
			if err := qry.Exec(); err != nil {
				return err
			}
		}
	}
	return nil
}

// Remove will delete(non-logged) node records from different Blob stores(node tables).
func (b *blobStore) Remove(ctx context.Context, storesBlobsIds ...BlobsPayload[sop.UUID]) error {
	if connection == nil {
		return fmt.Errorf("Cassandra connection is closed, 'call GetConnection(config) to open it")
	}
	// Delete per blob table the Node "blobs".
	for _, storeBlobIds := range storesBlobsIds {
		paramQ := make([]string, len(storeBlobIds.Blobs))
		idsAsIntfs := make([]interface{}, len(storeBlobIds.Blobs))
		for i := range storeBlobIds.Blobs {
			paramQ[i] = "?"
			idsAsIntfs[i] = interface{}(gocql.UUID(storeBlobIds.Blobs[i]))
		}
		deleteStatement := fmt.Sprintf("DELETE FROM %s.%s WHERE id in (%v);",
			connection.Config.Keyspace, storeBlobIds.BlobTable, strings.Join(paramQ, ", "))
		qry := connection.Session.Query(deleteStatement, idsAsIntfs...).WithContext(ctx)
		if connection.Config.ConsistencyBook.BlobStoreRemove > gocql.Any {
			qry.Consistency(connection.Config.ConsistencyBook.BlobStoreRemove)
		}
		if err := qry.Exec(); err != nil {
			return err
		}
	}
	return nil
}
