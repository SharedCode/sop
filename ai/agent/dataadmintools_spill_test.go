package agent

import (
	"context"
	"fmt"
	"os"
	"testing"
	"time"

	"github.com/sharedcode/sop"
	"github.com/sharedcode/sop/ai/database"
)

// MockStore for testing spilling without full DB setup if possible,
// but since we need real Store semantics for FindOne/Next, we'll use a real temporary DB.

func TestJoinRight_SpillToDisk(t *testing.T) {
	// 1. Setup Engine & Context
	ctx := context.Background()

	// Create a temporary database path
	dbName := "test_spill_db"
	dbPath := fmt.Sprintf("/tmp/%s_%d", dbName, time.Now().UnixNano())
	defer os.RemoveAll(dbPath)

	// Define Resolver
	resolver := func(name string) (Database, error) {
		// Just return a new DB based on requested name.
		// In a real scenario, this would look up config.
		// For test, we hijack it to return our temp DB.
		if name == dbName || name == "temp_db_name_if_any" {
			return database.NewDatabase(sop.DatabaseOptions{
				StoresFolders: []string{dbPath},
			}), nil
		}
		// For temp store generated by RightOuterJoinStoreCursor, it might ask for a DB.
		// RightOuterJoinStoreCursor calls engine.OpenStore(ctx, map[string]any{"name": tsName})
		// engine.OpenStore defaults to checking "database" arg, or variable.
		// If "transaction" is not provided, it fails?
		// Wait, engine.OpenStore checks:
		// if txName == "" { try finding default }

		return nil, fmt.Errorf("db not found: %s", name)
	}

	engine := NewScriptEngine(NewScriptContext(), resolver)

	// Open DB (Registers it in context if assigned, but here we just verify it works)
	// We need to register it in engine.Context.Databases manually?
	// No, OpenDB returns it. But for the Transaction to use it, it needs to be known?
	// The script "op" usually assigns the result to a variable.
	// But in Go code we are calling engine methods directly.

	// Create DB Instance
	db, _ := resolver(dbName)
	// We need to put it in engine context so BeginTx can find it?
	engine.Context.Databases[dbName] = db

	// Begin Tx
	// engine.BeginTx looks up "database" arg.
	t1, err := engine.BeginTx(ctx, map[string]any{
		"name":     "tx1",
		"mode":     "write",
		"database": dbName,
	})
	if err != nil {
		t.Fatalf("BeginTx failed: %v", err)
	}
	// Register transaction manually if BeginTx doesn't automatically put it in Context.Transactions?
	// engine.BeginTx returns sop.Transaction. The script logic stores it.
	// The engine method just returns it.
	engine.Context.Transactions["tx1"] = t1

	defer engine.RollbackTx(ctx, map[string]any{"name": "tx1"})

	// 2. Setup Right Store (Driver)
	// Add some items
	rightStoreName := "right_store"
	rs, err := engine.OpenStore(ctx, map[string]any{
		"name":        rightStoreName,
		"transaction": "tx1",
		"database":    dbName,
		"create":      true,
	})
	if err != nil {
		t.Fatalf("OpenStore right failed: %v", err)
	}

	// Add 10 items to right store
	for i := 0; i < 10; i++ {
		rs.Add(ctx, fmt.Sprintf("k%d", i), map[string]any{
			"id":   i,
			"name": fmt.Sprintf("R%d", i),
		})
	}

	// 3. Setup Left Input (Memory List -> Cursor)
	// We want to force a spill. Let's set spill threshold to 5.
	// We will provide a cursor that yields 20 items.
	// Items 0-9 match Right items. Items 10-19 are extra.

	items := make([]any, 20)
	for i := 0; i < 20; i++ {
		items[i] = map[string]any{
			"ref_id": i,
			"desc":   fmt.Sprintf("L%d", i),
		}
	}
	leftCursor := &ListCursor{items: items}

	// 4. Initialize RightOuterJoinStoreCursor manually to set SpillThreshold
	// ON: right.id = left.ref_id
	// Inverted ON: {id: ref_id}

	cursor := &RightOuterJoinStoreCursor{
		rightStore:     rs,
		leftCursor:     leftCursor,
		on:             map[string]any{"id": "ref_id"},
		ctx:            ctx,
		engine:         engine,
		spillThreshold: 5, // Force Spill!
	}
	defer cursor.Close()

	// 5. Consume Results
	count := 0
	matches := 0

	for {
		item, ok, err := cursor.Next(ctx)
		if err != nil {
			t.Fatalf("Next failed: %v", err)
		}
		if !ok {
			break
		}
		count++

		m := item.(map[string]any)
		// Verify join correctness
		rName := m["name"]
		lDesc := m["desc"]

		t.Logf("Row: %+v", m)

		if rName != nil && lDesc != nil {
			matches++
		}
	}

	// 6. Verify Spill happened
	if cursor.tempStore == nil {
		t.Error("Expected tempStore to be initialized (Spill did not happen)")
	} else {
		t.Log("Spill successfully triggered (TempStore exists)")
	}

	// 7. Verify Results
	// Right has 10 items. All should match because Left has 0-19.
	// So we expect 10 results, all fully matched.
	if count != 10 {
		t.Errorf("Expected 10 results, got %d", count)
	}
	if matches != 10 {
		t.Errorf("Expected 10 full matches, got %d", matches)
	}
}
