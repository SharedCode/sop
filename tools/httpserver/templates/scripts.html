{{define "scripts"}}
<script>
    window.onerror = function(message, source, lineno, colno, error) {
        console.error("GLOBAL ERROR CAUGHT:", message, "at", source, ":", lineno, ":", colno);
        return false; // Let default handler run
    };

    let currentDatabase = null;
    let currentStore = null;
    let firstKey = null;
    let lastKey = null;
    let currentStoreInfo = null;
    let currentItemKey = null;
    
    // Environment Flags
    // ALLOW_INVALID_MAP_KEY: If true, allows saving a store with Map Key type without
    // requiring an Index Specification or CEL Expression. Controlled by SOP_ALLOW_INVALID_MAP_KEY env var.
    const ALLOW_INVALID_MAP_KEY = {{ .AllowInvalidMapKey }};
    let currentItems = [];
    let currentKeyColumnWidth = '45%';
    let columnWidths = [];
    let availableDatabases = [];

    // Load Databases on Start
    fetch('/api/databases')
        .then(res => res.json())
        .then(databases => {
            availableDatabases = databases;
            const select = document.getElementById('database-select');
            select.innerHTML = '';
            if (!databases || databases.length === 0) {
                const opt = document.createElement('option');
                opt.textContent = "No databases found";
                select.appendChild(opt);
                showSetupWizard();
                return;
            }
            
            // Show database switcher only if we have multiple databases
            if (databases.length > 1) {
                document.getElementById('database-section').style.display = 'block';
            }

            const userDBs = databases.filter(db => !db.is_system);
            const systemDBs = databases.filter(db => db.is_system);

            userDBs.forEach(db => {
                const opt = document.createElement('option');
                opt.value = db.name;
                opt.textContent = db.name + (db.mode === 'clustered' ? ' (Clustered)' : '');
                select.appendChild(opt);
            });

            if (systemDBs.length > 0) {
                if (userDBs.length > 0) {
                    const separator = document.createElement('option');
                    separator.disabled = true;
                    separator.textContent = "──────────";
                    select.appendChild(separator);
                }

                systemDBs.forEach(db => {
                    const opt = document.createElement('option');
                    opt.value = db.name;
                    opt.textContent = "⚠️ " + db.name + " (System)";
                    opt.className = "option-system";
                    // Inline style for better compatibility across browsers/OS
                    opt.style.color = "var(--danger-bg)"; 
                    opt.style.fontWeight = "bold";
                    select.appendChild(opt);
                });
            }

            // Select logic with persistence
            const savedDB = localStorage.getItem('sop_current_database');
            const targetDB = databases.find(d => d.name === savedDB);

            if (targetDB) {
                 select.value = targetDB.name;
                 selectDatabase(targetDB.name);
            } else if (userDBs.length > 0) {
                selectDatabase(userDBs[0].name);
            } else if (systemDBs.length > 0) {
                selectDatabase(systemDBs[0].name);
            }
        })
        .catch(err => {
            console.error(err);
            document.getElementById('database-select').innerHTML = '<option>Error loading databases</option>';
        });

    function selectDatabase(name, forceRefresh = false, storeToSelect = null) {
        if (!forceRefresh && currentDatabase === name) return;

        // Check for unsaved changes
        if (!closeDetail()) {
            // Revert selection
            const select = document.getElementById('database-select');
            if (select && currentDatabase) {
                select.value = currentDatabase;
            }
            return;
        }

        currentDatabase = name;
        localStorage.setItem('sop_current_database', name);
        currentStore = null;
        document.getElementById('store-list').innerHTML = '<li>Loading...</li>';
        document.getElementById('current-store-title').textContent = 'Select a Store';
        document.getElementById('data-grid').innerHTML = '';
        document.getElementById('toolbar').style.display = 'none';
        document.getElementById('pagination').style.display = 'none';
        document.getElementById('pagination-top').style.display = 'none';
        
        // Reset DB Options
        document.getElementById('db-options-section').style.display = 'none';
        document.getElementById('db-options-content').innerHTML = 'Loading...';
        
        fetch(`/api/stores?database=${encodeURIComponent(name)}`)
            .then(res => res.json())
            .then(stores => {
                const list = document.getElementById('store-list');
                list.innerHTML = '';
                if (!stores || stores.length === 0) {
                    list.innerHTML = '<li>No stores found</li>';
                    return;
                }
                stores.forEach(store => {
                    const li = document.createElement('li');
                    li.textContent = store.charAt(0).toUpperCase() + store.slice(1);
                    li.onclick = () => selectStore(store, li);
                    list.appendChild(li);

                    if (storeToSelect && store === storeToSelect) {
                        selectStore(store, li);
                    }
                });
            })
            .catch(err => {
                const list = document.getElementById('store-list');
                list.innerHTML = `<li class="error-text">Error: ${err.message}</li>`;
            });

        // Fetch DB Options
        fetch(`/api/db/options?database=${encodeURIComponent(name)}`)
            .then(res => res.json())
            .then(opts => {
                const section = document.getElementById('db-options-section');
                const content = document.getElementById('db-options-content');
                section.style.display = 'block';
                
                let html = '';
                
                // Display Mode (Type)
                // L2CacheType: 2=Redis (Clustered), others (0=NoCache, 1=InMemory) = Standalone
                const typeStr = (opts.cache_type === 2) ? "Clustered" : "Standalone";
                html += `<div style="margin-bottom: 5px;"><strong>Type:</strong> ${typeStr}</div>`;

                if (opts.stores_folders && opts.stores_folders.length > 0) {
                    html += '<strong>Stores Folders:</strong><ul style="margin: 5px 0; padding-left: 20px; list-style-type: disc;">';
                    opts.stores_folders.forEach(f => {
                        // Shorten path logic:
                        // Only shorten if length > 27 characters
                        let shortPath = f;
                        if (f.length > 27) {
                            // Split by / or \
                            const parts = f.split(/[/\\]/).filter(p => p.length > 0);
                            if (parts.length > 2) {
                                shortPath = '../' + parts[parts.length - 2] + '/' + parts[parts.length - 1];
                            }
                        }
                        
                        // Escape for JS string
                        const safePath = f.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                        
                        html += `<li style="cursor: copy; padding: 2px 0;" 
                                     title="${f} (Click to Copy)"
                                     onclick="navigator.clipboard.writeText('${safePath}').then(() => { const el = this; const orig = el.style.color; el.style.color = '#4caf50'; setTimeout(() => el.style.color = orig, 500); });">
                                    ${shortPath}
                                 </li>`;
                    });
                    html += '</ul>';
                }
                
                if (opts.erasure_config && Object.keys(opts.erasure_config).length > 0) {
                    html += '<details><summary style="cursor: pointer; font-weight: bold; margin-bottom: 5px;">Erasure Config</summary><pre style="margin: 0; font-size: 10px; overflow-x: visible;">' + JSON.stringify(opts.erasure_config, null, 2) + '</pre></details>';
                }

                if (opts.redis_config) {
                    html += '<details><summary style="cursor: pointer; font-weight: bold; margin-bottom: 5px;">Redis Config</summary><pre style="margin: 0; font-size: 10px; overflow-x: visible;">' + JSON.stringify(opts.redis_config, null, 2) + '</pre></details>';
                }
                
                if (!html) {
                    html = 'No specific options found.';
                }
                content.innerHTML = html;
            })
            .catch(err => {
                console.error("Failed to fetch DB options", err);
                document.getElementById('db-options-content').innerHTML = '<span class="error-text">Failed to load options</span>';
                document.getElementById('db-options-section').style.display = 'block';
            });
    }

    function isStoreReadOnly(info) {
        if (!info) return true;
        
        const hasIndex = info.indexSpec && info.indexSpec.index_fields && info.indexSpec.index_fields.length > 0;
        const hasCel = !!info.celExpression;
        const isPrimitiveMetadata = info.isPrimitiveKey;
        
        let isPrimitiveData = false;
        if (info.count > 0 && info.sampleKey !== undefined && info.sampleKey !== null) {
             const t = typeof info.sampleKey;
             if (t !== 'object' || Array.isArray(info.sampleKey)) {
                 isPrimitiveData = true;
             }
        }
        
        const hasSchema = hasIndex || hasCel || isPrimitiveMetadata || isPrimitiveData;
        return !hasSchema;
    }

    function selectStore(name, element, force = false) {
        if (currentStore === name && !force) return;

        // Close detail panel as it may be showing data from previous store
        if (!closeDetail()) return;

        currentStore = name;
        columnWidths = []; // Reset column widths
        
        // Highlight active
        document.querySelectorAll('#sidebar li').forEach(el => el.classList.remove('active'));
        element.classList.add('active');

        // Show Delete Button
        const deleteBtn = document.getElementById('btn-delete-store');
        deleteBtn.style.display = 'inline-block';
        deleteBtn.title = `Delete store '${name}'`;

        // Show Code Button
        const codeBtn = document.getElementById('btn-code-store');
        codeBtn.style.display = 'inline-block';
        codeBtn.title = `Generate Code for '${name}'`;

        // Show Edit Store Button
        const editBtn = document.getElementById('btn-edit-store');
        editBtn.style.display = 'none';

        // Show View Store Button
        const viewBtn = document.getElementById('btn-view-store');
        viewBtn.style.display = 'none';

        // Show Edit CEL Button
        const celBtn = document.getElementById('btn-edit-cel');
        celBtn.style.display = 'none'; // Hidden in favor of Edit Store
        // celBtn.style.display = 'inline-block';
        // celBtn.title = `Edit '${name}' CEL expression`;

        // Fetch Store Info
        fetch(`/api/store/info?database=${encodeURIComponent(currentDatabase)}&name=${encodeURIComponent(name)}`)
            .then(res => res.json())
            .then(info => {
                currentStoreInfo = info;

                // Toggle Edit/View buttons based on count
                // NOTE: We now use the Edit button for ALL stores (populated or empty).
                // The Edit modal handles read-only fields for populated stores.
                editBtn.style.display = 'inline-block';
                editBtn.title = `Edit Store Metadata for '${name}'`;
                viewBtn.style.display = 'none'; // Hide the old read-only view button
                
                /*
                if (info.count > 0) {
                    viewBtn.style.display = 'inline-block';
                    viewBtn.title = `View Store Details for '${name}'`;
                    editBtn.style.display = 'none';
                } else {
                    editBtn.style.display = 'inline-block';
                    editBtn.title = `Edit Store '${name}'`;
                    viewBtn.style.display = 'none';
                }
                */

                // Use name for display, description for tooltip
                let displayTitle = info.name;
                if (displayTitle) {
                    displayTitle = displayTitle.charAt(0).toUpperCase() + displayTitle.slice(1);
                }
                const titleElem = document.getElementById('current-store-title');
                titleElem.textContent = displayTitle;
                if (info.description) {
                    titleElem.title = info.description;
                } else {
                    titleElem.removeAttribute('title');
                }

                buildSearchUI(info);
                loadItems('first');
            });
    }

    function deleteStore() {
        if (!currentStore) return;
        
        const name = prompt(`Please type the store name '${currentStore}' to confirm deletion:`);
        if (name === null) return; // User cancelled prompt
        
        if (name.trim().toLowerCase() !== currentStore.toLowerCase()) {
            alert("Store name does not match. Deletion cancelled.");
            return;
        }

        fetch('/api/store/delete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                database: currentDatabase,
                store: currentStore
            })
        })
        .then(async res => {
            if (!res.ok) {
                const text = await res.text();
                throw new Error(text || res.statusText);
            }
            return res.json();
        })
        .then(data => {
            if (data.status === 'ok') {
                alert("Store deleted successfully.");
                currentStore = null;
                document.getElementById('current-store-title').textContent = "Select a Store";
                
                // Hide all store-specific buttons
                document.getElementById('btn-delete-store').style.display = 'none';
                document.getElementById('btn-code-store').style.display = 'none';
                document.getElementById('btn-edit-store').style.display = 'none';
                document.getElementById('btn-view-store').style.display = 'none';
                document.getElementById('btn-edit-cel').style.display = 'none';

                document.getElementById('data-grid').innerHTML = '';
                document.getElementById('toolbar').style.display = 'none';
                // Refresh list
                selectDatabase(currentDatabase, true);
            } else {
                alert("Error: " + (data.error || "Unknown error"));
            }
        })
        .catch(err => alert("Error: " + err));
    }

    function buildSearchUI(info) {
        const toolbar = document.getElementById('toolbar');
        toolbar.innerHTML = ''; // Clear existing
        toolbar.style.display = 'flex';
        toolbar.style.flexWrap = 'wrap';

        // Helper to trigger search
        const triggerSearch = () => {
            loadItems('search').then(items => {
                if (items && items.length > 0) {
                    const firstRow = document.querySelector('#items-table tbody tr');
                    if (firstRow) {
                        showDetail(firstRow, items[0], false);
                        firstRow.scrollIntoView({ block: 'nearest' });
                    }
                }
            });
        };

        if (info.indexSpec && info.indexSpec.index_fields) {
            // Complex Key with Index Spec
            info.indexSpec.index_fields.forEach(field => {
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `search-field-${field.field_name}`;
                input.placeholder = `${field.field_name} (${field.ascending_sort_order ? 'Asc' : 'Desc'})`;
                input.style.marginRight = '5px';
                input.style.flex = '1 1 150px'; // Allow wrapping
                input.tabIndex = 0;
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') triggerSearch();
                });
                toolbar.appendChild(input);
            });
        } else if (info.sampleKey && typeof info.sampleKey === 'object' && info.sampleKey !== null) {
            // Inferred Complex Key from Sample
            // Sort keys to be deterministic
            const keys = Object.keys(info.sampleKey).sort();
            keys.forEach(key => {
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `search-field-${key}`;
                input.placeholder = key;
                input.style.marginRight = '5px';
                input.style.flex = '1 1 150px'; // Allow wrapping
                input.tabIndex = 0;
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') triggerSearch();
                });
                toolbar.appendChild(input);
            });
        } else {
            // Primitive Key or no spec
            const input = document.createElement('input');
            input.type = 'text';
            input.id = 'search-input';
            input.placeholder = 'Search keys...';
            input.style.flex = '1';
            input.tabIndex = 0;
            toolbar.appendChild(input);
        }

        const btn = document.createElement('button');
        btn.textContent = 'Search';
        btn.title = "Search for items in the store based on the key or index fields.";
        btn.onclick = triggerSearch;
        btn.tabIndex = 0;
        toolbar.appendChild(btn);

        // Add Enter key support for simple search input
        const simpleInput = document.getElementById('search-input');
        if (simpleInput) {
            simpleInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') btn.click();
            });
        }

        const refreshBtn = document.createElement('button');
        refreshBtn.textContent = 'Refresh';
        refreshBtn.title = "Refreshes the selected store's currently displayed data. Useful when wanting to fetch latest data from the database";
        refreshBtn.onclick = () => loadItems('current', firstKey);
        refreshBtn.style.marginLeft = '10px';
        refreshBtn.tabIndex = 0;
        toolbar.appendChild(refreshBtn);

        // Only show Add Item for non-registry stores (Macros are too complex to add manually)
        // Determine if store has "Schema" (Add/Delete Allowed)
        const isReadOnly = isStoreReadOnly(info);

        if (info.description !== "AI Models Registry" && !isReadOnly) {
            const addBtn = document.createElement('button');
            addBtn.textContent = 'Add Item';
            addBtn.title = "Add a new item to the store.";
            addBtn.onclick = () => showAdd();
            addBtn.classList.add('btn-success');
            addBtn.style.marginLeft = '10px';
            addBtn.tabIndex = 0;
            addBtn.id = 'btn-add-item';
            toolbar.appendChild(addBtn);
        } else if (isReadOnly) {
            const warning = document.createElement('span');
            warning.textContent = "⚠️ Read-Only (No Index/CEL)";
            warning.title = "This store does not have an explicit Index Specification or CEL Expression. Adding or deleting items is disabled because the key structure is not strictly defined. Please migrate to a new store with a defined schema.";
            warning.style.marginLeft = '10px';
            warning.style.color = 'var(--warning-text)';
            warning.style.fontSize = '12px';
            warning.style.alignSelf = 'center';
            toolbar.appendChild(warning);
        }
    }

    let userSelectedColumns = null; // Set of strings, or null if show all
    let allDetectedColumns = []; // List of all columns detected in currentItems
    let showSelectionColumn = false; // Toggle for checkbox column
    let selectedItems = new Set(); // Set of keys selected for deletion

    function toggleSelection(checkbox) {
        const key = checkbox.getAttribute('data-key');
        if (checkbox.checked) {
            selectedItems.add(key);
        } else {
            selectedItems.delete(key);
        }
        updateDeleteButton();
        
        // Update Select All checkbox state
        const allCheckboxes = document.querySelectorAll('.row-checkbox');
        const allChecked = Array.from(allCheckboxes).every(cb => cb.checked);
        const selectAllCb = document.getElementById('cb-select-all');
        if (selectAllCb) selectAllCb.checked = allChecked;
    }

    function toggleSelectAll(checkbox) {
        const checkboxes = document.querySelectorAll('.row-checkbox');
        checkboxes.forEach(cb => {
            cb.checked = checkbox.checked;
            const key = cb.getAttribute('data-key');
            if (checkbox.checked) {
                selectedItems.add(key);
            } else {
                selectedItems.delete(key);
            }
        });
        updateDeleteButton();
    }

    function updateDeleteButton() {
        const btn = document.getElementById('btn-bulk-delete');
        if (btn) {
            // Check if Read-Only (No Index Spec AND No CEL)
            const isReadOnly = isStoreReadOnly(currentStoreInfo);

            if (showSelectionColumn && !isReadOnly) {
                btn.style.display = 'flex';
                btn.disabled = selectedItems.size === 0;
                btn.style.opacity = selectedItems.size === 0 ? '0.5' : '1';
                btn.title = `Delete ${selectedItems.size} selected item(s), no questions asked`;
            } else {
                btn.style.display = 'none';
            }
        }
    }

    async function deleteSelectedItems() {
        if (selectedItems.size === 0) return;
        
        const keysToDelete = Array.from(selectedItems);
        let successCount = 0;
        let failCount = 0;

        const btn = document.getElementById('btn-bulk-delete');
        const originalContent = btn.innerHTML;
        btn.innerHTML = '<span style="font-size: 12px;">...</span>';
        btn.disabled = true;

        const batchSize = 5;
        for (let i = 0; i < keysToDelete.length; i += batchSize) {
            const batch = keysToDelete.slice(i, i + batchSize);
            await Promise.all(batch.map(async (keyStr) => {
                try {
                    let keyVal;
                    try {
                        keyVal = JSON.parse(keyStr);
                    } catch {
                        keyVal = keyStr;
                    }

                    const payload = {
                        database: currentDatabase,
                        store: currentStore,
                        key: keyVal
                    };

                    const response = await fetch('/api/store/item/delete', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (response.ok) {
                        successCount++;
                    } else {
                        failCount++;
                        console.error(`Failed to delete ${keyStr}`);
                    }
                } catch (e) {
                    failCount++;
                    console.error(e);
                }
            }));
        }

        btn.innerHTML = originalContent;
        btn.disabled = false;
        
        selectedItems.clear();
        updateDeleteButton();
        loadItems('current', firstKey);
        
        if (failCount > 0) {
            alert(`Deleted ${successCount} items. Failed to delete ${failCount} items.`);
        }
    }

    function renderGrid(items) {
        const grid = document.getElementById('data-grid');
        const pagination = document.getElementById('pagination');
        const paginationTop = document.getElementById('pagination-top');
        
        if (!items || items.length === 0) {
            grid.innerHTML = '<p>No items found. <button onclick="loadItems(\'first\')" title="Go to the first page of items.">Go to First</button></p>';
            pagination.style.display = 'none';
            paginationTop.style.display = 'none';
            return;
        }

        // --- FLATTENING LOGIC (Retrofit) ---
        // Flatten Key and Value into a single object for display.
        const flatItems = items.map(item => {
            const flat = {};
            
            // 1. Flatten Key
            let k = item.key;
            // Try parse string JSON (Legacy/StringDB support)
            if (typeof k === 'string' && k.trim().startsWith('{')) {
                try { k = JSON.parse(k); } catch(e){}
            }
            
            if (k !== null && typeof k === 'object' && !Array.isArray(k)) {
                Object.assign(flat, k);
            } else {
                // Primitive Key
                flat['Key'] = item.key;
            }

            // 2. Flatten Value
            let v = item.value;
            // Try parse string JSON
            if (typeof v === 'string' && v.trim().startsWith('{') && !v.includes('"type":"Buffer"')) { // Avoid buffer objects if possible
                try { v = JSON.parse(v); } catch(e){}
            }

            if (v !== null && typeof v === 'object' && !Array.isArray(v)) {
                 // Priority to Key fields: only add Value fields if they don't exist in Key
                 Object.keys(v).forEach(k => {
                     // Check exact match and case-insensitive match against existing keys
                     // This prevents showing both "Name" (key) and "name" (value) or duplicates
                     const isDuplicate = flat.hasOwnProperty(k) || 
                                       Object.keys(flat).some(existingKey => existingKey.toLowerCase() === k.toLowerCase());
                     
                     if (!isDuplicate) {
                         flat[k] = v[k];
                     }
                 });
            } else if (v !== undefined) {
                 if (!flat.hasOwnProperty('Value')) {
                     flat['Value'] = item.value;
                 }
            }
            
            // Metadata for UI operations (Keep hidden)
            flat.__original_key = item.key;
            flat.__original_value = item.value;
            
            return flat;
        });

        // --- COLUMN DETECTION ---
        let columns = new Set();
        flatItems.forEach(item => {
            Object.keys(item).forEach(k => {
                if (k !== '__original_key' && k !== '__original_value') {
                    columns.add(k);
                }
            });
        });
        
        let cols = Array.from(columns);

        // --- APPLY INDEX SPEC SORTING ---
        if (typeof currentStoreInfo !== 'undefined' && currentStoreInfo && currentStoreInfo.indexSpec && Array.isArray(currentStoreInfo.indexSpec.index_fields)) {
            const specFields = currentStoreInfo.indexSpec.index_fields.map(f => f.field_name);
            const sortedCols = [];
            const visited = new Set();

            // 1. Add columns defined in IndexSpecification
            specFields.forEach(f => {
                if (columns.has(f)) {
                    sortedCols.push(f);
                    visited.add(f);
                }
            });

            // 2. Add remaining columns
            cols.forEach(c => {
                if (!visited.has(c)) {
                    sortedCols.push(c);
                }
            });
            
            cols = sortedCols;
        }

        // Store all detected columns for the selector
        allDetectedColumns = cols;

        // Filter based on user selection
        if (userSelectedColumns) {
            cols = cols.filter(c => userSelectedColumns.has(c));
        }

        // --- DYNAMIC TABLE GENERATION ---
        let html = '<table id="items-table"><thead><tr>';
        
        if (showSelectionColumn) {
             html += '<th style="width: 40px; text-align: center;"><input type="checkbox" id="cb-select-all" onchange="toggleSelectAll(this)"></th>';
        }
        
        // Identify Index Fields for Styling
        const indexFieldSet = new Set();
        if (typeof currentStoreInfo !== 'undefined' && currentStoreInfo && currentStoreInfo.indexSpec && Array.isArray(currentStoreInfo.indexSpec.index_fields)) {
             currentStoreInfo.indexSpec.index_fields.forEach(f => indexFieldSet.add(f.field_name));
        }
        
        // Render Columns
        cols.forEach((col, index) => {
             let style = '';
             if (columnWidths[index]) style = `style="width: ${columnWidths[index]}"`;
             
             // Determine class: th-key for index columns, th-val for others
             const headerClass = indexFieldSet.has(col) ? 'th-key' : 'th-val';
             
             html += `<th class="${headerClass}" ${style}>${col} <div class="col-resizer" onmousedown="initColResize(event)"></div></th>`;
        });
        
        html += '</tr></thead><tbody>';
        
        flatItems.forEach(item => {
            // Reconstruct original item context for Detail View / OnClick
            const originalItem = { key: item.__original_key, value: item.__original_value };
            // Escape single quotes for the onclick attribute
            const itemJson = JSON.stringify(originalItem).replace(/'/g, "&#39;");
            
            html += `<tr onclick='showDetail(this, ${itemJson})'>`;
            
            if (showSelectionColumn) {
                // Serialize key for storage/comparison
                const keyStr = typeof item.__original_key === 'object' ? JSON.stringify(item.__original_key) : String(item.__original_key);
                const isChecked = selectedItems.has(keyStr) ? 'checked' : '';
                // Escape for HTML attribute
                const safeKey = keyStr.replace(/'/g, "&#39;").replace(/"/g, "&quot;");
                
                html += `<td style="text-align: center;" onclick="event.stopPropagation()">
                            <input type="checkbox" class="row-checkbox" onchange="toggleSelection(this)" data-key='${safeKey}' ${isChecked}>
                         </td>`;
            }
            
            // Render Cells
            cols.forEach(col => {
                let val = item[col];
                
                // Formatting
                if (typeof val === 'object') {
                    if (val === null) {
                        val = 'null';
                    } else {
                        val = JSON.stringify(val);
                    }
                }
                if (val === undefined) val = '';
                
                let displayVal = val;
                // Truncate Steps column if too long
                if (col.toLowerCase() === 'steps' && String(val).length > 18) {
                    displayVal = '{...}';
                }

                html += `<td title="${String(val).replace(/"/g, '&quot;')}">${displayVal}</td>`;
            });
            
            html += '</tr>';
        });
        html += '</tbody></table>';
        grid.innerHTML = html;
    }

    function showColumnSelector() {
        const modal = document.getElementById('column-modal');
        const list = document.getElementById('column-list');
        list.innerHTML = '';

        // Special Option: Selection Checkbox
        const divSelect = document.createElement('div');
        divSelect.style.marginBottom = '10px';
        divSelect.style.paddingBottom = '10px';
        divSelect.style.borderBottom = '1px solid var(--border-color)';
        divSelect.innerHTML = `<label><input type="checkbox" id="col-show-selection" ${showSelectionColumn ? 'checked' : ''}> <strong>Enable Selection / Bulk Delete</strong></label>`;
        list.appendChild(divSelect);

        if (allDetectedColumns.length === 0) {
            list.innerHTML += '<p>No columns detected. Load data first.</p>';
        } else {
            const uniqueCols = [...new Set(allDetectedColumns)];
            
            const divAll = document.createElement('div');
            divAll.innerHTML = `<label><input type="checkbox" id="col-select-all" onchange="toggleAllColumns(this)"> <strong>Select All Columns</strong></label>`;
            list.appendChild(divAll);

            uniqueCols.forEach(col => {
                const div = document.createElement('div');
                const checked = !userSelectedColumns || userSelectedColumns.has(col) ? 'checked' : '';
                div.innerHTML = `<label><input type="checkbox" class="col-checkbox" value="${col}" ${checked}> ${col}</label>`;
                list.appendChild(div);
            });
        }
        
        modal.style.display = 'flex';
    }

    function toggleAllColumns(source) {
        const checkboxes = document.querySelectorAll('.col-checkbox');
        checkboxes.forEach(cb => cb.checked = source.checked);
    }

    function applyColumns() {
        // Save Selection Column State
        const selectionCheckbox = document.getElementById('col-show-selection');
        if (selectionCheckbox) {
            showSelectionColumn = selectionCheckbox.checked;
            // Reset selection if disabled
            if (!showSelectionColumn) {
                selectedItems.clear();
            }
            updateDeleteButton();
        }

        // Save current column widths before rebuilding
        const existingTable = document.getElementById('items-table');
        if (existingTable) {
            const ths = existingTable.querySelectorAll('th');
            if (ths.length > 0) {
                // If the first column is the selection checkbox, skip it when saving widths
                // We check if the first TH contains the select-all checkbox
                let startIndex = 0;
                const firstTh = ths[0];
                if (firstTh.querySelector('#cb-select-all')) {
                    startIndex = 1;
                }
                columnWidths = Array.from(ths).slice(startIndex).map(th => th.style.width);
            }
        }

        const checkboxes = document.querySelectorAll('.col-checkbox');
        const selected = new Set();
        checkboxes.forEach(cb => {
            if (cb.checked) selected.add(cb.value);
        });
        
        const allCheckboxes = document.querySelectorAll('.col-checkbox');
        if (selected.size === allCheckboxes.length) {
            userSelectedColumns = null;
        } else {
            userSelectedColumns = selected;
        }
        
        renderGrid(currentItems);
        document.getElementById('column-modal').style.display = 'none';
    }

    function loadItems(action = 'first', refKey = null, keepPanel = false) {
        if (!currentStore || !currentDatabase) return;

        const btn = document.getElementById('btn-save');
        if (btn && !btn.disabled) {
             if (!confirm("You have unsaved changes. Loading new items will discard them. Continue?")) {
                 return Promise.reject("Cancelled by user");
             }
             // User confirmed discard. Force close to reset state.
             closeDetail(true);
             keepPanel = false;
        }

        // Check if panel is open to preserve it
        const panel = document.getElementById('detail-panel');
        const wasOpen = (panel.style.display === 'block' || panel.style.display === 'flex');
        
        // If keepPanel is explicitly true (e.g. from saveItem), we respect it.
        // Otherwise, we default to closing it UNLESS it was already open (for navigation).
        // However, for pagination (action != 'current'), we might want to keep it open 
        // but we can't show the "same" item. 
        // The user request is: "on Page navigation... it should not auto close so user can compare item details with preview of another record on the grid."
        // This implies the detail pane should stay open showing the *old* item until the user selects a *new* one.
        
        // So we should NOT closeDetail() here if wasOpen is true.
        // But we need to make sure we don't have a stale "selected-row" highlight that points to a row that no longer exists.
        
        // if (!keepPanel) {
        //    closeDetail(true);
        // }
        
        let url = `/api/store/items?database=${encodeURIComponent(currentDatabase)}&name=${encodeURIComponent(currentStore)}&_=${new Date().getTime()}`;
        
        if (action === 'search') {
             let query = "";
             if (currentStoreInfo && currentStoreInfo.indexSpec && currentStoreInfo.indexSpec.index_fields) {
                 // Construct JSON object from fields
                 const queryObj = {};
                 let hasValue = false;
                 currentStoreInfo.indexSpec.index_fields.forEach(field => {
                     const val = document.getElementById(`search-field-${field.field_name}`).value;
                     if (val) {
                         // Try to parse number if possible, else string
                         const numVal = Number(val);
                         queryObj[field.field_name] = isNaN(numVal) ? val : numVal;
                         hasValue = true;
                     }
                 });
                 if (hasValue) {
                     query = JSON.stringify(queryObj);
                 }
             } else if (currentStoreInfo && currentStoreInfo.sampleKey && typeof currentStoreInfo.sampleKey === 'object') {
                 // Construct JSON object from inferred fields
                 const queryObj = {};
                 let hasValue = false;
                 const keys = Object.keys(currentStoreInfo.sampleKey).sort();
                 keys.forEach(key => {
                     const el = document.getElementById(`search-field-${key}`);
                     if (el) {
                         const val = el.value;
                         if (val) {
                             // Try to parse number if possible, else string
                             const numVal = Number(val);
                             queryObj[key] = isNaN(numVal) ? val : numVal;
                             hasValue = true;
                         }
                     }
                 });
                 if (hasValue) {
                     query = JSON.stringify(queryObj);
                 }
             } else {
                 query = document.getElementById('search-input').value;
             }
             
             if (query) {
                url += `&q=${encodeURIComponent(query)}`;
             } else {
                 // If search is empty, treat as first
                 action = 'first';
                 url += `&action=${action}`;
             }
        } else {
             url += `&action=${action}`;
             if (refKey) {
                 const keyStr = typeof refKey === 'object' ? JSON.stringify(refKey) : refKey;
                 url += `&key=${encodeURIComponent(keyStr)}`;
             }
        }

        // Use NDJSON for streaming support
        return fetch(url, {
             headers: { 'Accept': 'application/x-ndjson' }
        })
            .then(async res => {
                if (!res.ok) throw new Error(res.statusText);
                const contentType = res.headers.get("content-type");
                if (contentType && contentType.includes("application/x-ndjson")) {
                    const reader = res.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    const items = [];
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop(); // Keep last incomplete line
                        for (const line of lines) {
                            if (line.trim()) {
                                try { items.push(JSON.parse(line)); } catch(e) {}
                            }
                        }
                    }
                    if (buffer.trim()) {
                        try { items.push(JSON.parse(buffer)); } catch(e) {}
                    }
                    return items;
                } else {
                    return res.json();
                }
            })
            .then(items => {
                // Save current column widths before rebuilding
                const existingTable = document.getElementById('items-table');
                if (existingTable) {
                    const ths = existingTable.querySelectorAll('th');
                    if (ths.length > 0) {
                        // If the first column is the selection checkbox, skip it when saving widths
                        let startIndex = 0;
                        const firstTh = ths[0];
                        if (firstTh.querySelector('#cb-select-all')) {
                            startIndex = 1;
                        }
                        columnWidths = Array.from(ths).slice(startIndex).map(th => th.style.width);
                    }
                }

                const grid = document.getElementById('data-grid');
                const pagination = document.getElementById('pagination');
                const paginationTop = document.getElementById('pagination-top');
                
                if (!items || items.length === 0) {
                    if (action === 'next') {
                        return items;
                    }
                    currentItems = [];
                    grid.innerHTML = '<p>No items found. <button onclick="loadItems(\'first\')" title="Go to the first page of items.">Go to First</button></p>';
                    pagination.style.display = 'none';
                    paginationTop.style.display = 'none';
                    firstKey = null;
                    lastKey = null;
                    return items;
                }

                currentItems = items;

                // Update keys
                firstKey = items[0].key;
                lastKey = items[items.length - 1].key;
                
                // Show pagination
                pagination.style.display = 'flex';
                paginationTop.style.display = 'flex';

                renderGrid(items);
                return items;
            });
    }

    function firstPage() { loadItems('first'); }
    function lastPage() { loadItems('last'); }
    function nextPage() { loadItems('next', lastKey); }
    function prevPage() { loadItems('prev', firstKey); }

    let currentItemValue = null;

    // --- Navigation Stack ---
    let viewStack = [];

    function pushView() {
        if (currentItemKey !== null) {
            viewStack.push({
                database: currentDatabase, // Save current database
                store: currentStore,
                key: currentItemKey,
                value: JSON.parse(JSON.stringify(currentItemValue)), // Deep copy (simple)
            });
        }
    }

    function popView() {
        if (viewStack.length === 0) return;
        const state = viewStack.pop();
        
        let contextChanged = false;

        // Restore Database context if changed
        if (state.database && state.database !== currentDatabase) {
             currentDatabase = state.database;
             const dbSelect = document.getElementById('db-select');
             if(dbSelect) dbSelect.value = currentDatabase;
             contextChanged = true;
        }

        // Restore Store context if changed
        if (state.store !== currentStore) {
            currentStore = state.store;
            const storeSelect = document.getElementById('store-select');
            if(storeSelect) storeSelect.value = currentStore;
            contextChanged = true;
        }

        // If context changed, reload items in background to keep Grid in sync
        if (contextChanged) {
             loadItems('first', null, true);
        }

        currentItemKey = state.key;
        currentItemValue = state.value;
        
        // Construct item wrapper
        const item = { key: currentItemKey, value: currentItemValue };
        
        showDetail(null, item, true);
    }

    // --- Script Visualizer Helper Functions ---

    function escapeHtml(unsafe) {
        if (unsafe === undefined || unsafe === null) return '';
        return String(unsafe)
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#039;");
    }

    function showToolInstructions(toolName, summary) {
        let msg = "";
        if (summary) {
            msg += "Summary:\n" + summary + "\n\n";
        }
        msg += "Tool: " + toolName;
        // The summary often contains the full args which IS the instruction for execute_script
        // msg += "\n(Full instructions are not yet available.)";
        alert(msg);
    }

    function renderScriptView(script) {
        // Ensure steps is an array
        const steps = Array.isArray(script.steps) ? script.steps : [];
        const stepsJson = JSON.stringify(steps);
        
        // Ensure name/desc are strings
        const name = script.name || '';
        const desc = script.description || '';
        const db = script.database || '';
        const cat = script.category || '';
        const ver = script.version || '';

        // Options for Database
        let dbOptions = '<option value="">(None / Portable)</option>';
        if (typeof availableDatabases !== 'undefined' && availableDatabases.length > 0) {
            availableDatabases.forEach(d => {
                const sel = d.name === db ? 'selected' : '';
                dbOptions += `<option value="${d.name}" ${sel}>${d.name}</option>`;
            });
        }

        // Back button logic for "Program Steps" header
        let stepsBackBtn = '';
        if (typeof viewStack !== 'undefined' && viewStack.length > 0) {
            stepsBackBtn = `<span onclick="popView()" style="cursor: pointer; display: inline-flex; align-items: center; color: var(--text-color); margin-right: 0;" title="Back to caller script">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
                </svg>
            </span>`;
        }

        return `
            <div id="value-form" class="script-view-container">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div class="form-group" style="flex-direction: row; align-items: center; gap: 8px;">
                        <label class="form-label" style="margin-bottom: 0;">Name</label>
                        <input type="text" class="value-input form-input" data-key="name" value="${escapeHtml(name)}" oninput="document.getElementById('btn-save').disabled=false;" style="flex: 1;">
                    </div>
                    <div class="form-group" style="flex-direction: row; align-items: center; gap: 8px;">
                        <label class="form-label" style="margin-bottom: 0;" title="Description">Desc</label>
                        <input type="text" class="value-input form-input" data-key="description" value="${escapeHtml(desc)}" oninput="document.getElementById('btn-save').disabled=false;" style="flex: 1;">
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 0px;">
                    <div class="form-group" style="flex-direction: row; align-items: center; gap: 8px;">
                         <label class="form-label" style="margin-bottom: 0;">Category</label>
                         <input type="text" class="value-input form-input" data-key="category" value="${escapeHtml(cat)}" oninput="document.getElementById('btn-save').disabled=false;" style="flex: 1;">
                    </div>
                    <div class="form-group" style="flex-direction: row; align-items: center; gap: 8px;">
                         <label class="form-label" style="margin-bottom: 0;">Context</label>
                         <select class="value-input form-input" data-key="database" onchange="document.getElementById('btn-save').disabled=false;" style="flex: 1;">
                            ${dbOptions}
                         </select>
                    </div>
                </div>

                <!-- Hidden inputs for other fields to preserve them -->
                <input type="hidden" class="value-input" data-key="version" value="${escapeHtml(ver)}">

                <!-- Steps Section -->
                <div style="margin-top: 9px; border-top: 1px solid var(--border-color); padding-top: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <div style="display: flex; align-items: center; gap: 0;">
                            ${stepsBackBtn}
                            <label class="form-label" style="font-size: 1.1em; margin-bottom: 0; margin-left: ${stepsBackBtn ? '0' : '0'};">Program Steps</label>
                            <button onclick="runScriptInEditor()" style="font-size: 12px; padding: 2px 8px; background: #28a745; border: none; color: white; cursor: pointer; margin-left: 10px;">▶ Run</button>
                        </div>
                        <button onclick="addScriptStep()" style="font-size: 12px; padding: 2px 8px;">+ Add Step</button>
                    </div>
                    
                    <!-- The Master Source of Truth for Steps -->
                    <input type="hidden" class="value-input" data-key="steps" id="hidden-steps-json" value="${escapeHtml(stepsJson)}">

                    <div id="script-steps-list" style="display: flex; flex-direction: column; gap: 8px;">
                        ${renderScriptSteps(steps)}
                    </div>

                    <!-- Execution Output -->
                    <div id="script-execution-output" style="margin-top: 15px; display: none; border-top: 1px solid var(--border-color); padding-top: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <label class="form-label">Execution Output (NDJSON Stream)</label>
                            <button onclick="document.getElementById('script-output-content').innerHTML = ''; document.getElementById('script-execution-output').style.display = 'none';" style="background: none; border: none; cursor: pointer; color: var(--text-muted); font-size: 12px;" title="Clear Output">Clear</button>
                        </div>
                        <div id="script-output-content" style="background: #1e1e1e; color: #d4d4d4; padding: 10px; font-family: monospace; border-radius: 4px; max-height: 300px; overflow-y: auto; white-space: pre-wrap; font-size: 12px;"></div>
                    </div>
                </div>
            </div>
        `;
    }

    function renderScriptSteps(steps, openIdx = -1) {
        if (!steps || steps.length === 0) {
            return '<div style="text-align: center; color: var(--text-muted); padding: 20px; border: 1px dashed var(--border-color); border-radius: 4px;">No steps defined. Add one to start programming.</div>';
        }
        return steps.map((step, idx) => renderSingleStepCard(step, idx, idx === openIdx)).join('');
    }

    function renderSingleStepCard(step, idx, isOpen) {
        // Resolve the Display Name for the step
        // We prioritize Name as the primary label ("Function"), falling back to Command/Script
        if (step.function && !step.command) {
             // Migration fix for old "function" field
             step.command = step.function;
             if (!step.type) step.type = 'command';
        }
        
        const type = step.type || 'unknown';
        
        let fn = step.name || step.command || step.script_name || step.function || 'unknown';
        if (type === 'script' || type === 'call_script') {
            // For scripts, always prioritize script_name unless an explicit Name overrides it.
            // If Name is present, we use that (step.name check above covers it).
            // But if Name is missing, we MUST use script_name, not fall through to 'command' or 'llm.generate'.
            if (!step.name && step.script_name) {
                fn = step.script_name;
            }
        }

        // Color coding
        let color = '#7f8c8d'; // Gray
        if (fn.startsWith('llm.') || type === 'ask') color = '#9b59b6'; // Purple
        else if (fn.startsWith('db.') || type === 'fetch') color = '#2ecc71'; // Green
        else if (fn.startsWith('os.') || type === 'command') color = '#e74c3c'; // Red
        else if (fn === 'loop' || type === 'loop') color = '#f39c12'; // Orange
        else if (fn === 'map' || fn === 'reduce') color = '#d35400'; // Dark Orange
        else if (type === 'call_script' || type === 'script') color = '#3498db'; // Blue for Script Calls

        const argsCount = Object.keys(step.args || {}).length;
        const outVar = step.out ? `<span style="background: var(--bg-primary); padding: 1px 4px; border-radius: 3px; border: 1px solid var(--border-color); font-size: 0.85em; margin-left: auto;">&rarr; ${escapeHtml(step.out)}</span>` : '';

        // Step Arguments Summary
        let fullSummary = '';
        if (type === 'ask' && step.prompt) fullSummary = step.prompt;
        else if (step.args && step.args.prompt) fullSummary = step.args.prompt;
        else if (step.args && step.args.query) fullSummary = step.args.query;
        else if (step.args && Object.keys(step.args).length > 0) fullSummary = JSON.stringify(step.args);
        else fullSummary = '';

        let summary = '';
        if (fullSummary.startsWith('{') || fullSummary.startsWith('[')) {
             // JSON Args Logic
             if (fullSummary.length <= 18) {
                 summary = fullSummary;
             } else {
                 summary = "{...}";
             }
        } else if (fullSummary) {
             // String/Text logic
             if (fullSummary.length > 30) {
                 summary = `"${fullSummary.substring(0, 30)}..."`;
             } else {
                 summary = `"${fullSummary}"`;
             }
        }


        // Drill Down Logic
        // Always allow drill-down if type is 'call_script'
        // Or if it looks like a custom function (not standard namespaces)
        const isStandard = fn.startsWith('llm.') || fn.startsWith('db.') || fn.startsWith('os.') || ['loop', 'map', 'reduce'].includes(fn) || ['ask', 'set', 'if', 'say'].includes(type);
        
        let shouldDrill = (type === 'call_script' || type === 'script');
        if (!shouldDrill && !isStandard && type === 'tool') {
            shouldDrill = true; // Assume custom tool is a script
        }
        
        // Target for drill down
        const drillTarget = step.script_name || fn;
        
        // --- Toolbar Button Logic ---
        // If it's drillable, show Spyglass. Otherwise show Info.
        // We now place this in the main toolbar, not next to title.
        
        let toolBtn = '';
        if (shouldDrill && drillTarget) {
             toolBtn = `<button style="padding: 4px; line-height: 0; font-size: 1.1em; z-index: 10; background: none; border: none; cursor: pointer;" onclick="event.stopPropagation(); drillDownToScript('${escapeHtml(drillTarget)}')" title="Drill into script">🔍</button>`;
        } else {
             toolBtn = `<button style="padding: 4px; line-height: 0; font-size: 1.1em; z-index: 10; background: none; border: none; cursor: pointer;" onclick="event.stopPropagation(); showToolInstructions('${escapeHtml(step.command)}', this.getAttribute('data-summary'))" data-summary="${escapeHtml(fullSummary)}" title="Instructions">ℹ️</button>`;
        }

        // Label (e.g. "call: my_script")
        const label = (type === 'call_script' || type === 'script') ? `call: ${fn}` : fn;

        let headerTitle = step.description || step.prompt || fullSummary || label;

        return `
            <div class="step-card" id="step-card-${idx}" style="border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-secondary);">
                <div class="step-header" onclick="toggleStepDetails(${idx})" style="padding: 8px; cursor: pointer; display: flex; align-items: center; gap: 10px; border-left: 4px solid ${color};">
                    <span style="font-weight: bold; font-family: monospace;" title="${escapeHtml(headerTitle)}">${escapeHtml(label)}</span>
                    <span style="color: var(--text-muted); font-size: 0.9em;" title="${escapeHtml(fullSummary)}">${escapeHtml(summary)}</span>
                    <div style="margin-left: auto; display: flex; align-items: center; gap: 0px;">
                        <button style="padding: 4px; line-height: 0; font-size: 1.1em; z-index: 10; background: none; border: none; cursor: pointer;" onclick="event.stopPropagation(); moveScriptStepUp(${idx})" title="Move Up"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"/></svg></button>
                        <button style="padding: 4px; line-height: 0; font-size: 1.1em; z-index: 10; background: none; border: none; cursor: pointer;" onclick="event.stopPropagation(); moveScriptStepDown(${idx})" title="Move Down"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"/></svg></button>
                        ${toolBtn}
                        <button style="padding: 4px; line-height: 0; font-size: 1.1em; z-index: 10; margin-left: 0px; background: none; border: none; cursor: pointer;" onclick="event.stopPropagation(); deleteScriptStep(${idx})" title="Delete Step"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg></button>
                    </div>
                </div>
                <div id="step-body-${idx}" style="display: ${isOpen ? 'block' : 'none'}; padding: 10px 10px 6px 10px; border-top: 1px solid var(--border-color); background: var(--bg-primary);">
                    <!-- We will render the form for editing this step here -->
                    ${renderStepEditForm(step, idx)}
                </div>
            </div>
        `;
    }

    function renderStepEditForm(step, idx) {
        const argsJson = JSON.stringify(step.args || {}, null, 2);
        
        // --- Type Selection ---
        const typeOptions = ['command', 'ask', 'set', 'if', 'loop', 'fetch', 'say', 'script'];
        let typeOptsHtml = '';
        typeOptions.forEach(t => {
            const sel = (step.type || 'command') === t ? 'selected' : '';
            typeOptsHtml += `<option value="${t}" ${sel}>${t}</option>`;
        });
        
        // Exact Execution Field Logic (No Magic)
        // Modified Layout: Type | Name | Output
        
        let execInput = '';
        let execLabel = '';
        
        if (step.type === 'command') {
            execLabel = `<label class="form-label" style="font-size: 0.8em; margin-bottom: 0;" title="Command">Cmd</label>`;
            execInput = `<input type="text" class="form-input" style="font-family: monospace; width: 33%;" value="${escapeHtml(step.command || '')}" onchange="updateStepField(${idx}, 'command', this.value)">`;
        } else if (step.type === 'call_script' || step.type === 'script') {
            execLabel = `<label class="form-label" style="font-size: 0.8em; margin-bottom: 0;" title="Script Name">Script</label>`;
            execInput = `<input type="text" class="form-input" style="font-family: monospace; width: 33%;" value="${escapeHtml(step.script_name || '')}" onchange="updateStepField(${idx}, 'script_name', this.value)">`;
        } else if (step.type === 'ask') {
             execLabel = `<label class="form-label" style="font-size: 0.8em; margin-bottom: 0;" title="Prompt">Prompt</label>`;
             execInput = `<input type="text" class="form-input" style="font-family: monospace; width: 33%;" value="${escapeHtml(step.prompt || '')}" onchange="updateStepField(${idx}, 'prompt', this.value)">`;
        } else if (step.type === 'set') {
             execLabel = `<label class="form-label" style="font-size: 0.8em; margin-bottom: 0;" title="Variable">Var</label>`;
             execInput = `<input type="text" class="form-input" style="font-family: monospace; width: 33%;" value="${escapeHtml(step.variable || '')}" onchange="updateStepField(${idx}, 'variable', this.value)">`;
        } else if (step.type === 'fetch') {
             execLabel = `<label class="form-label" style="font-size: 0.8em; margin-bottom: 0;" title="Resource">Res</label>`;
             execInput = `<input type="text" class="form-input" style="font-family: monospace; width: 33%;" value="${escapeHtml(step.resource || '')}" onchange="updateStepField(${idx}, 'resource', this.value)">`;
        } else if (step.type === 'say') {
             execLabel = `<label class="form-label" style="font-size: 0.8em; margin-bottom: 0;" title="Message">Msg</label>`;
             execInput = `<input type="text" class="form-input" style="font-family: monospace; width: 33%;" value="${escapeHtml(step.message || '')}" onchange="updateStepField(${idx}, 'message', this.value)">`;
        } else if (step.type === 'if') {
             execLabel = `<label class="form-label" style="font-size: 0.8em; margin-bottom: 0;" title="Condition">If</label>`;
             execInput = `<input type="text" class="form-input" style="font-family: monospace; width: 33%;" value="${escapeHtml(step.condition || '')}" onchange="updateStepField(${idx}, 'condition', this.value)">`;
        }
        
        let row2Html = '';
        if (execInput) {
             row2Html = `
            <div class="form-group" style="flex-direction: row; align-items: center; gap: 8px; margin-top: 0px;">
                ${execLabel}
                ${execInput}
                <label class="form-label" style="font-size: 0.8em; margin-bottom: 0;" title="Description">Desc</label>
                <input type="text" class="form-input" style="flex: 1;" value="${escapeHtml(step.description || '')}" onchange="updateStepField(${idx}, 'description', this.value)">
            </div>`;
        } else {
             // Fallback: Just Description row
             row2Html = `
            <div class="form-group" style="flex-direction: row; align-items: center; gap: 8px; margin-top: 0px;">
                <label class="form-label" style="font-size: 0.8em; margin-bottom: 0;" title="Description">Desc</label>
                <input type="text" class="form-input" style="flex: 1;" value="${escapeHtml(step.description || '')}" onchange="updateStepField(${idx}, 'description', this.value)">
            </div>`;
        }

        let row1 = `
            <div id="step-row1-${idx}" style="display: grid; grid-template-columns: 1.2fr 1.4fr 1.4fr; gap: 8px; margin-bottom: 0px;">
                <div class="form-group" style="flex-direction: row; align-items: center; gap: 8px;">
                    <label class="form-label" style="font-size: 0.8em; margin-bottom: 0;">Type</label>
                    <select class="form-input" style="flex: 1; padding: 2px;" onchange="updateStepField(${idx}, 'type', this.value)">
                        ${typeOptsHtml}
                    </select>
                </div>
                <div class="form-group" style="flex-direction: row; align-items: center; gap: 8px;">
                    <label class="form-label" style="font-size: 0.8em; margin-bottom: 0;">Name</label>
                    <input type="text" class="form-input" style="font-family: monospace; flex: 1;" value="${escapeHtml(step.name || '')}" onchange="updateStepField(${idx}, 'name', this.value)">
                </div>
                <div class="form-group" style="flex-direction: row; align-items: center; gap: 8px;">
                    <label class="form-label" style="font-size: 0.8em; margin-bottom: 0;" title="Output Variable">Output</label>
                    <input type="text" class="form-input" style="font-family: monospace; flex: 1;" value="${escapeHtml(step.out || '')}" onchange="updateStepField(${idx}, 'out', this.value)">
                </div>
            </div>`;

        return `
            ${row1}
            <div id="step-row2-${idx}">${row2Html}</div>
            <div class="form-group" style="margin-top: 2px; margin-bottom: 8px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <label class="form-label" style="font-size: 0.8em; margin-bottom: 0;">Args(JSON)</label>
                        <span onclick="openArgsModal(${idx})" style="cursor: pointer; padding: 2px;" title="Open in Editor">
                             <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.814z"/>
                                <path fill-rule="evenodd" d="M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5v11z"/>
                             </svg>
                        </span>
                    </div>
                </div>
                <textarea id="args-input-${idx}" class="form-input" style="font-family: monospace; height: 56px; max-height: 200px; font-size: 0.9em; width: 100%; box-sizing: border-box; white-space: nowrap; overflow-x: auto;" onchange="updateStepField(${idx}, 'args', this.value)">${escapeHtml(JSON.stringify(step.args || {}))}</textarea>
            </div>
        `;
    }

    let currentEditingStepIdx = -1;

    function openArgsModal(idx) {
        currentEditingStepIdx = idx;
        const input = document.getElementById(`args-input-${idx}`);
        const modal = document.getElementById('args-modal');
        const modalInput = document.getElementById('args-modal-input');
        
        if (!input || !modal || !modalInput) return;
        
        try {
            const json = JSON.parse(input.value);
            modalInput.value = JSON.stringify(json, null, 4);
        } catch(e) {
            modalInput.value = input.value;
        }
        
        modal.style.display = 'flex';
        modalInput.focus();
    }

    function saveArgsFromModal() {
        if (currentEditingStepIdx === -1) return;
        
        const modalInput = document.getElementById('args-modal-input');
        const input = document.getElementById(`args-input-${currentEditingStepIdx}`);
        
        if (input && modalInput) {
            try {
                // Minify or reformat to compact JSON
                const json = JSON.parse(modalInput.value);
                // Keep it relatively compact in the list view? Or just stringify.
                input.value = JSON.stringify(json);
                updateStepField(currentEditingStepIdx, 'args', input.value);
            } catch(e) {
                alert("Invalid JSON: " + e.message);
                return;
            }
        }
        
        closeArgsModal();
    }

    function closeArgsModal() {
        document.getElementById('args-modal').style.display = 'none';
        currentEditingStepIdx = -1;
    }
    
    // Legacy function placeholder if needed
    function toggleArgsEditor(idx) {
        openArgsModal(idx);
    }

    // Dirty State Management for Item Details
    function markItemDirty() {
        const btn = document.getElementById('btn-save');
        const icon = document.getElementById('btn-save-icon');
        if (btn) {
             btn.disabled = false;
             // Visual Cue: Blue color when dirty
             btn.style.color = '#3498db'; 
             if (icon) icon.style.color = '#3498db';
        }
    }

    function markItemClean() {
        const btn = document.getElementById('btn-save');
        const icon = document.getElementById('btn-save-icon');
        if (btn) {
             btn.disabled = true;
             // Reset color
             btn.style.color = 'var(--text-color)';
             if (icon) icon.style.color = 'currentColor';
        }
    }

    function toggleStepDetails(idx) {
        const body = document.getElementById(`step-body-${idx}`);
        if (body.style.display === 'none') {
            body.style.display = 'block';
        } else {
            body.style.display = 'none';
        }
    }

    // State Management for Steps
    // We read from the hidden input, modify, and write back
    
    function getStepsFromDOM() {
        const el = document.getElementById('hidden-steps-json');
        try {
            return JSON.parse(el.value);
        } catch(e) { return []; }
    }

    function saveStepsToDOM(steps, openIdx = -1) {
        const el = document.getElementById('hidden-steps-json');
        el.value = JSON.stringify(steps);
        // Refresh the list view
        document.getElementById('script-steps-list').innerHTML = renderScriptSteps(steps, openIdx);
        // Enable main save button
        document.getElementById('btn-save').disabled = false;
    }

    function updateStepField(idx, field, value) {
        const steps = getStepsFromDOM();
        if (!steps[idx]) return;

        if (field === 'args') {
            try {
                steps[idx].args = JSON.parse(value);
            } catch (e) {
                alert("Invalid JSON for arguments");
                return;
            }
        } else {
            steps[idx][field] = value;
        }
        saveStepsToDOM(steps, idx);
    }

    async function runScriptInEditor() {
        const nameInput = document.querySelector('input[data-key="name"]');
        const catInput = document.querySelector('input[data-key="category"]');
        const name = nameInput ? nameInput.value : '';
        const category = catInput ? catInput.value : 'general';
        
        if (!name) {
            alert("Script must have a name to run.");
            return;
        }

        const outputDiv = document.getElementById('script-execution-output');
        const contentDiv = document.getElementById('script-output-content');
        if (outputDiv) outputDiv.style.display = 'block';
        if (contentDiv) {
            contentDiv.innerHTML = '<div style="color: #fff;">Initializing execution...</div>';
            contentDiv.innerHTML += '<div style="color: #e74c3c; font-size: 0.9em;">Note: Runs the SAVED version of the script. Verify "Save" is disabled (saved).</div>';
        }

        try {
            const response = await fetch('/api/scripts/execute', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: name,
                    category: category,
                    args: {} 
                })
            });

            if (!response.ok) {
                const text = await response.text();
                if (contentDiv) contentDiv.innerHTML += `<div style="color: #e74c3c;">HTTP Error: ${response.status} - ${text}</div>`;
                return;
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            
            // State for rendering
            let currentTableRecords = [];
            
            const flushRecords = () => {
                if (currentTableRecords.length > 0) {
                    // We can reuse renderDataResults if we can access it, or inline a simple table renderer
                    // Since renderDataResults is in scope (global-ish), let's try to use it
                    // But we need to adapt it to append to contentDiv instead of chat-history
                     const container = document.createElement('div');
                     container.className = 'chat-message ai-table-container';
                     
                     // Simple Table renderer reuse
                     // We manually construct table for the editor output
                     const records = currentTableRecords;
                     if (records.length > 0) {
                        const table = document.createElement('table');
                        table.className = 'data-table';
                        table.style.width = '100%';
                        table.style.fontSize = '0.9em';
                        
                        // Headers
                        const keys = Object.keys(records[0]);
                        const thead = document.createElement('thead');
                        const trHead = document.createElement('tr');
                        keys.forEach(k => {
                            const th = document.createElement('th');
                            th.textContent = k;
                            th.style.textAlign = 'left';
                            trHead.appendChild(th);
                        });
                        thead.appendChild(trHead);
                        table.appendChild(thead);
                        
                        // Body
                        const tbody = document.createElement('tbody');
                        records.forEach(r => {
                            const tr = document.createElement('tr');
                            keys.forEach(k => {
                                const td = document.createElement('td');
                                let val = r[k];
                                if (typeof val === 'object') val = JSON.stringify(val);
                                td.textContent = String(val);
                                tr.appendChild(td);
                            });
                            tbody.appendChild(tr);
                        });
                        table.appendChild(tbody);
                        container.appendChild(table);
                     }
                     
                     contentDiv.appendChild(container);
                     currentTableRecords = [];
                     contentDiv.scrollTop = contentDiv.scrollHeight;
                }
            };

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');
                
                for (const line of lines) {
                    if (!line.trim()) continue;
                    try {
                        const event = JSON.parse(line);
                        
                        if (event.type === 'step_start') {
                            flushRecords();
                            const el = document.createElement('div');
                            el.style.marginTop = '10px';
                            el.style.borderBottom = '1px solid #444';
                            el.style.paddingBottom = '4px';
                            // console.log("step_start event:", event); // Debug in console
                            const stepPrefix = (event.step_index !== undefined && event.step_index !== null) ? `Step ${event.step_index}` : 'Step';
                            el.innerHTML = `<span style="color: #64b5f6;">▶ ${stepPrefix}: Executing</span> <code>${event.command || 'unknown'}</code>`; // Removed inline debug
                            contentDiv.appendChild(el);
                            contentDiv.appendChild(el);
                        } else if (event.type === 'ask') {
                            flushRecords();
                            const el = document.createElement('div');
                            el.style.marginTop = '10px';
                            el.style.borderBottom = '1px solid #444';
                            el.style.paddingBottom = '4px';
                            const stepPrefix = event.step_index ? `Step ${event.step_index}` : 'Step (No Index)';
                            // Escape prompt to avoid HTML injection issues, though prompt is usually safe text.
                            // But cleaner is setting textContent for the variable part.
                            // However, using innerHTML for structure.
                            const promptSafe = (event.prompt || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            el.innerHTML = `<span style="color: #64b5f6;">▶ ${stepPrefix} Ask:</span> "${promptSafe}"`;
                            contentDiv.appendChild(el);

                            const res = event.record || event.result;
                            if (res) {
                                const resEl = document.createElement('div');
                                resEl.style.marginTop = '4px';
                                resEl.style.whiteSpace = 'pre-wrap';
                                if (typeof res === 'object') {
                                     resEl.textContent = JSON.stringify(res, null, 2);
                                } else {
                                     resEl.textContent = res;
                                }
                                contentDiv.appendChild(resEl);
                            }
                        } else if (event.type === 'record') {
                            const rec = event.record || event.result || event.payload;
                            if (rec) {
                                currentTableRecords.push(rec);
                            }
                        } else if (event.type === 'error') {
                            flushRecords();
                            const el = document.createElement('div');
                            el.style.color = '#e74c3c';
                            el.innerHTML = `<strong>Error:</strong> ${event.error}`;
                            contentDiv.appendChild(el);
                        } else {
                            // Fallback for other events
                            flushRecords();
                            const el = document.createElement('div');
                            el.style.color = '#aaa';
                            el.textContent = JSON.stringify(event);
                            contentDiv.appendChild(el);
                        }
                        
                        contentDiv.scrollTop = contentDiv.scrollHeight;

                    } catch (e) {
                         // Maybe not JSON?
                         if (contentDiv) {
                            const el = document.createElement('div');
                            el.textContent = line;
                            contentDiv.appendChild(el);
                         }
                    }
                }
            }
            flushRecords();
            
            if (contentDiv) {
                const end = document.createElement('div');
                end.innerHTML = '<span style="color: #2ecc71;">Done.</span>';
                contentDiv.appendChild(end);
                contentDiv.scrollTop = contentDiv.scrollHeight;
            }

        } catch (e) {
            if (contentDiv) contentDiv.innerHTML += `<div style="color: red;">Exception: ${e.message}</div>`;
        }
    }

    function addScriptStep() {
        const steps = getStepsFromDOM();
        steps.push({
            type: "command",
            name: "Generate",
            command: "llm.generate",
            args: { prompt: "New instruction" },
            out: "result"
        });
        const newIdx = steps.length - 1;
        saveStepsToDOM(steps, newIdx);
        
        setTimeout(() => {
             const newBody = document.getElementById(`step-body-${newIdx}`);
             if(newBody) newBody.scrollIntoView({ behavior: 'smooth' });
        }, 50);
    }

    function deleteScriptStep(idx) {
        if(!confirm("Delete this step?")) return;
        const steps = getStepsFromDOM();
        steps.splice(idx, 1);
        saveStepsToDOM(steps);
    }

    function moveScriptStepUp(idx) {
        if (idx <= 0) return;
        const steps = getStepsFromDOM();
        [steps[idx - 1], steps[idx]] = [steps[idx], steps[idx - 1]];
        saveStepsToDOM(steps);
    }

    function moveScriptStepDown(idx) {
        const steps = getStepsFromDOM();
        if (idx >= steps.length - 1) return;
        [steps[idx + 1], steps[idx]] = [steps[idx], steps[idx + 1]];
        saveStepsToDOM(steps);
    }

    // --- End Script Visualizer ---

    function showDetail(row, item, autoOpen = true) {
        console.log("showDetail called. Store:", currentStore); // Debug
        
        // Check for unsaved changes if panel is open
        const panel = document.getElementById('detail-panel');
        const wasOpen = (panel.style.display === 'block' || panel.style.display === 'flex');

        if (wasOpen) {
             const btn = document.getElementById('btn-save');
             if (btn && !btn.disabled) {
                 if (!confirm("You have unsaved changes. Are you sure you want to discard them?")) {
                     return;
                 }
             }
        }

        // Highlight selected row
        if (row) {
            document.querySelectorAll('#items-table tr').forEach(tr => tr.classList.remove('selected-row'));
            row.classList.add('selected-row');
        }

        currentItemKey = item.key;
        currentItemValue = item.value;
        
        // Try to parse value if it's a string (e.g. stored as JSON string)
        if (typeof currentItemValue === 'string') {
            try {
                const parsed = JSON.parse(currentItemValue);
                if (typeof parsed === 'object' && parsed !== null) {
                    // Check if it's a byte array
                    const isByteArray = Array.isArray(parsed) && parsed.every(n => typeof n === 'number');
                    if (!isByteArray) {
                        currentItemValue = parsed;
                        // Update item.value locally so the rest of the function uses the object
                        item.value = parsed;
                    }
                }
            } catch (e) {
                console.error("Failed to parse value as JSON:", e);
            }
        }

        // If panel was closed and autoOpen is false, just return (after setting currentItemKey and highlight)
        if (!wasOpen && !autoOpen) {
            return;
        }

        const viewer = document.getElementById('json-viewer');
        
        // Format Key Display
        let keyStr = "";
        if (typeof item.key === 'object' && item.key !== null) {
            // Reorder key fields based on IndexSpec
            let orderedKey = {};
            let keyFields = Object.keys(item.key);
            
            if (currentStoreInfo && currentStoreInfo.indexSpec && currentStoreInfo.indexSpec.index_fields) {
                const indexOrder = currentStoreInfo.indexSpec.index_fields.map(f => f.field_name);
                keyFields.sort((a, b) => {
                    const idxA = indexOrder.indexOf(a);
                    const idxB = indexOrder.indexOf(b);
                    if (idxA !== -1 && idxB !== -1) return idxA - idxB;
                    if (idxA !== -1) return -1;
                    if (idxB !== -1) return 1;
                    return a.localeCompare(b);
                });
            }
            
            keyFields.forEach(k => {
                orderedKey[k] = item.key[k];
            });
            keyStr = JSON.stringify(orderedKey, null, 2);
        } else {
            keyStr = item.key;
        }
        
        // Debug Info on UI
        // (Removed debug message)

        let valueHtml = '';
        let isScriptView = false;
        
        // Check if Value is a Byte Array (Blob)
        let isBlob = false;
        if (Array.isArray(currentItemValue) && currentItemValue.every(n => typeof n === 'number')) {
            isBlob = true;
        }

        if (isBlob) {
             // Blob View (Raw JSON Array)
             const len = currentItemValue.length;
             const jsonStr = JSON.stringify(currentItemValue);
             valueHtml = `
                <div style="margin-bottom: 5px; font-size: 12px; color: var(--text-muted);">Byte Array (${len} bytes)</div>
                <textarea id="edit-value" oninput="markItemDirty()" style="width: 100%; height: 300px; font-family: monospace; margin-top: 5px;" class="form-input">${jsonStr}</textarea>
            `;
        } else if (typeof currentItemValue === 'object' && currentItemValue !== null) {
            
            // Check if this is a script store
            isScriptView = currentStore && currentStore.toLowerCase() === 'scripts';
            
            if (isScriptView) {
                 valueHtml = renderScriptView(currentItemValue);
            } else {
                // Form View
                valueHtml = '<div id="value-form" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; padding-right: 2px;">';
                const keys = Object.keys(currentItemValue);
                if (keys.length === 0) {
                     valueHtml += '<em>Empty Object</em>';
                }
                keys.forEach(key => {
                    let val = currentItemValue[key];
                    let displayVal = val;
                    if (typeof val === 'object') {
                        displayVal = JSON.stringify(val);
                    }
                    // Escape quotes for attribute
                    const safeVal = String(displayVal).replace(/"/g, '&quot;');
                    
                    valueHtml += `
                        <div class="form-group" style="display: flex; flex-direction: column;">
                            <label class="form-label">${key}</label>
                            <input type="text" class="value-input form-input" data-key="${key}" value="${safeVal}" 
                                oninput="markItemDirty()">
                        </div>
                    `;
                });
                valueHtml += '</div>';
            }
        } else {
            // Primitive View (Textarea)
            const valStr = JSON.stringify(currentItemValue, null, 2);
            valueHtml = `<textarea id="edit-value" oninput="markItemDirty()" style="width: 100%; height: 300px; font-family: monospace; margin-top: 5px;" class="form-input">${valStr}</textarea>`;
        }

        // Back Button Logic
        let backBtn = '';
        // If it is a Script View, renderScriptView handles the Back button logic (Steps Section).
        // If it is a Standard View (JSON/Primitive), we show the Back button here.
        if (!isScriptView && viewStack.length > 0) {
            backBtn = `<button onclick="popView()" style="padding: 2px 8px; font-size: 12px; margin-right: 10px;" title="Go back to previous item.">⬅ Back</button>`;
        }

        viewer.innerHTML = `
            <div style="margin-bottom: 0px; display: flex; align-items: flex-start; gap: 8px;">
                <strong style="margin-top: 5px;">Key:</strong>
                <pre class="pre-block" title="${keyStr.replace(/"/g, '&quot;')}" style="margin: 0; flex: 1; padding: 4px; overflow: hidden; height: 38px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; white-space: pre-wrap; word-break: break-all;">${keyStr.replace(/\n/g, ' ')}</pre>
            </div>
            <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                <strong>Value:</strong>
                <div style="display: flex; align-items: center;">
                    ${backBtn}
                    <button onclick="closeDetail()" style="padding: 2px 8px; font-size: 12px;" title="Close the item details panel.">Close</button>
                </div>
            </div>
            <div style="margin-bottom: 10px;">
                ${valueHtml}
            </div>
            <div style="display: flex; gap: 10px;">
                <!-- Save Button (Icon) -->
                <!-- Color #3498db is applied when dirty via markItemDirty() -->
                <button id="btn-save" onclick="saveItem()" disabled title="Save changes to the item" style="background: none; border: none; padding: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: var(--text-color);">
                    <svg id="btn-save-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16" style="transition: color 0.2s ease;">
                        <path d="M11 2H9v3h2z"/>
                        <path d="M1.5 0h11.586a1.5 1.5 0 0 1 1.06.44l1.415 1.414A1.5 1.5 0 0 1 16 2.914V14.5a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 14.5v-13A1.5 1.5 0 0 1 1.5 0M1 1.5v13a.5.5 0 0 0 .5.5H2v-4.5A1.5 1.5 0 0 1 3.5 9h9a1.5 1.5 0 0 1 1.5 1.5V15h.5a.5.5 0 0 0 .5-.5V2.914a.5.5 0 0 0-.146-.353l-1.415-1.415A.5.5 0 0 0 13.086 1H13v4.5A1.5 1.5 0 0 1 11.5 7h-7A1.5 1.5 0 0 1 3 5.5V1H1.5a.5.5 0 0 0-.5.5m3 4a.5.5 0 0 0 .5.5h7a.5.5 0 0 0 .5-.5V1H4zM3 15h10v-4.5a.5.5 0 0 0-.5-.5h-9a.5.5 0 0 0-.5.5z"/>
                    </svg>
                </button>
                
                <!-- Delete Button (Icon) -->
                <button onclick="deleteItem()" title="Delete this item from the store" style="background: none; border: none; padding: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: var(--text-color);">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                        <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                    </svg>
                </button>
            </div>
        `;

        // Disable Key Editing (Implicitly handled as Key is displayed in <pre>)
        // But we should check if we need to disable Value editing for some reason?
        // No, Value updates are allowed.
        
        // However, if the store is Read-Only (No Index Specs/CEL), we should disable Delete button here too.
        const isReadOnly = isStoreReadOnly(currentStoreInfo);
        
        if (isReadOnly) {
            const delBtn = viewer.querySelector('.btn-danger');
            if (delBtn) {
                delBtn.disabled = true;
                delBtn.title = "Deletion is disabled for stores without an Index Specification or CEL Expression.";
                delBtn.style.opacity = '0.5';
                delBtn.style.cursor = 'not-allowed';
            }
        }

        document.getElementById('detail-resizer').style.display = 'block';
        panel.style.display = 'flex';
    }

    function saveItem() {
        if (!currentStore || currentItemKey === null) return;

        let newVal;
        const form = document.getElementById('value-form');
        
        if (form) {
            // Reconstruct object from form
            newVal = Array.isArray(currentItemValue) ? [] : {};
            const inputs = form.querySelectorAll('.value-input');
            
            inputs.forEach(input => {
                const key = input.getAttribute('data-key');
                const rawVal = input.value;
                const originalVal = currentItemValue[key];
                
                // Type conversion
                let finalVal = rawVal;
                
                // Force JSON parse for 'steps' to ensure array, even if originalVal was missing/null
                if(key === 'steps') {
                     try { finalVal = JSON.parse(rawVal); } catch(e) { finalVal = []; }
                } else if (typeof originalVal === 'number') {
                    finalVal = Number(rawVal);
                } else if (typeof originalVal === 'boolean') {
                    finalVal = (rawVal.toLowerCase() === 'true');
                } else if (typeof originalVal === 'object' && originalVal !== null) {
                    try {
                        finalVal = JSON.parse(rawVal);
                    } catch {
                        // Fallback to string if parse fails
                        finalVal = rawVal;
                    }
                }
                
                newVal[key] = finalVal;
            });
        } else {
            const valText = document.getElementById('edit-value').value;
            try {
                newVal = JSON.parse(valText);
            } catch (e) {
                alert("Invalid JSON in Value field");
                return;
            }
        }

        const payload = {
            database: currentDatabase,
            store: currentStore,
            key: currentItemKey,
            value: newVal
        };

        const btn = document.getElementById('btn-save');
        // Visual feedback: Disable while saving
        btn.disabled = true;
        btn.style.opacity = '0.5';

        fetch('/api/store/item/update', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(res => {
            if (!res.ok) return res.text().then(t => { throw new Error(t) });
            return res.json();
        })
        .then(() => {
            // Success: Reset button state
            btn.style.opacity = '1';
            markItemClean();
            
            // Update local state so subsequent edits work correctly
            currentItemValue = newVal;

            // Refresh the grid in background to show updated values
            return loadItems('current', firstKey, true).then(newItems => {
                // Re-highlight the saved item
                if (newItems && newItems.length > 0) {
                    const savedKeyStr = JSON.stringify(currentItemKey);
                    const targetIndex = newItems.findIndex(item => JSON.stringify(item.key) === savedKeyStr);
                    
                    if (targetIndex >= 0) {
                        const rows = document.querySelectorAll('#items-table tbody tr');
                        if (rows && rows[targetIndex]) {
                            // Just highlight, don't re-open detail as it's already open
                            document.querySelectorAll('#items-table tr').forEach(tr => tr.classList.remove('selected-row'));
                            rows[targetIndex].classList.add('selected-row');
                        }
                    }
                }
            });
        })
        .catch(err => {
            const msg = "Update failed: " + err.message + "\n\n" +
                        "Another user may have modified this record (Swarm conflict).\n" +
                        "Please refresh the data to see the latest changes.";
            alert(msg);
            btn.style.opacity = '1';
            markItemDirty(); // Re-enable so user can try again
        });
    }

    function deleteItem() {
        if (!currentStore || currentItemKey === null) return;
        
        // Check if Read-Only (No Index Spec AND No CEL)
        if (isStoreReadOnly(currentStoreInfo)) {
            alert("Deletion is disabled for stores without an Index Specification or CEL Expression.");
            return;
        }

        showConfirm("Are you sure you want to delete this item?", () => {
            performDelete();
        });
    }

    function performDelete() {
        const payload = {
            database: currentDatabase,
            store: currentStore,
            key: currentItemKey
        };

        fetch('/api/store/item/delete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(res => {
            if (!res.ok) return res.text().then(t => { throw new Error(t) });
            return res.json();
        })
        .then(() => {
            // Find index of deleted item to determine next selection
            let targetIndex = -1;
            if (currentItems && currentItems.length > 0) {
                // We need to compare keys carefully (objects vs primitives)
                const deletedKeyStr = JSON.stringify(currentItemKey);
                targetIndex = currentItems.findIndex(item => JSON.stringify(item.key) === deletedKeyStr);
            }

            loadItems('current', firstKey).then(newItems => {
                if (!newItems || newItems.length === 0) {
                    closeDetail();
                    return;
                }
                
                // Try to select item at same index, or last item if index out of bounds
                if (targetIndex >= 0) {
                    if (targetIndex >= newItems.length) {
                        targetIndex = newItems.length - 1;
                    }
                    // We need to find the row element to pass to showDetail for highlighting
                    // Since we just reloaded, we can find it by index in the table
                    const rows = document.querySelectorAll('#items-table tbody tr');
                    if (rows && rows[targetIndex]) {
                        showDetail(rows[targetIndex], newItems[targetIndex], false);
                    } else {
                        showDetail(null, newItems[targetIndex], false);
                    }
                } else {
                    // Fallback to first item if we couldn't track index
                    const rows = document.querySelectorAll('#items-table tbody tr');
                    if (rows && rows[0]) {
                        showDetail(rows[0], newItems[0], false);
                    } else {
                        showDetail(null, newItems[0], false);
                    }
                }
            });
        })
        .catch(err => {
            alert("Delete failed: " + err.message);
        });
    }

    let currentConfirmHandler = null;

    function closeConfirmModal() {
        document.getElementById('confirm-modal').style.display = 'none';
        if (currentConfirmHandler) {
            document.removeEventListener('keydown', currentConfirmHandler, true);
            currentConfirmHandler = null;
        }
    }

    function showConfirm(message, onConfirm) {
        const modal = document.getElementById('confirm-modal');
        const msgEl = document.getElementById('confirm-message');
        const okBtn = document.getElementById('confirm-ok');
        const cancelBtn = document.getElementById('confirm-cancel');

        msgEl.textContent = message;
        modal.style.display = 'flex';

        // Setup click handlers
        okBtn.onclick = () => {
            closeConfirmModal();
            onConfirm();
        };
        cancelBtn.onclick = () => {
            closeConfirmModal();
        };

        // Remove existing handler if any (safety)
        if (currentConfirmHandler) {
            document.removeEventListener('keydown', currentConfirmHandler, true);
        }

        // Define new handler
        currentConfirmHandler = function(e) {
            const isTab = e.key === 'Tab';
            const isEscape = e.key === 'Escape';
            const isLeft = e.key === 'ArrowLeft';
            const isRight = e.key === 'ArrowRight';
            const isEnter = e.key === 'Enter';

            if (isEscape) {
                e.preventDefault();
                e.stopImmediatePropagation();
                closeConfirmModal();
                return;
            }

            if (isTab || isLeft || isRight) {
                e.preventDefault();
                e.stopImmediatePropagation();
                
                const activeEl = document.activeElement;
                
                // Toggle logic:
                // If on Cancel -> Go to OK
                // If on OK -> Go to Cancel
                // If anywhere else -> Go to Cancel (Safe default)
                if (activeEl === cancelBtn) {
                    okBtn.focus();
                } else {
                    cancelBtn.focus();
                }
            }
            
            if (isEnter) {
                e.preventDefault();
                e.stopImmediatePropagation();
                // Trigger click on the focused element if it's one of our buttons
                if (document.activeElement === okBtn || document.activeElement === cancelBtn) {
                    document.activeElement.click();
                }
            }
        };

        // Add key handler
        document.addEventListener('keydown', currentConfirmHandler, true);

        // Force focus to Cancel button
        requestAnimationFrame(() => {
            cancelBtn.focus();
        });
    }

    function showAdd() {
        const modal = document.getElementById('add-modal');
        const keyContainer = document.getElementById('add-key-container');
        const valContainer = document.getElementById('add-value-container');
        const keyModeToggle = document.getElementById('add-key-mode-toggle');
        const valModeToggle = document.getElementById('add-value-mode-toggle');
        const keyModeWrapper = document.getElementById('add-key-mode-wrapper');
        const valModeWrapper = document.getElementById('add-value-mode-wrapper');
        
        keyContainer.innerHTML = '';
        valContainer.innerHTML = '';
        keyModeToggle.checked = false;
        valModeToggle.checked = false;
        
        // Reset visibility
        if (keyModeWrapper) keyModeWrapper.style.display = 'block';
        if (valModeWrapper) valModeWrapper.style.display = 'block';

        // --- Build Key UI ---
        let keySchema = [];
        // 1. Infer from data first (most accurate for full struct)
        if (currentItems && currentItems.length > 0 && typeof currentItems[0].key === 'object' && currentItems[0].key !== null) {
            keySchema = Object.keys(currentItems[0].key);
        } 
        // 2. Fallback to IndexSpec
        else if (currentStoreInfo && currentStoreInfo.indexSpec && currentStoreInfo.indexSpec.index_fields) {
            keySchema = currentStoreInfo.indexSpec.index_fields.map(f => f.field_name);
        }
        // 3. Fallback to Sample Key
        else if (currentStoreInfo && currentStoreInfo.sampleKey && typeof currentStoreInfo.sampleKey === 'object') {
            keySchema = Object.keys(currentStoreInfo.sampleKey).sort();
        }

        if (keySchema.length > 0) {
            // Reorder keySchema based on IndexSpec if available
            if (currentStoreInfo && currentStoreInfo.indexSpec && currentStoreInfo.indexSpec.index_fields) {
                const indexOrder = currentStoreInfo.indexSpec.index_fields.map(f => f.field_name);
                // Sort keySchema: index fields first (in order), then others
                keySchema.sort((a, b) => {
                    const idxA = indexOrder.indexOf(a);
                    const idxB = indexOrder.indexOf(b);
                    if (idxA !== -1 && idxB !== -1) return idxA - idxB;
                    if (idxA !== -1) return -1;
                    if (idxB !== -1) return 1;
                    return a.localeCompare(b);
                });
            }

            // Complex Key Form
            keySchema.forEach(fieldName => {
                const div = document.createElement('div');
                div.style.marginBottom = '5px';
                div.innerHTML = `
                    <label style="display:block; font-size:12px; font-weight:bold;">${fieldName}</label>
                    <input type="text" class="add-key-field" data-name="${fieldName}" style="width:100%; padding:5px; border:1px solid var(--input-border); border-radius:3px; background: var(--input-bg); color: var(--text-color); box-sizing: border-box;">
                `;
                keyContainer.appendChild(div);
            });
        } else {
            // Simple Key or Unknown Schema -> JSON Mode
            keyModeToggle.checked = true;
            renderAddKeyJson();
            // Hide toggle if primitive (no schema)
            if (keyModeWrapper) keyModeWrapper.style.display = 'none';
        }

        // --- Build Value UI ---
        let useForm = false;
        let valueSchema = [];
        let isArray = false;

        // 1. Fallback to Sample Value
        if (currentStoreInfo && currentStoreInfo.sampleValue) {
            if (Array.isArray(currentStoreInfo.sampleValue)) {
                isArray = true;
            } else if (typeof currentStoreInfo.sampleValue === 'object') {
                valueSchema = Object.keys(currentStoreInfo.sampleValue);
            }
        }

        // 2. Fallback to First Item
        if (!isArray && valueSchema.length === 0 && currentItems && currentItems.length > 0) {
            const sampleVal = currentItems[0].value;
            if (Array.isArray(sampleVal)) {
                isArray = true;
            } else if (typeof sampleVal === 'object' && sampleVal !== null) {
                valueSchema = Object.keys(sampleVal);
            }
        }

        if (isArray) {
            // Force JSON Mode for Arrays
            valModeToggle.checked = true;
            renderAddValueJson("[]");
        } else if (valueSchema.length > 0) {
            useForm = true;
            valueSchema.forEach(k => {
                const div = document.createElement('div');
                div.style.marginBottom = '5px';
                div.innerHTML = `
                    <label style="display:block; font-size:12px; font-weight:bold;">${k}</label>
                    <input type="text" class="add-value-field" data-name="${k}" style="width:100%; padding:5px; border:1px solid var(--input-border); border-radius:3px; background: var(--input-bg); color: var(--text-color); box-sizing: border-box;">
                `;
                valContainer.appendChild(div);
            });
        }

        if (!useForm && !isArray) {
            // Fallback to JSON
            valModeToggle.checked = true;
            renderAddValueJson();
            // Hide toggle if primitive
            if (valModeWrapper) valModeWrapper.style.display = 'none';
        }

        // Reset position to center
        const modalContent = document.getElementById('add-modal-content');
        if (modalContent) {
            modalContent.style.top = '50%';
            modalContent.style.left = '50%';
            modalContent.style.transform = 'translate(-50%, -50%)';
            modalContent.style.margin = '0';
        }

        modal.style.display = 'block';
    }

    function toggleAddKeyMode() {
        const isJson = document.getElementById('add-key-mode-toggle').checked;
        const container = document.getElementById('add-key-container');
        
        if (isJson) {
            // Switch to JSON
            let currentObj = {};
            const inputs = container.querySelectorAll('.add-key-field');
            if (inputs.length > 0) {
                inputs.forEach(inp => {
                    const k = inp.getAttribute('data-name');
                    currentObj[k] = parseInputVal(inp.value);
                });
                renderAddKeyJson(JSON.stringify(currentObj, null, 2));
            } else {
                renderAddKeyJson();
            }
        } else {
            // Switch to Form
            const textarea = document.getElementById('add-key-json');
            let obj = {};
            if (textarea) {
                try {
                    obj = JSON.parse(textarea.value);
                } catch {
                    alert("Invalid JSON or Primitive value, cannot switch to Form view.");
                    document.getElementById('add-key-mode-toggle').checked = true;
                    return;
                }
            }
            
            if (typeof obj === 'object' && obj !== null) {
                container.innerHTML = '';
                Object.keys(obj).forEach(k => {
                    const div = document.createElement('div');
                    div.style.marginBottom = '5px';
                    div.innerHTML = `
                        <label style="display:block; font-size:12px; font-weight:bold;">${k}</label>
                        <input type="text" class="add-key-field" data-name="${k}" value="${String(obj[k]).replace(/"/g, '&quot;')}" style="width:100%; padding:5px; border:1px solid var(--input-border); border-radius:3px; background: var(--input-bg); color: var(--text-color); box-sizing: border-box;">
                    `;
                    container.appendChild(div);
                });
            } else {
                alert("Value is not an object, cannot use Form view.");
                document.getElementById('add-key-mode-toggle').checked = true;
            }
        }
    }

    function renderAddKeyJson(content = '') {
        const container = document.getElementById('add-key-container');
        container.innerHTML = `<textarea id="add-key-json" placeholder="Key (JSON Object or simple value)" style="width:100%; height:60px; padding:5px; font-family:monospace; border:1px solid var(--input-border); border-radius:3px; background: var(--input-bg); color: var(--text-color); box-sizing: border-box;">${content}</textarea>`;
    }

    function toggleAddValueMode() {
        const isJson = document.getElementById('add-value-mode-toggle').checked;
        const container = document.getElementById('add-value-container');
        
        if (isJson) {
            // Switch to JSON
            // Try to harvest current values from form if they exist
            let currentObj = {};
            const inputs = container.querySelectorAll('.add-value-field');
            if (inputs.length > 0) {
                inputs.forEach(inp => {
                    const k = inp.getAttribute('data-name');
                    currentObj[k] = parseInputVal(inp.value);
                });
                renderAddValueJson(JSON.stringify(currentObj, null, 2));
            } else {
                renderAddValueJson();
            }
        } else {
            // Switch to Form
            // Try to parse JSON
            const textarea = document.getElementById('add-value-json');
            let obj = {};
            if (textarea) {
                try {
                    obj = JSON.parse(textarea.value);
                } catch {
                    alert("Invalid JSON, cannot switch to Form view.");
                    document.getElementById('add-value-mode-toggle').checked = true;
                    return;
                }
            }
            
            // Render Form
            container.innerHTML = '';
            if (typeof obj === 'object' && obj !== null) {
                Object.keys(obj).forEach(k => {
                    const div = document.createElement('div');
                    div.style.marginBottom = '5px';
                    div.innerHTML = `
                        <label style="display:block; font-size:12px; font-weight:bold;">${k}</label>
                        <input type="text" class="add-value-field" data-name="${k}" value="${String(obj[k]).replace(/"/g, '&quot;')}" style="width:100%; padding:5px; border:1px solid var(--input-border); border-radius:3px; background: var(--input-bg); color: var(--text-color); box-sizing: border-box;">
                    `;
                    container.appendChild(div);
                });
            } else {
                // Primitive value?
                alert("Value is not an object, cannot use Form view.");
                document.getElementById('add-value-mode-toggle').checked = true;
                renderAddValueJson(textarea ? textarea.value : '');
            }
        }
    }

    function renderAddValueJson(content = '') {
        const container = document.getElementById('add-value-container');
        container.innerHTML = `<textarea id="add-value-json" placeholder="Enter JSON Object, Array, or simple value (String, Number, Boolean)" style="width:100%; height:200px; padding:5px; font-family:monospace; border:1px solid var(--input-border); border-radius:3px; background: var(--input-bg); color: var(--text-color); box-sizing: border-box;">${content}</textarea>`;
    }

    function parseInputVal(val) {
        if (val === '') return val;
        if (!isNaN(Number(val))) return Number(val);
        if (val.toLowerCase() === 'true') return true;
        if (val.toLowerCase() === 'false') return false;
        return val;
    }

    function closeAdd() {
        document.getElementById('add-modal').style.display = 'none';
    }

    function addItem() {
        if (!currentStore) return;

        let key, val;

        // --- Construct Key ---
        const keyFields = document.querySelectorAll('.add-key-field');
        if (keyFields.length > 0) {
            // Complex Key Form
            key = {};
            keyFields.forEach(inp => {
                key[inp.getAttribute('data-name')] = parseInputVal(inp.value);
            });
        } else {
            // JSON/Simple Mode
            let keyText = "";
            const keyJsonInput = document.getElementById('add-key-json');
            const keySimpleInput = document.getElementById('add-key-simple');
            
            if (keyJsonInput) keyText = keyJsonInput.value;
            else if (keySimpleInput) keyText = keySimpleInput.value;

            keyText = keyText.trim();
            if (keyText.startsWith('{') || keyText.startsWith('[')) {
                try {
                    key = JSON.parse(keyText);
                } catch (e) {
                    alert("Invalid JSON in Key field: " + e.message);
                    return;
                }
            } else {
                // Try to parse as number if it looks like one
                if (keyText !== "" && !isNaN(Number(keyText))) {
                    key = Number(keyText);
                } else {
                    key = keyText;
                }
            }
        }

        // --- Construct Value ---
        const valFields = document.querySelectorAll('.add-value-field');
        if (valFields.length > 0) {
            // Form Mode
            val = {};
            valFields.forEach(inp => {
                val[inp.getAttribute('data-name')] = parseInputVal(inp.value);
            });
        } else {
            // JSON/Raw Mode
            const valText = document.getElementById('add-value-json').value.trim();
            
            if (valText.startsWith('{') || valText.startsWith('[')) {
                try {
                    val = JSON.parse(valText);
                } catch (e) {
                    alert("Invalid JSON in Value field: " + e.message);
                    return;
                }
            } else if (valText.startsWith('"') && valText.endsWith('"')) {
                 // Explicitly quoted string -> parse as JSON to handle escapes
                 try {
                    val = JSON.parse(valText);
                 } catch (e) {
                    alert("Invalid JSON string: " + e.message);
                    return;
                 }
            } else {
                // Primitive inference
                if (valText === 'true') val = true;
                else if (valText === 'false') val = false;
                else if (valText === 'null') val = null;
                else if (valText !== "" && !isNaN(Number(valText))) {
                    val = Number(valText);
                } else {
                    val = valText; // Treat as plain string
                }
            }
        }

        // --- Validation ---

        // 1. Check IndexSpecification Requirements (Critical)
        if (currentStoreInfo && currentStoreInfo.indexSpec && currentStoreInfo.indexSpec.index_fields) {
            if (typeof key !== 'object' || key === null) {
                alert("Error: This store requires a structured key (JSON object) to match its Index Specification.");
                return;
            }
            
            const missingIndexFields = [];
            currentStoreInfo.indexSpec.index_fields.forEach(field => {
                if (key[field.field_name] === undefined) {
                    missingIndexFields.push(field.field_name);
                }
            });

            if (missingIndexFields.length > 0) {
                alert(`Error: The key is missing required index fields:\n${missingIndexFields.join(', ')}\n\nThese fields are required for the database comparer to function.`);
                return;
            }
        }

        // 2. Check for missing fields in Key based on sample (Warning)
        if (currentItems && currentItems.length > 0) {
            const sampleKey = currentItems[0].key;
            if (typeof sampleKey === 'object' && sampleKey !== null && typeof key === 'object' && key !== null) {
                const sampleFields = Object.keys(sampleKey);
                const newFields = Object.keys(key);
                const missing = sampleFields.filter(k => !newFields.includes(k));
                
                if (missing.length > 0) {
                    if (!confirm(`Warning: The key is missing the following fields found in other items:\n${missing.join(', ')}\n\nThis might cause sorting or retrieval issues.\nDo you want to proceed?`)) {
                        return;
                    }
                }
            }
            // Check for type mismatch (Primitive vs Object)
            const sampleType = typeof sampleKey;
            const newType = typeof key;
            if (sampleType !== newType) {
                 if (!confirm(`Warning: Key type mismatch.\nExpected: ${sampleType}\nGot: ${newType}\n\nDo you want to proceed?`)) {
                    return;
                }
            }
        }

        const payload = {
            database: currentDatabase,
            store: currentStore,
            key: key,
            value: val
        };

        fetch('/api/store/item/add', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(res => {
            if (!res.ok) return res.text().then(t => { throw new Error(t) });
            return res.json();
        })
        .then(() => {
            closeAdd();
            if (!currentItems || currentItems.length <= 1) {
                loadItems('first');
            } else {
                loadItems('current', firstKey);
            }
        })
        .catch(err => {
            alert("Add failed: " + err.message);
        });
    }
    document.getElementById('detail-resizer').style.display = 'none';
    
    function closeDetail(force = false) {
        const btn = document.getElementById('btn-save');
        if (!force && btn && !btn.disabled) {
            if (!confirm("You have unsaved changes. Are you sure you want to discard them?")) {
                return false;
            }
        }
        // Reset state
        if (btn) btn.disabled = true;
        currentItemKey = null;
        currentItemValue = null;

        document.getElementById('detail-panel').style.display = 'none';
        document.getElementById('detail-resizer').style.display = 'none';
        return true;
    }

    // Resizer Logic
    const sidebar = document.getElementById('sidebar');
    const resizer = document.getElementById('resizer');

    // Mouse Events
    resizer.addEventListener('mousedown', (e) => {
        e.preventDefault();
        document.addEventListener('mousemove', resize);
        document.addEventListener('mouseup', stopResize);
        resizer.classList.add('resizing');
        document.body.style.cursor = 'col-resize';
    });

    // Touch Events (for Mobile)
    resizer.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling while dragging
        document.addEventListener('touchmove', resize, { passive: false });
        document.addEventListener('touchend', stopResize);
        resizer.classList.add('resizing');
    }, { passive: false });

    function resize(e) {
        let clientX;
        if (e.type.startsWith('touch')) {
            clientX = e.touches[0].clientX;
        } else {
            clientX = e.clientX;
        }

        const newWidth = clientX;
        // Basic constraints - relaxed for mobile
        if (newWidth > 50 && newWidth < window.innerWidth - 50) {
            sidebar.style.width = newWidth + 'px';
        }
    }

    function stopResize() {
        document.removeEventListener('mousemove', resize);
        document.removeEventListener('mouseup', stopResize);
        document.removeEventListener('touchmove', resize);
        document.removeEventListener('touchend', stopResize);
        resizer.classList.remove('resizing');
        document.body.style.cursor = 'default';
    }

    // Detail Panel Resizer
    const detailPanel = document.getElementById('detail-panel');
    const detailResizer = document.getElementById('detail-resizer');

    detailResizer.addEventListener('mousedown', (e) => {
        e.preventDefault();
        document.addEventListener('mousemove', resizeDetail);
        document.addEventListener('mouseup', stopResizeDetail);
        detailResizer.classList.add('resizing');
        document.body.style.cursor = 'col-resize';
    });

    function resizeDetail(e) {
        const newWidth = window.innerWidth - e.clientX;
        if (newWidth > 200 && newWidth < (window.innerWidth * 0.5)) {
            detailPanel.style.width = newWidth + 'px';
        }
    }

    function stopResizeDetail() {
        document.removeEventListener('mousemove', resizeDetail);
        document.removeEventListener('mouseup', stopResizeDetail);
        detailResizer.classList.remove('resizing');
        document.body.style.cursor = 'default';
    }

    // Column Resizing
    let colResizingTh = null;
    let colStartX, colStartWidth;

    function initColResize(e) {
        e.stopPropagation();
        colResizingTh = e.target.parentElement;
        colStartX = e.clientX;
        colStartWidth = parseFloat(window.getComputedStyle(colResizingTh).width);
        document.addEventListener('mousemove', doColResize, false);
        document.addEventListener('mouseup', stopColResize, false);
    }
    function doColResize(e) {
        if (colResizingTh) {
            const newWidth = colStartWidth + (e.clientX - colStartX);
            if (newWidth > 50) {
                colResizingTh.style.width = newWidth + 'px';
            }
        }
    }
    function stopColResize(e) {
        colResizingTh = null;
        document.removeEventListener('mousemove', doColResize, false);
        document.removeEventListener('mouseup', stopColResize, false);
    }

    // Keyboard Navigation
    document.addEventListener('keydown', function(e) {
        // Handle Escape for Add Modal
        if (e.key === 'Escape') {
            const addModal = document.getElementById('add-modal');
            if (addModal && addModal.style.display !== 'none') {
                closeAdd();
                e.preventDefault();
                return;
            }
            const scriptModal = document.getElementById('script-modal');
            if (scriptModal && scriptModal.style.display !== 'none') {
                closeScriptModal();
                e.preventDefault();
                return;
            }
        }

        // Only handle if not typing in an input or textarea
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        // If modal is open, do not handle grid navigation
        if (document.getElementById('confirm-modal').style.display === 'flex') return;
        if (document.getElementById('add-modal').style.display === 'flex') return;

        const selectedRow = document.querySelector('#items-table tr.selected-row');
        
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (selectedRow) {
                const nextRow = selectedRow.nextElementSibling;
                if (nextRow) {
                    const index = nextRow.sectionRowIndex;
                    if (currentItems[index]) {
                        showDetail(nextRow, currentItems[index], false);
                    }
                    nextRow.scrollIntoView({ block: 'nearest' });
                }
            } else {
                // Select first row if none selected
                const firstRow = document.querySelector('#items-table tbody tr');
                if (firstRow) {
                    const index = firstRow.sectionRowIndex;
                    if (currentItems[index]) {
                        showDetail(firstRow, currentItems[index], false);
                    }
                    firstRow.scrollIntoView({ block: 'nearest' });
                }
            }
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (selectedRow) {
                const prevRow = selectedRow.previousElementSibling;
                if (prevRow) {
                    const index = prevRow.sectionRowIndex;
                    if (currentItems[index]) {
                        showDetail(prevRow, currentItems[index], false);
                    }
                    prevRow.scrollIntoView({ block: 'nearest' });
                }
            }
        } else if (e.key === 'Delete' || e.key === 'Backspace') {
            if (selectedRow && currentItemKey !== null) {
                deleteItem();
            }
        } else if (e.key === 'Enter') {
            if (selectedRow) {
                e.preventDefault();
                const index = selectedRow.sectionRowIndex;
                if (currentItems[index]) {
                    showDetail(selectedRow, currentItems[index], true);
                }
            }
        } else if (e.key === 'Escape') {
            e.preventDefault();
            closeDetail();
        }
    });

    // --- Chat & Tabs Logic ---

    function toggleProviderSelect() {
        const agent = document.getElementById('agent-select').value;
        const providerSelect = document.getElementById('provider-select');
        // Show provider select only for RAG agents (doctor, sql_admin)
        if (agent === 'doctor' || agent === 'sql_admin') {
            providerSelect.style.display = 'inline-block';
        } else {
            providerSelect.style.display = 'none';
        }
    }

    function switchTab(tabName) {
        // Update Tabs
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.getElementById(`tab-btn-${tabName}`).classList.add('active');

        // Update Content
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById(`tab-${tabName}`).classList.add('active');
    }

    function resetChatPosition() {
        const widget = document.getElementById('chat-widget');
        
        // Mobile Detection: Check width or user agent
        const isMobile = window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        if (isMobile) {
            // On mobile, we let the CSS media query handle the full-screen layout.
            // We clear inline styles that might interfere.
            widget.style.width = '';
            widget.style.height = '';
            widget.style.left = '';
            widget.style.top = '';
            widget.style.right = '';
            widget.style.bottom = '';
            return;
        }

        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const width = 480;
        const height = 500;
        
        widget.style.width = width + 'px';
        widget.style.height = height + 'px';
        // Position at bottom-left, above the toggle button (which is ~52px from bottom)
        widget.style.left = '57px';
        widget.style.top = (viewportHeight - height + 2) + 'px';
        widget.style.right = 'auto';
        widget.style.bottom = 'auto';
    }

    // Handle resize events to adjust chat position if needed
    window.addEventListener('resize', function() {
        const widget = document.getElementById('chat-widget');
        if (widget && widget.classList.contains('active')) {
            resetChatPosition();
        }
    });

    function toggleChatWidget(forceOpen) {
        const widget = document.getElementById('chat-widget');
        const btn = document.getElementById('chat-toggle-btn');
        
        if (widget.classList.contains('active') && !forceOpen) {
            widget.classList.remove('active');
        } else {
            // Always reset position when opening to ensure it is visible and accessible
            resetChatPosition();
            
            widget.classList.add('active');
            // Focus input when opening
            setTimeout(() => document.getElementById('chat-input').focus(), 100);
        }
    }

    // --- Draggable Chat Widget Logic ---
    document.addEventListener('DOMContentLoaded', function() {
        const widget = document.getElementById('chat-widget');
        const header = widget.querySelector('.chat-header');
        let isDragging = false;
        let dragStartX, dragStartY;

        header.addEventListener('mousedown', function(e) {
            // Ignore if clicking controls or select
            if (e.target.closest('.chat-controls') || e.target.closest('select')) return;
            
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            
            // Change cursor style globally to indicate dragging
            document.body.style.cursor = 'move';
        });

        document.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            e.preventDefault();
            
            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;
            
            // Use top/left for positioning
            const rect = widget.getBoundingClientRect();
            widget.style.left = (rect.left + deltaX) + 'px';
            widget.style.top = (rect.top + deltaY) + 'px';
            
            // Clear right/bottom if they exist to avoid conflicts
            widget.style.right = 'auto';
            widget.style.bottom = 'auto';
            
            dragStartX = e.clientX;
            dragStartY = e.clientY;
        });

        document.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                document.body.style.cursor = 'default';
            }
        });

        // --- Resize Logic ---
        let isResizing = false;
        let resizeDir = '';
        let resizeStartX, resizeStartY, startWidth, startHeight, startLeft, startTop;

        const handles = widget.querySelectorAll('.resize-handle');
        handles.forEach(handle => {
            handle.addEventListener('mousedown', function(e) {
                e.stopPropagation(); // Prevent drag
                e.preventDefault(); // Prevent selection
                isResizing = true;
                resizeDir = handle.getAttribute('data-dir');
                resizeStartX = e.clientX;
                resizeStartY = e.clientY;
                
                const rect = widget.getBoundingClientRect();
                startWidth = rect.width;
                startHeight = rect.height;
                startLeft = rect.left;
                startTop = rect.top;
                
                document.body.style.cursor = window.getComputedStyle(handle).cursor;
            });
        });

        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            e.preventDefault();
            
            const deltaX = e.clientX - resizeStartX;
            const deltaY = e.clientY - resizeStartY;
            const minW = 300;
            const minH = 300;
            
            if (resizeDir.includes('e')) {
                widget.style.width = Math.max(minW, startWidth + deltaX) + 'px';
            }
            if (resizeDir.includes('s')) {
                widget.style.height = Math.max(minH, startHeight + deltaY) + 'px';
            }
            if (resizeDir.includes('w')) {
                let newWidth = startWidth - deltaX;
                if (newWidth < minW) {
                    newWidth = minW;
                    widget.style.left = (startLeft + startWidth - minW) + 'px';
                } else {
                    widget.style.left = (startLeft + deltaX) + 'px';
                }
                widget.style.width = newWidth + 'px';
            }
            if (resizeDir.includes('n')) {
                let newHeight = startHeight - deltaY;
                if (newHeight < minH) {
                    newHeight = minH;
                    widget.style.top = (startTop + startHeight - minH) + 'px';
                } else {
                    widget.style.top = (startTop + deltaY) + 'px';
                }
                widget.style.height = newHeight + 'px';
            }
        });

        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = 'default';
            }
        });
    });

    // --- Draggable Add Modal Logic (Event Delegation) ---
    (function() {
        let isDragging = false;
        let dragStartX, dragStartY;
        let initialLeft, initialTop;
        let activeModalContent = null;

        document.addEventListener('mousedown', function(e) {
            const header = e.target.closest('#add-modal-header');
            if (!header) return;
            
            const modalContent = document.getElementById('add-modal-content');
            if (!modalContent) return;

            isDragging = true;
            activeModalContent = modalContent;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            
            // If we are centered via transform, we need to switch to explicit top/left
            const rect = modalContent.getBoundingClientRect();
            modalContent.style.transform = 'none';
            modalContent.style.left = rect.left + 'px';
            modalContent.style.top = rect.top + 'px';
            modalContent.style.margin = '0';
            
            initialLeft = rect.left;
            initialTop = rect.top;
            
            document.body.style.cursor = 'move';
            e.preventDefault(); // Prevent text selection
        });

        document.addEventListener('mousemove', function(e) {
            if (!isDragging || !activeModalContent) return;
            e.preventDefault();
            
            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;
            
            activeModalContent.style.left = (initialLeft + deltaX) + 'px';
            activeModalContent.style.top = (initialTop + deltaY) + 'px';
        });

        document.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                activeModalContent = null;
                document.body.style.cursor = 'default';
            }
        });
    })();

    let chatAbortController = null;
    let chatHistory = [];
    let historyIndex = -1;

    function jsonToCSV(input) {
        try {
            let items;
            if (typeof input === 'string') {
                items = JSON.parse(input);
            } else {
                items = input;
            }

            if (!Array.isArray(items) || items.length === 0) {
                console.log("jsonToCSV: Input is not an array or empty");
                return typeof input === 'string' ? input : JSON.stringify(input);
            }

            console.log("jsonToCSV: Parsed " + items.length + " items");
            if (items.length > 0) {
                console.log("First item structure:", JSON.stringify(items[0]));
            }

            // Check if items have the specific SOP 'key'/'value' structure
            const isSopStructure = items.some(item => 
                (item && typeof item === 'object') && ('key' in item || 'value' in item));

            let headers = [];
            let csv = "";

            if (!isSopStructure) {
                // Handle generic JSON array (e.g. Script steps)
                let fields = new Set();
                items.forEach(item => {
                    if (item && typeof item === 'object') {
                        Object.keys(item).forEach(k => fields.add(k));
                    }
                });
                headers = Array.from(fields);
                csv = headers.join(", ") + "\n";
                
                items.forEach(item => {
                    let row = [];
                    headers.forEach(h => {
                        let val = item[h];
                         if (typeof val === 'object' && val !== null) {
                            val = JSON.stringify(val).replace(/"/g, '""'); 
                            val = `"${val}"`;
                        } else if (typeof val === 'string') {
                             if (val.includes(',') || val.includes('"') || val.includes('\n')) {
                                val = val.replace(/"/g, '""');
                                val = `"${val}"`;
                             }
                        } else if (val === undefined || val === null) {
                            val = "";
                        }
                        row.push(val);
                    });
                    csv += row.join(", ") + "\n";
                });
                return csv;
            }

            // Existing SOP Structure Logic
            let keyIsMap = false;
            let valueIsMap = false;
            let keyFields = new Set();
            let valueFields = new Set();

            // Check if all keys are null (e.g. projection query)
            const allKeysNull = items.every(item => item.key == null);
            // Check if all values are null (e.g. key-only query)
            const allValuesNull = items.every(item => item.value == null);

            items.forEach(item => {
                if (typeof item.key === 'object' && item.key !== null) {
                    keyIsMap = true;
                    Object.keys(item.key).forEach(k => keyFields.add(k));
                }
                if (typeof item.value === 'object' && item.value !== null) {
                    valueIsMap = true;
                    Object.keys(item.value).forEach(k => valueFields.add(k));
                }
            });

            // Use Set insertion order (which matches server order), do NOT sort.
            let kFieldsArr = Array.from(keyFields);
            let vFieldsArr = Array.from(valueFields);

            if (keyIsMap) {
                kFieldsArr.forEach(k => headers.push(k.charAt(0).toUpperCase() + k.slice(1)));
            } else if (!allKeysNull) {
                headers.push("Key");
            }

            if (valueIsMap) {
                vFieldsArr.forEach(v => headers.push(v.charAt(0).toUpperCase() + v.slice(1)));
            } else if (!allValuesNull) {
                headers.push("Value");
            }

            csv = headers.join(", ") + "\n";

            items.forEach(item => {
                let row = [];
                if (keyIsMap) {
                    kFieldsArr.forEach(k => {
                        let val = "";
                        if (item.key && typeof item.key === 'object') {
                            val = item.key[k] !== undefined ? item.key[k] : "";
                        }
                        row.push(val);
                    });
                } else if (!allKeysNull) {
                    row.push(item.key !== null && item.key !== undefined ? item.key : "");
                }

                if (valueIsMap) {
                    vFieldsArr.forEach(v => {
                        let val = "";
                        if (item.value && typeof item.value === 'object') {
                            val = item.value[v] !== undefined ? item.value[v] : "";
                        }
                        row.push(val);
                    });
                } else if (!allValuesNull) {
                    row.push(item.value !== null && item.value !== undefined ? item.value : "");
                }
                csv += row.join(", ") + "\n";
            });

            return csv;
        } catch (e) {
            console.error("Failed to convert JSON to CSV", e);
            return typeof input === 'string' ? input : JSON.stringify(input);
        }
    }

    function processMacroTrace(trace, format) {
        let output = "";
        console.log("Processing Macro Trace. Steps:", trace.length);
        
        trace.forEach((step, index) => {
            console.log(`Step ${index} type: ${step.type}`);
            if (step.type === 'command') {
                // Optionally show the command being executed
                // output += `> ${step.command}\n`;
                
                if (step.result) {
                    let resultDisplay = step.result;
                    
                    // Handle object/array results (from new streaming logic)
                    let parsedResult = step.result;
                    let isObject = typeof step.result === 'object' && step.result !== null;

                    if (!isObject && typeof step.result === 'string') {
                        try {
                            // Try to parse if it's a string
                            if (step.result.trim().startsWith('[') || step.result.trim().startsWith('{')) {
                                parsedResult = JSON.parse(step.result);
                                isObject = true;
                            }
                        } catch (e) {
                            // Not JSON
                        }
                    }

                    if (format === 'csv') {
                        try {
                            if (isObject && Array.isArray(parsedResult)) {
                                const csv = jsonToCSV(parsedResult);
                                if (csv.includes(',')) {
                                    resultDisplay = csv;
                                }
                            }
                        } catch (e) {
                            console.error(`Step ${index} CSV conversion error:`, e);
                        }
                    } else {
                        // JSON format
                        if (isObject) {
                            resultDisplay = JSON.stringify(parsedResult, null, 2);
                        }
                    }
                    
                    // Ensure we don't print [object Object]
                    if (typeof resultDisplay === 'object') {
                        resultDisplay = JSON.stringify(resultDisplay, null, 2);
                    }

                    output += resultDisplay + "\n";
                }
            } else if (step.type === 'say') {
                output += step.result + "\n";
            } else if (step.type === 'error') {
                output += `Error: ${step.error}\n`;
            } else if (step.type === 'ask') {
                output += `${step.prompt}\n`;
            }
        });
        
        return output.trim();
    }

    async function sendChatMessage() {
        const input = document.getElementById('chat-input');
        const sendBtn = document.getElementById('chat-send-btn');
        
        // Check if we are in "Stop" mode
        if (chatAbortController) {
            chatAbortController.abort();
            chatAbortController = null;
            if (sendBtn) sendBtn.textContent = 'Send';
            appendChatMessage('ai', 'Request cancelled by user.');
            return;
        }

        const message = input.value.trim();
        const agentSelect = document.getElementById('agent-select');
        const agent = agentSelect ? agentSelect.value : 'db_admin';
        const providerSelect = document.getElementById('provider-select');
        const provider = providerSelect ? providerSelect.value : '';
        const formatSelect = document.getElementById('format-select');
        const format = formatSelect ? formatSelect.value : 'csv';

        if (!message) return;

        // Save to history
        chatHistory.push(message);
        historyIndex = -1; // Reset index

        // Add User Message
        appendChatMessage('user', message);
        input.value = '';
        
        // Show Loading
        const loadingId = appendChatMessage('ai', 'Thinking...');
        // Setup AbortController
        chatAbortController = new AbortController();
        if (sendBtn) sendBtn.textContent = 'Stop';

        try {
            const response = await fetch('/api/ai/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    message: message,
                    database: currentDatabase,
                    store: currentStore,
                    agent: agent,
                    provider: provider,
                    format: format
                }),
                signal: chatAbortController.signal
            });

            // Remove Loading
            const loadingEl = document.getElementById(loadingId);
            if (loadingEl) loadingEl.remove();

            if (!response.ok) {
                const text = await response.text();
                appendChatMessage('ai', 'HTTP Error: ' + response.status + ' - ' + text);
                return;
            }

            // Read the stream
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            
            // State for rendering
            let currentContentSpan = null;
            let currentTableContainer = null;
            let currentTableRecords = [];
            let currentTableType = null; // 'record' or 'kv'

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                const chunk = decoder.decode(value, { stream: true });
                // Split by newline to handle multiple objects in one chunk
                const lines = chunk.split('\n');
                
                for (const line of lines) {
                    if (!line.trim()) continue;
                    try {
                        const event = JSON.parse(line);
                        
                        // Helper to flush pending records before showing text or other content
                        const flushRecords = () => {
                            if (currentTableRecords.length > 0) {
                                renderDataResults(currentTableRecords, format, currentTableType);
                                currentTableRecords = []; // Clear
                                // Also ensure we create a NEW content span for subsequent text
                                currentContentSpan = null; 
                                
                                // Scroll down
                                const hist = document.getElementById('chat-history');
                                if (hist) hist.scrollTop = hist.scrollHeight;
                            }
                        };

                        if (event.type === 'content') {
                             flushRecords(); // Flush any data tables before showing new text analysis/headers

                             if (!currentContentSpan) {
                                // Start new content block
                                const msgDiv = document.createElement('div');
                                msgDiv.className = 'chat-message ai';
                                currentContentSpan = document.createElement('span');
                                msgDiv.appendChild(currentContentSpan);
                                document.getElementById('chat-history').appendChild(msgDiv);
                                pruneChatHistory();
                                document.getElementById('chat-history').scrollTop = document.getElementById('chat-history').scrollHeight;
                            }
                            
                            // For now basic accumulation, markdown later?
                            // If event.payload is the whole response (as per our backend right now), just set it.
                            // If we switch to token streaming, we append.
                            // Backend emits entire string for now.
                            // Handle Markdown
                            const markdownHtml = marked.parse(String(event.payload));
                            currentContentSpan.innerHTML += markdownHtml;
                            document.getElementById('chat-history').scrollTop = document.getElementById('chat-history').scrollHeight;
                        } 
                        else if (event.type === 'record' || event.type === 'kv') {
                            // Collect records
                            // If we encounter a schema change, we might want to flush?
                            // For simplicity, we just collect until text/content interrupts.
                            currentTableRecords.push(event.payload);
                            currentTableType = event.type;
                        }
                        else if (event.type === 'tool_call') {
                            flushRecords();
                            appendChatMessage('ai', '🛠️ Calling Tool: ' + event.payload.tool);
                            currentContentSpan = null;
                        }
                        else if (event.type === 'error') {
                            flushRecords();
                            appendChatMessage('ai', 'Error: ' + event.payload);
                            currentContentSpan = null;
                        }
                    } catch (e) {
                        console.error("Failed to parse stream line:", line, e);
                    }
                }
            }
            
            // After stream, if we have records, render them
            if (currentTableRecords.length > 0) {
                renderDataResults(currentTableRecords, format, currentTableType);
            }

        } catch (err) {
             const loadingEl = document.getElementById(loadingId);
             if (loadingEl) loadingEl.remove();

             if (err.name === 'AbortError') {
                 // Ignore
             } else {
                 appendChatMessage('ai', 'Error: ' + err.message);
             }
        } finally {
             chatAbortController = null;
             if (sendBtn) sendBtn.textContent = 'Send';
        }
    }

    function renderDataResults(records, format, type) {
        // Auto-flatten records if they contain SOP internal fields (key, value, etc)
        // This makes the output much cleaner for Joins and raw Store scans.
        if (type === 'record') {
            records = records.map(r => {
                const flat = Object.assign({}, r);
                ['key', 'value', 'right_key', 'right_value'].forEach(field => {
                     if (flat[field] !== undefined) {
                         let val = flat[field];
                         // Try parse string JSON if possible
                         if (typeof val === 'string' && val.trim().startsWith('{')) {
                            try { val = JSON.parse(val); } catch(e){}
                         }
                         
                         // If it's an object, merge it up
                         if (val && typeof val === 'object' && !Array.isArray(val)) {
                             Object.assign(flat, val);
                             delete flat[field];
                         }
                     }
                });
                return flat;
            });
        }

        if (format === 'table') {
            renderRecordTable(records, type);
        } else if (format === 'json') {
            const block = document.createElement('div');
            block.className = 'chat-message ai';
            const uuid = generateUUID();
            block.id = 'msg-' + uuid;
            block.innerHTML = '<pre>' + JSON.stringify(records, null, 2) + '</pre>';
            document.getElementById('chat-history').appendChild(block);
            document.getElementById('chat-history').scrollTop = document.getElementById('chat-history').scrollHeight;
        } else if (format === 'csv') {
            const block = document.createElement('div');
            block.className = 'chat-message ai';
            const uuid = generateUUID();
            block.id = 'msg-' + uuid;
            
            // Convert Records to CSV
            const headerSet = new Set();
            records.forEach(r => Object.keys(r).forEach(k => headerSet.add(k)));
            const headers = Array.from(headerSet);
            
            let csvHeader = headers.join(',');
            let csvBody = '';

            records.forEach(r => {
                const row = headers.map(h => {
                        let val = r[h];
                        if (val === undefined || val === null) return '';
                        if (typeof val === 'object') val = JSON.stringify(val);
                        val = String(val);
                        if (val.includes(',') || val.includes('"') || val.includes('\n')) {
                            val = '"' + val.replace(/"/g, '""') + '"';
                        }
                        return val;
                }).join(',');
                csvBody += row + '\n';
            });

            block.innerHTML = '<pre class="csv-output"><span class="csv-header">' + csvHeader + '</span>\n' + csvBody + '</pre>';
            document.getElementById('chat-history').appendChild(block);
            document.getElementById('chat-history').scrollTop = document.getElementById('chat-history').scrollHeight;
        } else {
                // Default Fallback (Table)
                renderRecordTable(records, type);
        }
    }

    function renderRecordTable(records, type) {
        const container = document.createElement('div');
        container.className = 'chat-message ai-table-container';
        
        const table = document.createElement('table');
        table.className = 'data-table';
        const thead = document.createElement('thead');
        const tbody = document.createElement('tbody');
        
        let headers = [];
        if (type === 'kv') {
             headers = ['Key', 'Value'];
        } else {
             // Discover headers
             const headerSet = new Set();
             records.forEach(r => Object.keys(r).forEach(k => headerSet.add(k)));
             headers = Array.from(headerSet);
        }
        
        // Header Row
        const trHead = document.createElement('tr');
        headers.forEach(h => {
            const th = document.createElement('th');
            // Replace underscores with spaces so CSS capitalize can work on words
            th.textContent = h.replace(/_/g, ' ');
            trHead.appendChild(th);
        });
        thead.appendChild(trHead);
        
        // Body
        records.forEach(r => {
            const tr = document.createElement('tr');
            if (type === 'kv') {
                 // KV Specific rendering
                 const tdK = document.createElement('td');
                 // TODO: Pretty print objects
                 tdK.textContent = typeof r.key === 'object' ? JSON.stringify(r.key) : r.key;
                 
                 const tdV = document.createElement('td');
                 tdV.textContent = typeof r.value === 'object' ? JSON.stringify(r.value) : r.value;
                 
                 tr.appendChild(tdK);
                 tr.appendChild(tdV);
            } else {
                 headers.forEach(h => {
                     const td = document.createElement('td');
                     const val = r[h];
                     td.textContent = (typeof val === 'object' && val !== null) ? JSON.stringify(val) : (val === undefined ? '' : val);
                     tr.appendChild(td);
                 });
            }
            tbody.appendChild(tr);
        });
        
        table.appendChild(thead);
        table.appendChild(tbody);
        container.appendChild(table);
        
        document.getElementById('chat-history').appendChild(container);
        document.getElementById('chat-history').scrollTop = document.getElementById('chat-history').scrollHeight;
    }


    function handleChatKeydown(e) {
        const input = document.getElementById('chat-input');
        
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendChatMessage();
        } else if (e.key === 'ArrowUp') {
            // Only navigate history if cursor is at start or single line
            if (chatHistory.length > 0) {
                e.preventDefault();
                if (historyIndex === -1) {
                    historyIndex = chatHistory.length - 1;
                } else if (historyIndex > 0) {
                    historyIndex--;
                }
                input.value = chatHistory[historyIndex];
            }
        } else if (e.key === 'ArrowDown') {
            if (historyIndex !== -1) {
                e.preventDefault();
                if (historyIndex < chatHistory.length - 1) {
                    historyIndex++;
                    input.value = chatHistory[historyIndex];
                } else {
                    historyIndex = -1;
                    input.value = '';
                }
            }
        }
    }

    // --- Macro Tree View Logic ---

    // History Stack for Script Navigation
    let scriptViewStack = [];
    let currentScriptView = { name: '', steps: [] };

    function openScriptModal() {
        const modal = document.getElementById('script-modal');
        const container = document.getElementById('script-tree-container');
        
        let steps = [];
        let name = "Current Item";
        
        // Initial Load from selected item
        if (currentItemValue && Array.isArray(currentItemValue.steps)) {
            steps = currentItemValue.steps;
        }
        if (currentItemKey) {
            name = currentItemKey;
        }
        
        // Reset Stack
        scriptViewStack = [];
        currentScriptView = { name: name, steps: steps };
        
        renderScriptTree();
        modal.style.display = 'block';
    }

    function renderScriptTree() {
        const container = document.getElementById('script-tree-container');
        container.innerHTML = '';
        
        // Render Header with Back Button if needed
        const header = document.createElement('div');
        header.style.marginBottom = '10px';
        header.style.borderBottom = '1px solid var(--border-color)';
        header.style.paddingBottom = '10px';
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        header.style.gap = '10px';
        
        if (scriptViewStack.length > 0) {
            const backBtn = document.createElement('button');
            backBtn.innerHTML = '&#8592; Back';
            backBtn.onclick = goBackScript;
            backBtn.style.padding = '2px 8px';
            backBtn.style.cursor = 'pointer';
            header.appendChild(backBtn);
        }
        
        const title = document.createElement('h4');
        title.style.margin = '0';
        title.textContent = "Script: " + currentScriptView.name;
        header.appendChild(title);
        
        container.appendChild(header);

        if (!currentScriptView.steps || currentScriptView.steps.length === 0) {
            const msg = document.createElement('div');
            msg.innerHTML = '<em>No steps defined.</em>';
            container.appendChild(msg);
        } else {
            const ul = document.createElement('ul');
            renderMacroSteps(currentScriptView.steps, ul);
            container.appendChild(ul);
        }
    }

    function drillDownToScript(scriptName) {
        // Parse Category if present (e.g. "finance.compute_monthly")
        let searchName = scriptName;
        let searchCategory = null;
        if (scriptName.indexOf('.') > 0) {
            const parts = scriptName.split('.');
            // Assume format: category.name
            searchCategory = parts[0];
            searchName = parts[1];
        } else {
             // If no category is present, can we assume any? 
             // Ideally we search globally?
        }

        // Check for unsaved changes before starting navigation
        const btn = document.getElementById('btn-save');
        if (btn && !btn.disabled) {
             if (!confirm("You have unsaved changes. Navigating to script will discard them. Continue?")) {
                 return;
             }
        }

        const targetStore = "scripts";
        
        // Helper to find the script in a specific database
        const tryFetch = (dbName) => {
            // Using query on Name only for flexibility
            return fetch(`/api/store/items?database=${encodeURIComponent(dbName)}&name=${targetStore}&q=${encodeURIComponent(searchName)}`)
                .then(res => {
                    if (!res.ok) throw new Error(res.statusText);
                    return res.json();
                });
        };

        // UI Feedback
        const originalCursor = document.body.style.cursor;
        document.body.style.cursor = 'wait';

        tryFetch(currentDatabase)
            .then(items => {
                // Return { db: currentDatabase, items: items } if found
                if (items && items.length > 0) return { db: currentDatabase, items: items };
                
                // If not found, look for a System DB to fallback to
                const systemDB = availableDatabases.find(d => d.is_system);
                if (systemDB && systemDB.name !== currentDatabase) {
                    console.log(`Script '${scriptName}' not found in '${currentDatabase}', trying System DB '${systemDB.name}'...`);
                    return tryFetch(systemDB.name).then(sysItems => {
                        return { db: systemDB.name, items: sysItems };
                    });
                }
                return { db: currentDatabase, items: [] };
            })
            .then(result => {
                const items = result.items;
                const foundDB = result.db;
                
                if (items && items.length > 0) {
                    // Match Logic (Object Key vs String Key vs Namespace)
                    const item = items.find(i => {
                        if (i.key && typeof i.key === 'object') {
                             const keyName = i.key.name || i.key.Name;
                             const keyCat = i.key.category || i.key.Category;
                             
                             if (keyName !== searchName) return false;
                             if (searchCategory && keyCat !== searchCategory) return false;
                             return true;
                        }
                        if (i.key === searchName) {
                            if (searchCategory) return false;
                            return true;
                        }
                        return false;
                    }) || items[0];

                    // Verify correctness of match
                    let isMatch = false;
                    if (item.key && typeof item.key === 'object') {
                         const keyName = item.key.name || item.key.Name;
                         if (keyName === searchName) isMatch = true;
                    } else if (item.key === searchName) {
                        isMatch = true;
                    }
                    
                    if (isMatch) {
                        // FOUND! Now navigate the main UI.

                        // 1. Switch Database Context if needed
                        if (foundDB !== currentDatabase) {
                            currentDatabase = foundDB;
                            const dbSelect = document.getElementById('db-select');
                            if (dbSelect) dbSelect.value = currentDatabase;
                        }

                        // 2. Switch Store Context
                        currentStore = targetStore;
                        const storeSelect = document.getElementById('store-select');
                        if (storeSelect) {
                            storeSelect.value = currentStore;
                            // Optionally trigger onchange to update store info, but we are manually driving here
                        }

                        // 3. Load Items (to populate the grid for context) AND Show Detail
                        // We use loadItems() but we know it might be async.
                        // However, we already HAVE the item we want to show.
                        // We can show it immediately.
                        
                        document.body.style.cursor = originalCursor;
                        
                        // Push View State to History
                        pushView(); 

                        // Trigger loadItems to update the background grid
                        // We pass keepPanel=true so it doesn't close our detail view if we open it effectively immediately
                        loadItems('first', null, true); // This runs in background

                        // Open the Detail Pane with the Found Item
                        showDetail(null, item, true); 

                    } else {
                        document.body.style.cursor = originalCursor;
                        alert("Script found but key mismatch? Found: " + JSON.stringify(item.key));
                    }
                } else {
                    document.body.style.cursor = originalCursor;
                    alert("Script not found: " + scriptName);
                }
            })
            .catch(err => {
                document.body.style.cursor = originalCursor;
                alert("Error fetching script: " + err.message);
            });
    }

    function goBackScript() {
        if (scriptViewStack.length > 0) {
            currentScriptView = scriptViewStack.pop();
            renderScriptTree();
        }
    }

    function closeScriptModal() {
        document.getElementById('script-modal').style.display = 'none';
    }

    function renderMacroSteps(steps, container) {
        steps.forEach((step, index) => {
            const li = document.createElement('li');
            li.className = 'step-item';
            
            // Determine Type Class
            const typeClass = 'type-' + (step.type || 'unknown');
            
            // Determine Summary
            let summary = '';
            let isScriptCall = false;

            if (step.type === 'ask') summary = `Ask: "${step.prompt}" -> ${step.output_variable || '(no var)'}`;
            else if (step.type === 'set') summary = `Set: ${step.variable} = ${step.value}`;
            else if (step.type === 'if') summary = `If: ${step.condition}`;
            else if (step.type === 'loop') summary = `Loop: ${step.list} as ${step.iterator}`;
            else if (step.type === 'fetch') summary = `Fetch: ${step.resource} -> ${step.variable}`;
            else if (step.type === 'say') summary = `Say: "${step.message}"`;
            else if (step.type === 'command') summary = `Cmd: ${step.command} ${JSON.stringify(step.args || {})}`;
            else if (step.type === 'script' || step.type === 'call_script') {
                 summary = `Run Script: ${step.script_name}`;
                 isScriptCall = true;
            }
            else summary = JSON.stringify(step);

            // Check for children (nested steps)
            const hasChildren = step.steps && step.steps.length > 0;
            const toggleHtml = hasChildren ? '<div class="step-toggle">&#9654;</div>' : '<div class="step-toggle"></div>';

            const card = document.createElement('div');
            card.className = 'step-card';
            
            // Header
            const header = document.createElement('div');
            header.className = 'step-header';
            
            let actionHtml = '';
            if (isScriptCall && step.script_name) {
                actionHtml = `<button class="step-action-btn" title="View Script" onclick="event.stopPropagation(); drillDownToScript('${step.script_name}')" style="margin-left:auto; background:none; border:none; cursor:pointer; font-size:16px;">🔍</button>`;
            } else {
                // Ensure layout consistency
                actionHtml = '<span style="margin-left:auto;"></span>';
            }

            header.innerHTML = `
                ${toggleHtml}
                <span class="step-type ${typeClass}">${step.type || '?'}</span>
                <span class="step-summary">${summary.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>
                ${actionHtml}
            `;
            
            // Details (JSON view)
            const details = document.createElement('div');
            details.className = 'step-details';
            details.innerHTML = `<pre>${JSON.stringify(step, (k, v) => k === 'steps' ? undefined : v, 2)}</pre>`; // Exclude nested steps from detail view to avoid duplication

            // Event Listeners
            header.onclick = (e) => {
                // If clicking toggle area, toggle children
                // If clicking elsewhere, toggle details? Or just toggle children if present?
                // Let's make the whole header toggle children if present, else toggle details.
                if (hasChildren) {
                    toggleStepChildren(li);
                } else {
                    details.classList.toggle('open');
                }
            };

            card.appendChild(header);
            card.appendChild(details);
            
            // Children Container
            if (hasChildren) {
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'step-children';
                const childUl = document.createElement('ul');
                renderMacroSteps(step.steps, childUl);
                childrenContainer.appendChild(childUl);
                card.appendChild(childrenContainer);
            }

            li.appendChild(card);
            container.appendChild(li);
        });
    }

    function toggleStepChildren(li) {
        const toggle = li.querySelector('.step-toggle');
        const children = li.querySelector('.step-children');
        if (toggle && children) {
            toggle.classList.toggle('rotated');
            children.classList.toggle('open');
        }
    }

    // --- End Macro Tree View Logic ---

    function generateUUID() {
        if (typeof crypto !== 'undefined' && crypto.randomUUID) {
            return crypto.randomUUID();
        }
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    const MAX_CHAT_MESSAGES = 100; // Limit chat history to prevent DOM bloat

    function pruneChatHistory() {
        const history = document.getElementById('chat-history');
        if (history) {
            while (history.children.length > MAX_CHAT_MESSAGES) {
                history.removeChild(history.firstChild);
            }
        }
    }

    function appendChatMessage(role, text) {
        pruneChatHistory();
        console.log("Appending message:", role, text); // Debug Log
        const history = document.getElementById('chat-history');
        const div = document.createElement('div');
        div.className = `chat-message ${role}`;
        div.id = 'msg-' + generateUUID();
        
        // Simple markdown-like parsing for code blocks
        if (text.includes('```')) {
            text = text.replace(/```([\s\S]*?)```/g, '<pre>$1</pre>');
        }
        
        div.innerHTML = text.replace(/\n/g, '<br>');
        history.appendChild(div);
        
        console.log("Message appended to history. History child count:", history.children.length); // Debug Log

        // Auto-scroll to bottom
        requestAnimationFrame(() => {
            history.scrollTop = history.scrollHeight;
        });
        
        return div.id;
    }

    // Hook into showDetail to ensure we see the details tab
    const originalShowDetail = showDetail;
    showDetail = function(row, item, autoOpen) {
        originalShowDetail(row, item, autoOpen);
        
        // Only switch to details tab if we are explicitly opening/selecting (e.g. click)
        // If autoOpen is false (navigation), preserve the current tab (e.g. if user is in Chat)
        if (autoOpen === undefined || autoOpen === true) {
            switchTab('details');
        }
    };

    function toggleProviderSelect() {
        // No-op since we removed the agent select dropdown logic
    }

    // --- Code Generation Logic ---
    function showGeneratedCode() {
        if (!currentStore) return;
        updateGeneratedCodeView();
        document.getElementById('code-modal').style.display = 'flex';
    }

    function updateGeneratedCodeView() {
        const lang = document.getElementById('code-lang-select').value;
        const mode = document.querySelector('input[name="code-view-mode"]:checked').value;
        
        let keySample = null;
        let valSample = null;

        // 1. Try to get sample from Store Info
        if (currentStoreInfo) {
            if (currentStoreInfo.sampleKey) keySample = currentStoreInfo.sampleKey;
            if (currentStoreInfo.sampleValue) valSample = currentStoreInfo.sampleValue;
        }

        // 2. Fallback to first item in grid
        if (currentItems && currentItems.length > 0) {
            if (!keySample) keySample = currentItems[0].key;
            if (!valSample) valSample = currentItems[0].value;
        }

        // 3. Try to parse if string
        if (typeof keySample === 'string') {
            try { keySample = JSON.parse(keySample); } catch(e) {}
        }
        if (typeof valSample === 'string') {
            try { valSample = JSON.parse(valSample); } catch(e) {}
        }

        const storeNamePascal = toPascalCase(currentStore);
        let code = "";

        if (lang === 'go') {
            code = generateGoCode(storeNamePascal, keySample, valSample, mode);
        } else if (lang === 'python') {
            code = generatePythonCode(storeNamePascal, keySample, valSample, mode);
        } else if (lang === 'csharp') {
            code = generateCSharpCode(storeNamePascal, keySample, valSample, mode);
        } else if (lang === 'java') {
            code = generateJavaCode(storeNamePascal, keySample, valSample, mode);
        } else if (lang === 'rust') {
            code = generateRustCode(storeNamePascal, keySample, valSample, mode);
        }

        document.getElementById('generated-code-content').textContent = code;
    }

    // --- Go Generator ---
    function generateGoCode(name, keySample, valSample, mode) {
        let code = `// Generated Go code for store "${currentStore}"\n`;
        code += `package main\n\n`;
        
        // Check for time and uuid imports
        let needsTime = false;
        let needsUUID = false;
        const checkImports = (obj) => {
            if (typeof obj === 'object' && obj !== null) {
                Object.values(obj).forEach(v => {
                    if (typeof v === 'string') {
                        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(v) || /^\d{4}-\d{2}-\d{2}$/.test(v)) needsTime = true;
                        if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(v)) needsUUID = true;
                    }
                });
            }
        };
        checkImports(keySample);
        checkImports(valSample);
        
        if (needsTime || needsUUID) {
            code += `import (\n`;
            if (needsTime) code += `    "time"\n`;
            if (needsUUID) code += `    "github.com/google/uuid"\n`;
            code += `)\n\n`;
        }

        if (mode === 'struct') {
            // Key Struct
            if (typeof keySample === 'object' && keySample !== null) {
                code += jsonToGoStruct(`${name}Key`, keySample);
            } else {
                code += `type ${name}Key ${getGoType(keySample)}\n`;
            }
            code += "\n";
            // Value Struct
            if (typeof valSample === 'object' && valSample !== null) {
                code += jsonToGoStruct(`${name}Value`, valSample);
            } else {
                code += `type ${name}Value ${getGoType(valSample)}\n`;
            }
        } else {
            // Map
            code += `// Map representation\n`;
            code += `var ${name}Map = map[string]interface{}{\n`;
            if (keySample) code += `    "sampleKey": ${JSON.stringify(keySample)},\n`;
            if (valSample) code += `    "sampleValue": ${JSON.stringify(valSample)},\n`;
            code += `}\n`;
        }
        return code;
    }

    function getGoType(val) {
        if (val === null) return "interface{}";
        const type = typeof val;
        if (type === 'string') {
            if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(val)) return "uuid.UUID";
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(val)) return "time.Time";
            if (/^\d{4}-\d{2}-\d{2}$/.test(val)) return "time.Time";
            return "string";
        }
        if (type === 'number') return Number.isInteger(val) ? "int" : "float64";
        if (type === 'boolean') return "bool";
        if (Array.isArray(val)) {
            // Check if it looks like a byte array (all numbers 0-255)
            if (val.length > 0 && val.every(v => typeof v === 'number' && v >= 0 && v <= 255 && Number.isInteger(v))) {
                return "[]byte";
            }
            return "[]interface{}";
        }
        return "interface{}";
    }

    function jsonToGoStruct(structName, obj) {
        let code = `type ${structName} struct {\n`;
        const keys = Object.keys(obj);
        keys.forEach(key => {
            const val = obj[key];
            const fieldName = toPascalCase(key);
            let type = "interface{}";
            if (val !== null) {
                if (Array.isArray(val)) {
                    type = (val.length > 0) ? `[]${getGoType(val[0])}` : "[]interface{}";
                } else if (typeof val === 'object') {
                    type = "map[string]interface{}"; 
                } else {
                    type = getGoType(val);
                }
            }
            code += `    ${fieldName} ${type} \`json:"${key}"\`\n`;
        });
        code += `}`;
        return code;
    }

    // --- Python Generator ---
    function generatePythonCode(name, keySample, valSample, mode) {
        let code = `# Generated Python code for store "${currentStore}"\n`;
        
        let imports = [];
        if (mode === 'struct') {
            imports.push("dataclasses.dataclass");
            imports.push("typing.Any", "typing.List", "typing.Dict", "typing.Optional");
        }
        
        // Check for datetime/uuid imports
        let needsDateTime = false;
        let needsUUID = false;
        
        const checkTypes = (obj) => {
            if (typeof obj === 'object' && obj !== null) {
                Object.values(obj).forEach(v => {
                    if (typeof v === 'string') {
                        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(v) || /^\d{4}-\d{2}-\d{2}$/.test(v)) needsDateTime = true;
                        if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(v)) needsUUID = true;
                    }
                });
            }
        };
        checkTypes(keySample);
        checkTypes(valSample);
        
        if (needsDateTime) imports.push("datetime.datetime");
        if (needsUUID) imports.push("uuid.UUID");
        
        if (imports.length > 0) {
            // Group imports
            const fromImports = {};
            imports.forEach(imp => {
                const parts = imp.split('.');
                if (parts.length > 1) {
                    const mod = parts[0];
                    const cls = parts[1];
                    if (!fromImports[mod]) fromImports[mod] = [];
                    fromImports[mod].push(cls);
                }
            });
            
            Object.keys(fromImports).forEach(mod => {
                code += `from ${mod} import ${fromImports[mod].join(', ')}\n`;
            });
            code += "\n";
        }
        
        if (mode === 'struct') {
            // Key Class
            if (typeof keySample === 'object' && keySample !== null) {
                code += jsonToPythonClass(`${name}Key`, keySample);
            } else {
                code += `# Key is a primitive: ${typeof keySample}\n`;
            }
            code += "\n";
            // Value Class
            if (typeof valSample === 'object' && valSample !== null) {
                code += jsonToPythonClass(`${name}Value`, valSample);
            } else {
                code += `# Value is a primitive: ${typeof valSample}\n`;
            }
        } else {
            code += `# Dictionary representation\n`;
            code += `${name.toLowerCase()}_data = {\n`;
            if (keySample) code += `    "sample_key": ${JSON.stringify(keySample, null, 4)},\n`;
            if (valSample) code += `    "sample_value": ${JSON.stringify(valSample, null, 4)}\n`;
            code += `}\n`;
        }
        return code;
    }

    function getPythonType(val) {
        if (val === null) return "Optional[Any]";
        const type = typeof val;
        if (type === 'string') {
            if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(val)) return "UUID";
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(val)) return "datetime";
            if (/^\d{4}-\d{2}-\d{2}$/.test(val)) return "datetime";
            return "str";
        }
        if (type === 'number') return Number.isInteger(val) ? "int" : "float";
        if (type === 'boolean') return "bool";
        if (Array.isArray(val)) {
            if (val.length > 0 && val.every(v => typeof v === 'number' && v >= 0 && v <= 255 && Number.isInteger(v))) {
                return "bytes";
            }
            return "List[Any]";
        }
        return "Any";
    }

    function jsonToPythonClass(className, obj) {
        let code = `@dataclass\nclass ${className}:\n`;
        const keys = Object.keys(obj);
        if (keys.length === 0) code += "    pass\n";
        
        keys.forEach(key => {
            const val = obj[key];
            let type = "Any";
            if (val !== null) {
                if (Array.isArray(val)) {
                    type = (val.length > 0) ? `List[${getPythonType(val[0])}]` : "List[Any]";
                } else if (typeof val === 'object') {
                    type = "Dict[str, Any]";
                } else {
                    type = getPythonType(val);
                }
            }
            code += `    ${key}: ${type}\n`;
        });
        return code;
    }

    // --- C# Generator ---
    function generateCSharpCode(name, keySample, valSample, mode) {
        let code = `// Generated C# code for store "${currentStore}"\n`;
        code += `using System;\nusing System.Collections.Generic;\n\n`;
        code += `namespace Sop.Generated {\n`;

        if (mode === 'struct') {
            // Key Class
            if (typeof keySample === 'object' && keySample !== null) {
                code += jsonToCSharpClass(`${name}Key`, keySample);
            } else {
                code += `    // Key is a primitive: ${getCSharpType(keySample)}\n`;
            }
            code += "\n";
            // Value Class
            if (typeof valSample === 'object' && valSample !== null) {
                code += jsonToCSharpClass(`${name}Value`, valSample);
            } else {
                code += `    // Value is a primitive: ${getCSharpType(valSample)}\n`;
            }
        } else {
            code += `    public class ${name}Data {\n`;
            code += `        public static Dictionary<string, object> Sample = new Dictionary<string, object> {\n`;
            if (keySample) code += `            { "SampleKey", ${JSON.stringify(keySample)} },\n`;
            if (valSample) code += `            { "SampleValue", ${JSON.stringify(valSample)} }\n`;
            code += `        };\n    }\n`;
        }
        code += `}\n`;
        return code;
    }

    function getCSharpType(val) {
        if (val === null) return "object";
        const type = typeof val;
        if (type === 'string') {
            if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(val)) return "Guid";
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(val)) return "DateTime";
            if (/^\d{4}-\d{2}-\d{2}$/.test(val)) return "DateTime";
            return "string";
        }
        if (type === 'number') return Number.isInteger(val) ? "int" : "double";
        if (type === 'boolean') return "bool";
        if (Array.isArray(val)) {
            if (val.length > 0 && val.every(v => typeof v === 'number' && v >= 0 && v <= 255 && Number.isInteger(v))) {
                return "byte[]";
            }
            return "List<object>";
        }
        return "object";
    }

    function jsonToCSharpClass(className, obj) {
        let code = `    public class ${className} {\n`;
        const keys = Object.keys(obj);
        keys.forEach(key => {
            const val = obj[key];
            const fieldName = toPascalCase(key);
            let type = "object";
            if (val !== null) {
                if (Array.isArray(val)) {
                    type = (val.length > 0) ? `List<${getCSharpType(val[0])}>` : "List<object>";
                } else if (typeof val === 'object') {
                    type = "Dictionary<string, object>";
                } else {
                    type = getCSharpType(val);
                }
            }
            code += `        public ${type} ${fieldName} { get; set; }\n`;
        });
        code += `    }\n`;
        return code;
    }

    // --- Java Generator ---
    function generateJavaCode(name, keySample, valSample, mode) {
        let code = `// Generated Java code for store "${currentStore}"\n`;
        code += `import java.util.*;\n\n`;

        if (mode === 'struct') {
            // Key Class
            if (typeof keySample === 'object' && keySample !== null) {
                code += jsonToJavaClass(`${name}Key`, keySample);
            } else {
                code += `// Key is a primitive: ${getJavaType(keySample)}\n`;
            }
            code += "\n";
            // Value Class
            if (typeof valSample === 'object' && valSample !== null) {
                code += jsonToJavaClass(`${name}Value`, valSample);
            } else {
                code += `// Value is a primitive: ${getJavaType(valSample)}\n`;
            }
        } else {
            code += `public class ${name}Data {\n`;
            code += `    public static Map<String, Object> getSample() {\n`;
            code += `        Map<String, Object> map = new HashMap<>();\n`;
            // Simplified map generation
            code += `        // ... populate map with sample data ...\n`;
            code += `        return map;\n`;
            code += `    }\n}\n`;
        }
        return code;
    }

    function getJavaType(val) {
        if (val === null) return "Object";
        const type = typeof val;
        if (type === 'string') {
            if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(val)) return "UUID";
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(val)) return "Date";
            if (/^\d{4}-\d{2}-\d{2}$/.test(val)) return "Date";
            return "String";
        }
        if (type === 'number') return Number.isInteger(val) ? "Integer" : "Double";
        if (type === 'boolean') return "Boolean";
        if (Array.isArray(val)) {
            if (val.length > 0 && val.every(v => typeof v === 'number' && v >= 0 && v <= 255 && Number.isInteger(v))) {
                return "byte[]";
            }
            return "List<Object>";
        }
        return "Object";
    }

    function jsonToJavaClass(className, obj) {
        let code = `public class ${className} {\n`;
        const keys = Object.keys(obj);
        keys.forEach(key => {
            const val = obj[key];
            // Java convention: camelCase fields
            const fieldName = key; 
            let type = "Object";
            if (val !== null) {
                if (Array.isArray(val)) {
                    type = (val.length > 0) ? `List<${getJavaType(val[0])}>` : "List<Object>";
                } else if (typeof val === 'object') {
                    type = "Map<String, Object>";
                } else {
                    type = getJavaType(val);
                }
            }
            code += `    public ${type} ${fieldName};\n`;
        });
        code += `}\n`;
        return code;
    }

    // --- Rust Generator ---
    function generateRustCode(name, keySample, valSample, mode) {
        let code = `// Generated Rust code for store "${currentStore}"\n`;
        code += `use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n`;

        if (mode === 'struct') {
            // Key Struct
            if (typeof keySample === 'object' && keySample !== null) {
                code += jsonToRustStruct(`${name}Key`, keySample);
            } else {
                code += `// Key is a primitive: ${getRustType(keySample)}\n`;
                code += `type ${name}Key = ${getRustType(keySample)};\n`;
            }
            code += "\n";
            // Value Struct
            if (typeof valSample === 'object' && valSample !== null) {
                code += jsonToRustStruct(`${name}Value`, valSample);
            } else {
                code += `// Value is a primitive: ${getRustType(valSample)}\n`;
                code += `type ${name}Value = ${getRustType(valSample)};\n`;
            }
        } else {
            code += `// HashMap representation\n`;
            code += `// let mut map = HashMap::new();\n`;
            code += `// map.insert("sample_key", ...);\n`;
        }
        return code;
    }

    function getRustType(val) {
        if (val === null) return "Option<serde_json::Value>";
        const type = typeof val;
        if (type === 'string') return "String";
        if (type === 'number') return Number.isInteger(val) ? "i64" : "f64";
        if (type === 'boolean') return "bool";
        if (Array.isArray(val)) {
            if (val.length > 0 && val.every(v => typeof v === 'number' && v >= 0 && v <= 255 && Number.isInteger(v))) {
                return "Vec<u8>";
            }
            return "Vec<serde_json::Value>";
        }
        return "serde_json::Value";
    }

    function jsonToRustStruct(structName, obj) {
        let code = `#[derive(Serialize, Deserialize, Debug)]\nstruct ${structName} {\n`;
        const keys = Object.keys(obj);
        keys.forEach(key => {
            const val = obj[key];
            const fieldName = key; // Rust uses snake_case usually, but keeping key name for simplicity
            let type = "serde_json::Value";
            if (val !== null) {
                if (Array.isArray(val)) {
                    type = (val.length > 0) ? `Vec<${getRustType(val[0])}>` : "Vec<serde_json::Value>";
                } else if (typeof val === 'object') {
                    type = "HashMap<String, serde_json::Value>";
                } else {
                    type = getRustType(val);
                }
            }
            code += `    ${fieldName}: ${type},\n`;
        });
        code += `}\n`;
        return code;
    }

    function copyGeneratedCode() {
        const content = document.getElementById('generated-code-content').textContent;
        navigator.clipboard.writeText(content).then(() => {
            alert("Code copied to clipboard!");
        });
    }

    function toPascalCase(str) {
        return str.replace(/(?:^\w|[A-Z]|\b\w)/g, function(word, index) {
            return word.toUpperCase();
        }).replace(/\s+/g, '').replace(/[^a-zA-Z0-9]/g, '');
    }
    /*
     * showEditStore opens the modal to edit store metadata.
     * 
     * EDITING RULES:
     * 1. Empty Store (Count == 0):
     *    - Full structural rebuild allowed (Key/Value Type, Slot Length, etc.).
     *    - Seed Data inputs are shown to allow initializing the store with a specific type.
     * 
     * 2. Non-Empty Store (Count > 0):
     *    - Structural fields are LOCKED.
     *    - EXCEPTION: Index Spec and CEL can be edited IF AND ONLY IF they are currently missing.
     *    - Description and Cache Duration are always editable.
     */
    function showEditStore() {
        try {
            if (!currentStoreInfo) return;
            
            const modal = document.getElementById('add-store-modal');
            if (modal) {
                modal.style.display = 'flex';
                const header = modal.querySelector('.modal-header span');
                if (header) header.textContent = 'Edit Store Metadata';
            }
            
            // Populate fields
            const nameInput = document.getElementById('new-store-name');
            if (nameInput) {
                nameInput.value = currentStoreInfo.name;
                nameInput.disabled = true; // Name cannot be changed
            }
            
            const descInput = document.getElementById('new-store-description');
            if (descInput) descInput.value = currentStoreInfo.description || '';
            
            // Ensure count is treated as number
            const isEmptyStore = (currentStoreInfo.count === 0);
            console.log("showEditStore: currentStoreInfo.count=", currentStoreInfo.count, "isEmptyStore=", isEmptyStore);
    
            // Key Type (Read-Only unless empty)
            const keyType = document.getElementById('new-store-key-type');
            if (keyType) {
                keyType.value = currentStoreInfo.keyType || 'string';
                keyType.disabled = !isEmptyStore;
            }
            
            const keyIsArray = document.getElementById('new-store-key-is-array');
            if (keyIsArray) {
                keyIsArray.checked = currentStoreInfo.keyIsArray || false;
                keyIsArray.disabled = !isEmptyStore;
            }
            
            // Trigger visibility and populate fields
            if (typeof toggleIndexSpec === 'function') toggleIndexSpec();
            
            if (keyType && keyType.value === 'map') {
                 if (typeof populateKeyFieldsAndIndexSpec === 'function') populateKeyFieldsAndIndexSpec(currentStoreInfo);
                 
                 if (!isEmptyStore) {
                     // Default: Disable all structural fields
                     if (typeof disableKeyAndIndexFields === 'function') disableKeyAndIndexFields();
                 } else {
                     // Empty Store: Enable everything
                     const keyRows = document.querySelectorAll('.key-field-row input, .key-field-row select, .key-field-row button');
                     keyRows.forEach(el => el.disabled = false);
                     
                     const indexRows = document.querySelectorAll('.index-field-row select, .index-field-row button');
                     indexRows.forEach(el => el.disabled = false);
                     
                     const addKeyBtn = document.querySelector('button[onclick="addKeyFieldRow()"]');
                     if (addKeyBtn) addKeyBtn.disabled = false;
                     
                     const addIndexBtn = document.querySelector('button[onclick="addIndexFieldRow()"]');
                     if (addIndexBtn) addIndexBtn.disabled = false;
                 }
            }
    
            // Value Type (Read-Only unless empty)
            const valType = document.getElementById('new-store-value-type');
            if (valType) {
                valType.value = currentStoreInfo.valueType || 'string';
                valType.disabled = !isEmptyStore;
            }
            
            const valIsArray = document.getElementById('new-store-value-is-array');
            if (valIsArray) {
                valIsArray.checked = currentStoreInfo.valueIsArray || false;
                valIsArray.disabled = !isEmptyStore;
            }

            if (typeof toggleValueSpec === 'function') toggleValueSpec();
            
            // Other fields
            const slotLength = document.getElementById('new-store-slot-length');
            if (slotLength) {
                slotLength.value = currentStoreInfo.slotLength || 2000;
                slotLength.disabled = !isEmptyStore;
            }
            
            const isUnique = document.getElementById('new-store-is-unique');
            if (isUnique) {
                isUnique.checked = currentStoreInfo.isUnique !== false;
                isUnique.disabled = !isEmptyStore;
            }
            
            // Infer Data Size from IsValueInNode & IsValueDataActivelyPersisted
            // 0: Small (Value in Node)
            // 1: Medium (Value in Segment, not actively persisted)
            // 2: Big (Value actively persisted)
            let dataSize = "1"; // Default to Medium
            if (currentStoreInfo.isValueActivelyPersisted) {
                dataSize = "2"; // Big
            } else if (currentStoreInfo.isValueInNode) {
                dataSize = "0"; // Small
            }
            const dataSizeInput = document.getElementById('new-store-data-size');
            if (dataSizeInput) {
                dataSizeInput.value = dataSize;
                dataSizeInput.disabled = !isEmptyStore;
            }
            
            const cacheDuration = document.getElementById('new-store-cache-duration');
            if (cacheDuration) {
                cacheDuration.value = currentStoreInfo.cacheDuration || 0;
                cacheDuration.disabled = false; // Always editable
            }
    
            // Infer Streaming Mode
            let isStreaming = false;
            if (currentStoreInfo.keyType === 'map' && currentStoreInfo.valueType === 'blob') {
                 if (currentStoreInfo.indexSpec && currentStoreInfo.indexSpec.index_fields) {
                     const fields = currentStoreInfo.indexSpec.index_fields;
                     if (fields.length > 0 && fields[fields.length-1].field_name === 'ChunkIndex') {
                         isStreaming = true;
                     }
                 }
            }
            const streamingInput = document.getElementById('new-store-is-streaming');
            if (streamingInput) {
                streamingInput.checked = isStreaming;
                streamingInput.disabled = !isEmptyStore;
            }
    
            // Enable Advanced Mode to show all fields
            const advMode = document.getElementById('new-store-advanced-mode');
            if (advMode) advMode.checked = true;
            if (typeof toggleAdvancedOptions === 'function') toggleAdvancedOptions();
    
            // Ensure cache options visibility matches current ValueInNode state
            if (typeof toggleCacheOptions === 'function') toggleCacheOptions();
    
            // Show Unlock Button for non-empty stores to allow Admin override for Index/CEL
            const unlockBtn = document.getElementById('btn-unlock-admin');
            if (unlockBtn) {
                // We allow Admin override for any non-empty store that uses Map keys (Index/CEL supported)
                if (!isEmptyStore && !currentStoreInfo.isPrimitiveKey) {
                    unlockBtn.style.display = 'inline-block';
                } else {
                    unlockBtn.style.display = 'none';
                }
            }
            
            // Show Seed Data (relevant for empty store)
            const seedContainer = document.getElementById('seed-data-container');
            if (seedContainer) seedContainer.style.display = isEmptyStore ? 'block' : 'none';
            if (isEmptyStore) {
                if (typeof populateSeedDataUI === 'function') populateSeedDataUI();
            }
            
            // Update Button
            const footer = document.querySelector('#add-store-modal .modal-footer');
            if (footer) {
                const saveBtn = footer.querySelector('.btn-success');
                if (saveBtn) {
                    saveBtn.textContent = 'Update';
                    saveBtn.onclick = updateStore;
                }
            }
            
            // Enable Description editing
            if (descInput) descInput.disabled = false;
    
            // CEL is structural: editable only when Index is editable.
            const celEditBtn = document.querySelector('#new-store-cel-expression button');
            const hasIndexSpec = !!(currentStoreInfo.indexSpec && currentStoreInfo.indexSpec.index_fields && currentStoreInfo.indexSpec.index_fields.length > 0);
            
            const canEditIndex = isEmptyStore;
    
            if (celEditBtn) {
                celEditBtn.disabled = !canEditIndex;
            }
            const celExprVal = document.getElementById('cel-expression-value');
            if (celExprVal) celExprVal.disabled = !canEditIndex;
    
            // Disable Advanced Mode Toggle
            if (advMode) advMode.disabled = true;
            
        } catch (e) {
            console.error("Error in showEditStore:", e);
            alert("Error showing store details: " + e.message);
        }
    }



    function populateSeedDataUI() {
        if (!currentStoreInfo) return;

        // Populate Seed Key
        const keyType = document.getElementById('new-store-key-type').value;
        if (keyType === 'map') {
            // Ensure forms are generated
            updateSeedKeyForm();
            
            if (currentStoreInfo.sampleKey && typeof currentStoreInfo.sampleKey === 'object') {
                const rows = document.querySelectorAll('.seed-key-field-row');
                rows.forEach(row => {
                    const name = row.getAttribute('data-field');
                    if (currentStoreInfo.sampleKey[name] !== undefined) {
                        row.querySelector('input').value = currentStoreInfo.sampleKey[name];
                    }
                });
            }
        } else {
            if (currentStoreInfo.sampleKey !== undefined) {
                 document.getElementById('new-store-seed-key').value = currentStoreInfo.sampleKey;
            }
        }

        // Populate Seed Value
        const valType = document.getElementById('new-store-value-type').value;
        if (valType === 'map') {
            document.getElementById('seed-value-fields-list').innerHTML = '';
            if (currentStoreInfo.sampleValue && typeof currentStoreInfo.sampleValue === 'object') {
                Object.keys(currentStoreInfo.sampleValue).forEach(k => {
                    const val = currentStoreInfo.sampleValue[k];
                    let type = 'string';
                    const t = typeof val;
                    if (t === 'number') {
                         if (Number.isInteger(val)) type = 'int';
                         if (!Number.isInteger(val)) type = 'float64';
                    } 
                    if (t === 'boolean') type = 'bool';
                    
                    addSeedValueFieldRow(k, type, val);
                });
            }
        } else {
            if (currentStoreInfo.sampleValue !== undefined) {
                let val = currentStoreInfo.sampleValue;
                if (valType === 'blob' && Array.isArray(val)) {
                    if (typeof val === 'object') val = JSON.stringify(val);
                }
                document.getElementById('new-store-seed-value-simple').value = val;
            }
        }
    }

    function unlockAdminFields() {
        try {
            console.log("unlockAdminFields called");
            const token = prompt("Enter Admin Token to unlock structural fields:");
            if (!token) return;
            
            // Validate Token
            fetch('/api/admin/validate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ adminToken: token })
            })
            .then(res => {
                if (!res.ok) {
                    throw new Error("Invalid Admin Token");
                }
                return res.json();
            })
            .then(data => {
                window.currentAdminToken = token;
                proceedUnlock();
            })
            .catch(err => {
                alert("Error: " + err.message);
            });
        } catch (e) {
            console.error("Error in unlockAdminFields:", e);
            alert("Error unlocking: " + e.message);
        }
    }

    function proceedUnlock() {
        try {
            const isEmptyStore = currentStoreInfo && currentStoreInfo.count === 0;

            if (!isEmptyStore) {
                 alert("WARNING: You are about to modify the schema (Index/CEL) of a non-empty store.\n\nThis is an advanced operation. Ensure you understand the implications on existing data.");
            }
    
            // --- Key/Value Structure (Only editable if empty) ---
            if (isEmptyStore) {
                const keyType = document.getElementById('new-store-key-type');
                if (keyType) keyType.disabled = false;
                
                const keyIsArray = document.getElementById('new-store-key-is-array');
                if (keyIsArray) keyIsArray.disabled = false;
                
                // Enable Key Field inputs (for Map keys)
                const keyRows = document.querySelectorAll('.key-field-row input, .key-field-row select, .key-field-row button');
                keyRows.forEach(el => el.disabled = false);
    
                // Enable "Add Key Field" button
                const addKeyFieldBtn = document.querySelector('button[onclick="addKeyFieldRow()"]');
                if (addKeyFieldBtn) addKeyFieldBtn.disabled = false;
    
                const valType = document.getElementById('new-store-value-type');
                if (valType) valType.disabled = false;
                
                const valIsArray = document.getElementById('new-store-value-is-array');
                if (valIsArray) valIsArray.disabled = false;
    
                // Enable Value Map Fields
                const valRows = document.querySelectorAll('.value-field-row input, .value-field-row select, .value-field-row button');
                valRows.forEach(el => el.disabled = false);
                
                // Add "Add Field" button for Value Map if not exists
                const valMapContainer = document.getElementById('value-map-spec-container');
                if (valMapContainer) {
                    let addValBtn = valMapContainer.querySelector('button.add-val-btn');
                    if (!addValBtn) {
                        addValBtn = document.createElement('button');
                        addValBtn.className = 'add-val-btn';
                        addValBtn.textContent = '+ Add Field';
                        addValBtn.onclick = () => addValueFieldRow();
                        addValBtn.style.marginTop = '5px';
                        addValBtn.style.padding = '4px 8px';
                        addValBtn.style.cursor = 'pointer';
                        valMapContainer.appendChild(addValBtn);
                    }
                    addValBtn.disabled = false;
                }
    
                // Show Seed Data Container for Empty Store
                const seedContainer = document.getElementById('seed-data-container');
                if (seedContainer) seedContainer.style.display = 'block';
                
                // Ensure Seed Key form is populated and correct inputs are shown
                if (typeof updateSeedKeyForm === 'function') updateSeedKeyForm();
                if (typeof toggleIndexSpec === 'function') toggleIndexSpec();
                if (typeof populateSeedDataUI === 'function') populateSeedDataUI();
            }
    
            // --- Index & CEL (Always editable when unlocked) ---
    
            // Enable Advanced Mode Toggle
            console.log("Unlocking: advanced-mode");
            // document.getElementById('new-store-advanced-mode').disabled = false;
            
            // Advanced Options: Structural vs Config
            // Slot Length, Is Unique, Value In Node are Structural -> STRICTLY LOCKED ALWAYS
            console.log("Unlocking: slot-length");
            // document.getElementById('new-store-slot-length').disabled = true;
            console.log("Unlocking: is-unique");
            // document.getElementById('new-store-is-unique').disabled = true;
            console.log("Unlocking: data-size");
            // document.getElementById('new-store-data-size').disabled = true;
            console.log("Unlocking: is-streaming");
            // document.getElementById('new-store-is-streaming').disabled = !isEmptyStore;
            
            // Cache Duration is Config -> Always Unlocked
            console.log("Unlocking: cache-duration");
            // document.getElementById('new-store-cache-duration').disabled = false;
            if (typeof toggleCacheOptions === 'function') toggleCacheOptions();
    
            
            // Enable Index Spec inputs
            const indexRows = document.querySelectorAll('.index-field-row select, .index-field-row button');
            indexRows.forEach(el => el.disabled = false);
    
            // Enable "Add Index" button
            const addIndexFieldBtn = document.querySelector('button[onclick="addIndexFieldRow()"]');
            if (addIndexFieldBtn) addIndexFieldBtn.disabled = false;
            
            // CEL is structural: editable only when Index is editable.
            const hasIndexSpec = !!(currentStoreInfo && currentStoreInfo.indexSpec && currentStoreInfo.indexSpec.index_fields && currentStoreInfo.indexSpec.index_fields.length > 0);
            // Since we have Admin Token (we are in unlockAdminFields), we allow editing Index/CEL even if they exist.
            const canEditIndex = true;

            const celEditBtn = document.querySelector('#new-store-cel-expression button');
            if (celEditBtn) {
                celEditBtn.style.display = 'inline-block';
                celEditBtn.disabled = !canEditIndex;
            }
            const celExprVal = document.getElementById('cel-expression-value');
            if (celExprVal) celExprVal.disabled = !canEditIndex;
            
            // Hide the unlock button
            const unlockBtn = document.getElementById('btn-unlock-admin');
            if (unlockBtn) unlockBtn.style.display = 'none';
            
            // Enable Update button
            const saveBtn = document.querySelector('#add-store-modal .modal-footer .btn-success');
            if (saveBtn) saveBtn.disabled = false;
            
        } catch (e) {
            console.error("Error in proceedUnlock:", e);
            alert("Error unlocking: " + e.message);
        }
    }

    function showStoreDetails() {
        // Redirect to Edit Store (which now handles Read-Only/Edit hybrid view)
        showEditStore();
    }

    /* 
    function showStoreDetails_OLD() {
        // ... (Old logic commented out)
    }
    */

    function isEqual(a, b) {
        return false;
    }

    function updateStore() {
        const name = document.getElementById('new-store-name').value.trim();
        const desc = document.getElementById('new-store-description').value.trim();
        const celExpression = document.getElementById('cel-expression-value').value;
        
        const type = document.getElementById('new-store-key-type').value;
        let indexSpec = null;
        if (type === 'map') {
            indexSpec = generateIndexSpecJSON();
        }

        let slotLength = parseInt(document.getElementById('new-store-slot-length').value);
        if (isNaN(slotLength)) slotLength = 2000;
        
        const isUnique = document.getElementById('new-store-is-unique').checked;
        const dataSize = parseInt(document.getElementById('new-store-data-size').value);
        
        let cacheDuration = parseInt(document.getElementById('new-store-cache-duration').value);
        if (isNaN(cacheDuration)) cacheDuration = 0;
        let isCacheTTL = document.getElementById('new-store-cache-ttl').checked;

        // If Data Size is Small (0) or Big (2), cache settings are not applicable/hidden.
        if (dataSize !== 1) {
            cacheDuration = 0;
            isCacheTTL = false;
        }

        // Seed Data (Only if visible/empty)
        let seedKey = null;
        let seedValue = null;
        const seedContainer = document.getElementById('seed-data-container');
        
        if (seedContainer.style.display !== 'none') {
             // Reuse logic from saveNewStore (simplified duplication for now)
             if (type === 'map') {
                const rows = document.querySelectorAll('.seed-key-field-row');
                if (rows.length > 0) {
                    seedKey = {};
                    rows.forEach(row => {
                        const name = row.getAttribute('data-name') || row.getAttribute('data-field');
                        const valStr = row.querySelector('.seed-key-field-value').value;
                        const typeDefRow = Array.from(document.querySelectorAll('.key-field-row')).find(r => r.querySelector('.key-field-name').value.trim() === name);
                        const fieldType = typeDefRow ? typeDefRow.querySelector('.key-field-type').value : 'string';
                        let val = valStr;
                        if (['int', 'int8', 'int16', 'int32', 'int64', 'uint', 'uint8', 'uint16', 'uint32', 'uint64', 'rune'].includes(fieldType)) {
                            val = parseInt(valStr); if (isNaN(val)) val = 0;
                        } else if (['float32', 'float64', 'decimal'].includes(fieldType)) {
                            val = parseFloat(valStr); if (isNaN(val)) val = 0.0;
                        } else if (fieldType === 'bool') {
                            val = (valStr.toLowerCase() === 'true' || valStr === '1');
                        }
                        seedKey[name] = val;
                    });
                }
             } else {
                 const seedKeyStr = document.getElementById('new-store-seed-key').value.trim();
                 if (seedKeyStr) {
                     seedKey = seedKeyStr;
                     // Parse based on selected Key Type to ensure backend receives correct type
                     if (['int', 'int8', 'int16', 'int32', 'int64', 'uint', 'uint8', 'uint16', 'uint32', 'uint64', 'rune'].includes(type)) {
                         const n = parseInt(seedKeyStr);
                         if (!isNaN(n)) seedKey = n;
                     } else if (['float32', 'float64', 'decimal'].includes(type)) {
                         const n = parseFloat(seedKeyStr);
                         if (!isNaN(n)) seedKey = n;
                     } else if (type === 'bool') {
                         seedKey = (seedKeyStr.toLowerCase() === 'true' || seedKeyStr === '1');
                     }
                 }
             }
             
             try {
                seedValue = generateSeedValueJSON();
             } catch (e) {
                alert(e.message);
                return;
             }
        }

        const payload = {
            database: currentDatabase,
            storeName: name,
            description: desc,
            keyType: type,
            valueType: document.getElementById('new-store-value-type').value,
            celExpression: celExpression,
            indexSpec: indexSpec,
            slotLength: slotLength,
            isUnique: isUnique,
            dataSize: dataSize,
            cacheDuration: cacheDuration,
            isCacheTTL: isCacheTTL,
            seedKey: seedKey,
            seedValue: seedValue,
            adminToken: window.currentAdminToken || ""
        };

        fetch('/api/store/update', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(async res => {
            if (!res.ok) {
                const text = await res.text();
                if (text.includes("Cannot update") && text.includes("structure") && !window.currentAdminToken) {
                    const token = prompt("Structural changes detected. Please enter Admin Token to override:");
                    if (token) {
                        window.currentAdminToken = token;
                        payload.adminToken = token;
                        return fetch('/api/store/update', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        }).then(async res2 => {
                            if (!res2.ok) {
                                const text2 = await res2.text();
                                throw new Error(text2 || res2.statusText);
                            }
                            return res2.json();
                        });
                    }
                }
                throw new Error(text || res.statusText);
            }
            return res.json();
        })
        .then(data => {
            closeAddStoreModal();
            // Refresh store info
            selectDatabase(currentDatabase, true, name);
            if (data && data.warning) {
                alert('Store updated successfully.\n\nWARNING: ' + data.warning);
            } else {
                alert('Store updated successfully.');
            }
        })
        .catch(err => {
            alert("Error updating store: " + err.message);
        });
    }

    function showAddStore() {
        // currentStoreInfo = null; // Do not clear this, as it breaks Edit Store if we cancel Add
        window.currentAdminToken = null;

        document.getElementById('add-store-modal').style.display = 'flex';
        document.querySelector('#add-store-modal .modal-header span').textContent = 'Add New Store';

        // Reset Button
        const footer = document.querySelector('#add-store-modal .modal-footer');
        const saveBtn = footer.querySelector('.btn-success');
        saveBtn.textContent = 'Add';
        saveBtn.onclick = saveNewStore;
        saveBtn.disabled = false;

        // Reset Basic Fields
        document.getElementById('new-store-name').value = '';
        document.getElementById('new-store-name').disabled = false;
        document.getElementById('new-store-description').value = '';
        document.getElementById('new-store-description').disabled = false;

        // Reset Key Type
        document.getElementById('new-store-key-type').value = 'string';
        document.getElementById('new-store-key-type').disabled = false;
        document.getElementById('new-store-key-is-array').checked = false;
        document.getElementById('new-store-key-is-array').disabled = false;
        
        // Reset Value Type
        document.getElementById('new-store-value-type').value = 'string';
        document.getElementById('new-store-value-type').disabled = false;
        document.getElementById('new-store-value-is-array').checked = false;
        document.getElementById('new-store-value-is-array').disabled = false;

        // Reset CEL
        document.getElementById('cel-expression-value').value = '';
        document.getElementById('cel-expression-value').disabled = false;
        const celEditBtn = document.querySelector('#new-store-cel-expression button');
        if (celEditBtn) celEditBtn.disabled = false;

        // Reset Advanced Mode
        document.getElementById('new-store-advanced-mode').checked = false;
        document.getElementById('new-store-advanced-mode').disabled = false;
        toggleAdvancedOptions();

        // Reset Advanced Fields
        document.getElementById('new-store-slot-length').value = 2000;
        document.getElementById('new-store-slot-length').disabled = false;
        document.getElementById('new-store-is-unique').checked = true;
        document.getElementById('new-store-is-unique').disabled = false;
        document.getElementById('new-store-data-size').value = "0"; // Small
        document.getElementById('new-store-data-size').disabled = false;
        
        document.getElementById('new-store-cache-duration').value = 0;
        document.getElementById('new-store-cache-duration').disabled = false;
        document.getElementById('new-store-is-streaming').checked = false;
        document.getElementById('new-store-is-streaming').disabled = false;
        
        toggleCacheOptions();

        // Clear Dynamic Lists
        document.getElementById('key-fields-list').innerHTML = '';
        document.getElementById('index-fields-list').innerHTML = '';
        document.getElementById('value-map-fields-list').innerHTML = '';
        document.getElementById('seed-key-fields-list').innerHTML = '';
        document.getElementById('seed-value-fields-list').innerHTML = '';

        // Reset Seed Data Inputs
        document.getElementById('new-store-seed-key').value = '';
        document.getElementById('new-store-seed-value-simple').value = '';
        document.getElementById('seed-data-container').style.display = 'block'; // Always show for new store

        // Reset UI State
        toggleIndexSpec();
        
        // Re-enable Add Buttons (in case they were disabled by Edit Store)
        const addKeyBtn = document.querySelector('button[onclick="addKeyFieldRow()"]');
        if (addKeyBtn) addKeyBtn.disabled = false;
        
        const addIndexBtn = document.querySelector('button[onclick="addIndexFieldRow()"]');
        if (addIndexBtn) addIndexBtn.disabled = false;
        
        // Hide Unlock Button
        const unlockBtn = document.getElementById('btn-unlock-admin');
        if (unlockBtn) unlockBtn.style.display = 'none';

        // Sync UI with reset values
        if (typeof toggleIndexSpec === 'function') toggleIndexSpec();
        if (typeof toggleValueSpec === 'function') toggleValueSpec();
    }

    function closeAddStoreModal() {
        document.getElementById('add-store-modal').style.display = 'none';
        window.currentAdminToken = null;
        const unlockBtn = document.getElementById('btn-unlock-admin');
        if (unlockBtn) unlockBtn.style.display = 'none';
    }

    function addValueFieldRow(name = '', type = 'string', value = '') {
        const container = document.getElementById('value-map-fields-list');
        const div = document.createElement('div');
        div.className = 'value-field-row';
        div.style.display = 'flex';
        div.style.gap = '5px';
        div.innerHTML = `
            <input type="text" placeholder="Field Name" class="value-field-name" value="${name}" style="flex:1; padding: 4px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color);">
            <select class="value-field-type" style="width: 100px; padding: 4px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color);">
                <option value="string" ${type==='string'?'selected':''}>String</option>
                <option value="int" ${type==='int'?'selected':''}>Int</option>
                <option value="float64" ${type==='float64'?'selected':''}>Float64</option>
                <option value="bool" ${type==='bool'?'selected':''}>Bool</option>
            </select>
            <input type="text" placeholder="Value" class="value-field-value" value="${value}" style="flex:1; padding: 4px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color);">
            <button onclick="this.parentElement.remove();" style="background:var(--danger-bg); color:white; border:none; padding: 4px 8px; cursor:pointer;">×</button>
        `;
        container.appendChild(div);
    }

    // Updates the visibility of the "Is Array" checkbox based on the selected type.
    // Blob and Map types cannot be arrays, so we hide the checkbox.
    function updateArrayCheckboxVisibility(type, checkboxId) {
        const checkbox = document.getElementById(checkboxId);
        // Try to find the label container by ID convention first
        let container = document.getElementById(checkboxId + '-label');
        
        // Fallback to parentElement if no specific container found
        if (!container && checkbox) {
            container = checkbox.parentElement;
        }

        if (container) {
            if (type === 'blob' || type === 'map') {
                if (checkbox) checkbox.checked = false;
                container.style.display = 'none';
            } else {
                container.style.display = 'flex';
            }
        }
    }

    function toggleIndexSpec() {
        const type = document.getElementById('new-store-key-type').value;
        updateArrayCheckboxVisibility(type, 'new-store-key-is-array');

        const container = document.getElementById('index-spec-container');
        const celContainer = document.getElementById('new-store-cel-expression');
        
        const simpleKeyInput = document.getElementById('new-store-seed-key');
        const mapKeyContainer = document.getElementById('new-store-seed-key-map-container');

        if (type === 'map') {
            container.style.display = 'block';
            if (celContainer) celContainer.style.display = 'block';
            simpleKeyInput.style.display = 'none';
            mapKeyContainer.style.display = 'block';

            // Initialize with one row if empty
            if (document.getElementById('key-fields-list').children.length === 0) {
                addKeyFieldRow();
            }
            updateSeedKeyForm();
        } else {
            container.style.display = 'none';
            if (celContainer) celContainer.style.display = 'none';
            simpleKeyInput.style.display = 'block';
            mapKeyContainer.style.display = 'none';
        }
    }

    // --- Map Key Builder Logic ---
    function addKeyFieldRow(name = '', type = 'string') {
        const container = document.getElementById('key-fields-list');
        const div = document.createElement('div');
        div.className = 'key-field-row';
        div.style.display = 'flex';
        div.style.gap = '5px';
        div.innerHTML = `
            <input type="text" placeholder="Field Name" class="key-field-name" value="${name}" oninput="updateIndexDropdowns(); updateSeedKeyForm();" style="flex:1; padding: 4px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color);">
            <select class="key-field-type" onchange="updateSeedKeyForm()" style="width: 100px; padding: 4px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color);">
                <option value="string" ${type==='string'?'selected':''}>String</option>
                <option value="int" ${type==='int'?'selected':''}>Int</option>
                <option value="int8" ${type==='int8'?'selected':''}>Int8</option>
                <option value="int16" ${type==='int16'?'selected':''}>Int16</option>
                <option value="int32" ${type==='int32'?'selected':''}>Int32</option>
                <option value="int64" ${type==='int64'?'selected':''}>Int64</option>
                <option value="uint" ${type==='uint'?'selected':''}>Uint</option>
                <option value="uint8" ${type==='uint8'?'selected':''}>Uint8</option>
                <option value="uint16" ${type==='uint16'?'selected':''}>Uint16</option>
                <option value="uint32" ${type==='uint32'?'selected':''}>Uint32</option>
                <option value="uint64" ${type==='uint64'?'selected':''}>Uint64</option>
                <option value="float32" ${type==='float32'?'selected':''}>Float32</option>
                <option value="float64" ${type==='float64'?'selected':''}>Float64</option>
                <option value="complex64" ${type==='complex64'?'selected':''}>Complex64</option>
                <option value="complex128" ${type==='complex128'?'selected':''}>Complex128</option>
                <option value="rune" ${type==='rune'?'selected':''}>Rune</option>
                <option value="decimal" ${type==='decimal'?'selected':''}>Decimal</option>
                <option value="bool" ${type==='bool'?'selected':''}>Bool</option>
                <option value="timestamp" ${type==='timestamp'?'selected':''}>Timestamp</option>
                <option value="timestampz" ${type==='timestampz'?'selected':''}>TimestampZ</option>
                <option value="date" ${type==='date'?'selected':''}>Date</option>
                <option value="datetime" ${type==='datetime'?'selected':''}>DateTime</option>
                <option value="time" ${type==='time'?'selected':''}>Time</option>
                <option value="guid" ${type==='guid'?'selected':''}>UUID</option>
                <option value="blob" ${type==='blob'?'selected':''}>Blob</option>
            </select>
            <div style="display:flex; gap:0; align-items:center; border: 1px solid var(--input-border); border-radius: 4px; background: var(--input-bg);">
                <button onclick="moveFieldRow(this, -1)" style="cursor:pointer; background:none; border:none; color:var(--text-color); padding: 2px 6px;" title="Move Up">↑</button>
                <button onclick="moveFieldRow(this, 1)" style="cursor:pointer; background:none; border:none; color:var(--text-color); padding: 2px 6px; border-left: 1px solid var(--input-border);" title="Move Down">↓</button>
                <button onclick="this.closest('.key-field-row').remove(); updateIndexDropdowns(); updateSeedKeyForm();" style="color:red; cursor:pointer; background:none; border:none; padding: 2px 6px; border-left: 1px solid var(--input-border);">&times;</button>
            </div>
        `;
        container.appendChild(div);
        updateIndexDropdowns();
        updateSeedKeyForm();
    }

    function moveFieldRow(btn, direction) {
        const row = btn.closest('.key-field-row, .seed-value-field-row, .index-field-row');
        const container = row.parentElement;
        if (direction === -1) {
            if (row.previousElementSibling) {
                container.insertBefore(row, row.previousElementSibling);
            }
        } else {
            if (row.nextElementSibling) {
                container.insertBefore(row.nextElementSibling, row);
            }
        }
        // Update dependent UI
        if (row.classList.contains('key-field-row')) {
            updateIndexDropdowns();
            updateSeedKeyForm();
        }
    }

    function updateSeedKeyForm() {
        const container = document.getElementById('seed-key-fields-list');
        if (!container) return;
        
        const currentValues = {};
        container.querySelectorAll('.seed-key-field-row').forEach(row => {
            const name = row.getAttribute('data-field');
            const val = row.querySelector('input').value;
            if (name) currentValues[name] = val;
        });

        container.innerHTML = '';
        
        const keyRows = document.querySelectorAll('.key-field-row');
        keyRows.forEach(row => {
            const nameInput = row.querySelector('.key-field-name');
            const typeSelect = row.querySelector('.key-field-type');
            const name = nameInput.value.trim();
            const type = typeSelect.value;
            
            if (!name) return; // Skip empty names

            const div = document.createElement('div');
            div.className = 'seed-key-field-row';
            div.setAttribute('data-field', name);
            div.setAttribute('data-type', type);
            div.style.display = 'flex';
            div.style.alignItems = 'center';
            div.style.gap = '5px';
            
            const val = currentValues[name] || '';
            
            div.innerHTML = `
                <label style="width: 100px; font-size: 12px; overflow:hidden; text-overflow:ellipsis;" title="${name}">${name} (${type}):</label>
                <input type="text" class="seed-key-field-value" value="${val}" style="flex:1; padding: 4px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color);">
            `;
            container.appendChild(div);
        });
    }

    function addIndexFieldRow(fieldName = '', order = 'asc') {
        const container = document.getElementById('index-fields-list');
        const div = document.createElement('div');
        div.className = 'index-field-row';
        div.style.display = 'flex';
        div.style.gap = '5px';
        div.innerHTML = `
            <select class="index-field-select" style="flex:1; padding: 4px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color);">
                <!-- Populated by updateIndexDropdowns -->
            </select>
            <select class="index-field-order" style="width: 80px; padding: 4px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color);">
                <option value="asc" ${order==='asc'?'selected':''}>Asc</option>
                <option value="desc" ${order==='desc'?'selected':''}>Desc</option>
            </select>
            <div style="display:flex; gap:0; align-items:center; border: 1px solid var(--input-border); border-radius: 4px; background: var(--input-bg);">
                <button onclick="moveFieldRow(this, -1)" style="cursor:pointer; background:none; border:none; color:var(--text-color); padding: 2px 6px;" title="Move Up">↑</button>
                <button onclick="moveFieldRow(this, 1)" style="cursor:pointer; background:none; border:none; color:var(--text-color); padding: 2px 6px; border-left: 1px solid var(--input-border);" title="Move Down">↓</button>
                <button onclick="this.closest('.index-field-row').remove()" style="color:red; cursor:pointer; background:none; border:none; padding: 2px 6px; border-left: 1px solid var(--input-border);">&times;</button>
            </div>
        `;
        container.appendChild(div);
        const select = div.querySelector('.index-field-select');
        updateIndexDropdowns(select);
        if (fieldName) {
            select.value = fieldName;
        }
    }

    function populateKeyFieldsAndIndexSpec(info) {
        // 1. Populate Key Fields (Definition)
        const keyList = document.getElementById('key-fields-list');
        keyList.innerHTML = '';
        
        let fieldsFound = false;
        
        if (info.sampleKey && typeof info.sampleKey === 'object') {
            Object.keys(info.sampleKey).forEach(k => {
                const val = info.sampleKey[k];
                let type = 'string';
                const t = typeof val;
                if (t === 'number') {
                     if (Number.isInteger(val)) type = 'int';
                     else type = 'float64';
                } else if (t === 'boolean') type = 'bool';
                
                addKeyFieldRow(k, type);
            });
            fieldsFound = true;
        }
        
        // Fallback to Index Spec if sample key is missing
        if (!fieldsFound && info.indexSpec && info.indexSpec.index_fields) {
            info.indexSpec.index_fields.forEach(f => {
                addKeyFieldRow(f.field_name, 'string');
            });
        }

        // 2. Populate Index Spec
        const indexList = document.getElementById('index-fields-list');
        indexList.innerHTML = '';
        
        if (info.indexSpec && info.indexSpec.index_fields) {
            info.indexSpec.index_fields.forEach(f => {
                addIndexFieldRow(f.field_name, f.ascending_sort_order ? 'asc' : 'desc');
            });
        }
    }

    function disableKeyAndIndexFields() {
        const keyRows = document.querySelectorAll('.key-field-row input, .key-field-row select, .key-field-row button');
        keyRows.forEach(el => el.disabled = true);
        
        const indexRows = document.querySelectorAll('.index-field-row select, .index-field-row button');
        indexRows.forEach(el => el.disabled = true);
        
        // Disable Add buttons
        const addKeyBtn = document.querySelector('button[onclick="addKeyFieldRow()"]');
        if (addKeyBtn) addKeyBtn.disabled = true;
        
        const addIndexBtn = document.querySelector('button[onclick="addIndexFieldRow()"]');
        if (addIndexBtn) addIndexBtn.disabled = true;
    }

    function updateIndexDropdowns(targetSelect = null) {
        // Collect all defined key field names
        const keyRows = document.querySelectorAll('.key-field-row');
        const fieldNames = [];
        keyRows.forEach(row => {
            const name = row.querySelector('.key-field-name').value.trim();
            if (name) fieldNames.push(name);
        });

        // Update all index dropdowns
        const indexSelects = document.querySelectorAll('.index-field-select');
        indexSelects.forEach(select => {
            const currentVal = select.value;
            select.innerHTML = '';
            fieldNames.forEach(name => {
                const opt = document.createElement('option');
                opt.value = name;
                opt.text = name;
                if (name === currentVal) opt.selected = true;
                select.appendChild(opt);
            });
        });
    }

    function generateIndexSpecJSON() {
        const indexRows = document.querySelectorAll('.index-field-row');
        if (indexRows.length === 0) return "";

        const fields = [];
        indexRows.forEach(row => {
            const name = row.querySelector('.index-field-select').value;
            const order = row.querySelector('.index-field-order').value;
            if (name) {
                fields.push({
                    field_name: name,
                    ascending_sort_order: order === 'asc'
                });
            }
        });

        if (fields.length === 0) return "";

        return JSON.stringify({ index_fields: fields });
    }

    function toggleAdvancedOptions() {
        const advanced = document.getElementById('new-store-advanced-mode').checked;
        const container = document.getElementById('advanced-options-container');
        container.style.display = advanced ? 'block' : 'none';
        if (advanced) {
            toggleCacheOptions();
            updateSlotLengthWarning();
        }
    }

    function updateSlotLengthWarning() {
        const val = parseInt(document.getElementById('new-store-slot-length').value);
        const warning = document.getElementById('slot-length-warning');
        if (isNaN(val)) {
            warning.style.display = 'none';
            return;
        }
        
        if (val < 10) {
            warning.textContent = "Warning: Very low slot length will degrade performance due to frequent node splitting/merging.";
            warning.style.display = 'block';
        } else if (val > 5000) {
            warning.textContent = "Warning: Large slot length (>5000) may diminish performance gains and increase memory usage per node (L1/L2 cache pressure) when the node is full.";
            warning.style.display = 'block';
        } else {
            warning.style.display = 'none';
        }
    }

    function toggleCacheOptions() {
        const dataSize = document.getElementById('new-store-data-size').value;
        const container = document.getElementById('cache-options-container');
        
        // Data Size: 0=Small, 1=Medium, 2=Big
        // Small (0): Value in Node -> No Cache Config needed (implicit)
        // Medium (1): Value separate -> Cache Config allowed
        // Big (2): Value separate + Persisted -> No Cache Config (typically)
        
        if (dataSize === "1") { // Medium
            container.style.display = 'block';
        } else {
            container.style.display = 'none';
            // Reset values if hidden? Or keep them?
            // If hidden, user can't edit.
            // For Big (2), we might want to force disable cache.
            // For Small (0), cache is irrelevant.
        }
    }

    function toggleSeedHelp() {
        const el = document.getElementById('seed-help-text');
        if (el.style.display === 'none') {
            el.style.display = 'block';
        } else {
            el.style.display = 'none';
        }
    }

    function toggleSeedValueMode() {
        const isRaw = document.getElementById('seed-value-raw-mode').checked;
        document.getElementById('seed-value-builder').style.display = isRaw ? 'none' : 'block';
        document.getElementById('new-store-seed-value').style.display = isRaw ? 'block' : 'none';
    }

    let preStreamingState = null;

    function toggleStreamingMode() {
        const isStreaming = document.getElementById('new-store-is-streaming').checked;
        const keyTypeSelect = document.getElementById('new-store-key-type');
        const valueTypeSelect = document.getElementById('new-store-value-type');
        const valueInNode = document.getElementById('new-store-value-in-node');
        const dataSizeSelect = document.getElementById('new-store-data-size');
        
        if (isStreaming) {
            // 1. Force Key Type to Map
            if (keyTypeSelect.value !== 'map') {
                keyTypeSelect.value = 'map';
                // Clear existing fields to avoid "undefined" field from toggleIndexSpec default
                document.getElementById('key-fields-list').innerHTML = '';
                toggleIndexSpec(); 
                
                // Add default "Key" field (String) if list is empty
                const rows = document.getElementById('key-fields-list').children;
                if (rows.length === 0) {
                     addKeyFieldRow('Key', 'string');
                } else if (rows.length === 1) {
                    const nameInput = rows[0].querySelector('.key-field-name');
                    if (!nameInput.value) nameInput.value = 'Key';
                }
            }
            
            // 2. Add ChunkIndex field if not exists
            const keyFields = document.querySelectorAll('.key-field-name');
            let hasChunkIndex = false;
            keyFields.forEach(f => { if (f.value === 'ChunkIndex') hasChunkIndex = true; });
            
            if (!hasChunkIndex) {
                addKeyFieldRow('ChunkIndex', 'int');
            }
            
            // 3. Add ChunkIndex to Index Spec if not exists
            const indexSelects = document.querySelectorAll('.index-field-select');
            let hasChunkIndexIndex = false;
            indexSelects.forEach(s => { if (s.value === 'ChunkIndex') hasChunkIndexIndex = true; });
            
            if (!hasChunkIndexIndex) {
                addIndexFieldRow();
                const rows = document.getElementById('index-fields-list').children;
                const lastRow = rows[rows.length - 1];
                const select = lastRow.querySelector('.index-field-select');
                select.value = 'ChunkIndex';
            }
            
            // 4. Force Value Type to Blob
            valueTypeSelect.value = 'blob';
            toggleValueSpec(); 

            // 5. Auto-set Data Size to Big
            if (dataSizeSelect) {
                dataSizeSelect.value = "2"; // Big
                toggleCacheOptions();
            }
            
            if (typeof toggleIndexSpec === 'function') toggleIndexSpec();
            if (typeof toggleValueSpec === 'function') toggleValueSpec();

            // 6. Disable Value In Node (Handled by Data Size now)
            // if (valueInNode) { valueInNode.checked = false; valueInNode.disabled = true; }
            
            // 6. Update Seed Data Values
            setTimeout(() => {
                const seedRows = document.querySelectorAll('.seed-key-field-row');
                seedRows.forEach(row => {
                    const name = row.getAttribute('data-name');
                    const input = row.querySelector('input');
                    if (name === 'ChunkIndex') input.value = '0';
                    if (name === 'Key' && !input.value) input.value = 'sample_id';
                });
            }, 0);
            
            // Set Value to sample byte array
            document.getElementById('new-store-seed-value-simple').value = "[10, 20, 30, 40, 50]";

        } else {
            // Restore Value In Node
            valueInNode.disabled = false;
            valueInNode.checked = true;
        }
        
        if (typeof toggleCacheOptions === 'function') toggleCacheOptions();
    }

    function addSeedValueFieldRow(name = '', type = 'string', value = '') {
        const container = document.getElementById('seed-value-fields-list');
        const div = document.createElement('div');
        div.className = 'seed-value-field-row';
        div.style.display = 'flex';
        div.style.gap = '5px';
        div.innerHTML = `
            <input type="text" placeholder="Field Name" class="seed-field-name" value="${name}" style="flex:1; padding: 4px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color);">
            <select class="seed-field-type" style="width: 80px; padding: 4px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color);">
                <option value="string" ${type==='string'?'selected':''}>String</option>
                <option value="int" ${type==='int'?'selected':''}>Int</option>
                <option value="int8" ${type==='int8'?'selected':''}>Int8</option>
                <option value="int16" ${type==='int16'?'selected':''}>Int16</option>
                <option value="int32" ${type==='int32'?'selected':''}>Int32</option>
                <option value="int64" ${type==='int64'?'selected':''}>Int64</option>
                <option value="uint" ${type==='uint'?'selected':''}>Uint</option>
                <option value="uint8" ${type==='uint8'?'selected':''}>Uint8</option>
                <option value="uint16" ${type==='uint16'?'selected':''}>Uint16</option>
                <option value="uint32" ${type==='uint32'?'selected':''}>Uint32</option>
                <option value="uint64" ${type==='uint64'?'selected':''}>Uint64</option>
                <option value="float32" ${type==='float32'?'selected':''}>Float32</option>
                <option value="float64" ${type==='float64'?'selected':''}>Float64</option>
                <option value="complex64" ${type==='complex64'?'selected':''}>Complex64</option>
                <option value="complex128" ${type==='complex128'?'selected':''}>Complex128</option>
                <option value="rune" ${type==='rune'?'selected':''}>Rune</option>
                <option value="decimal" ${type==='decimal'?'selected':''}>Decimal</option>
                <option value="bool" ${type==='bool'?'selected':''}>Bool</option>
                <option value="timestamp" ${type==='timestamp'?'selected':''}>Timestamp</option>
                <option value="timestampz" ${type==='timestampz'?'selected':''}>TimestampZ</option>
                <option value="date" ${type==='date'?'selected':''}>Date</option>
                <option value="datetime" ${type==='datetime'?'selected':''}>DateTime</option>
                <option value="time" ${type==='time'?'selected':''}>Time</option>
                <option value="guid" ${type==='guid'?'selected':''}>UUID</option>
                <option value="blob" ${type==='blob'?'selected':''}>Blob</option>
            </select>
            <input type="text" placeholder="Value" class="seed-field-value" value="${value}" style="flex:1; padding: 4px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color);">
            <div style="display:flex; gap:0; align-items:center; border: 1px solid var(--input-border); border-radius: 4px; background: var(--input-bg);">
                <button onclick="moveFieldRow(this, -1)" style="cursor:pointer; background:none; border:none; color:var(--text-color); padding: 2px 6px;" title="Move Up">↑</button>
                <button onclick="moveFieldRow(this, 1)" style="cursor:pointer; background:none; border:none; color:var(--text-color); padding: 2px 6px; border-left: 1px solid var(--input-border);" title="Move Down">↓</button>
                <button onclick="this.closest('.seed-value-field-row').remove()" style="color:red; cursor:pointer; background:none; border:none; padding: 2px 6px; border-left: 1px solid var(--input-border);">&times;</button>
            </div>
        `;
        container.appendChild(div);
    }

    function generateSeedValueJSON() {
        const valType = document.getElementById('new-store-value-type').value;
        
        // 1. Handle Non-Map Types (Simple Input)
        if (valType !== 'map') {
            const valStr = document.getElementById('new-store-seed-value-simple').value.trim();
            if (!valStr) return null;
            
            const isArray = document.getElementById('new-store-value-is-array').checked;
            if (isArray) {
                try {
                    return JSON.parse(valStr);
                } catch (e) {
                    throw new Error("For Array types, please enter a valid JSON array (e.g. [1, 2])");
                }
            }

            // Single Value Parsing
            if (['int', 'int8', 'int16', 'int32', 'int64', 'uint', 'uint8', 'uint16', 'uint32', 'uint64', 'rune'].includes(valType)) {
                let val = parseInt(valStr);
                if (isNaN(val)) val = 0;
                return val;
            } else if (['float32', 'float64', 'decimal'].includes(valType)) {
                let val = parseFloat(valStr);
                if (isNaN(val)) val = 0.0;
                return val;
            } else if (valType === 'bool') {
                return (valStr.toLowerCase() === 'true' || valStr === '1');
            } else if (valType === 'timestamp') {
                let t = parseInt(valStr);
                if (isNaN(t)) {
                    t = Date.parse(valStr);
                    if (isNaN(t)) t = 0;
                }
                return t;
            } else if (valType === 'blob') {
                try {
                    const parsed = JSON.parse(valStr);
                    if (Array.isArray(parsed)) return parsed;
                } catch (e) {}

                // Fallback: Convert string to byte array
                let val = [];
                for (let i = 0; i < valStr.length; i++) {
                    val.push(valStr.charCodeAt(i));
                }
                return val;
            }
            
            // Default string, date, etc.
            return valStr;
        }

        // 2. Handle Map Type (Builder or Raw)
        const isRaw = document.getElementById('seed-value-raw-mode').checked;
        if (isRaw) {
            const raw = document.getElementById('new-store-seed-value').value.trim();
            if (!raw) return null;
            try {
                return JSON.parse(raw);
            } catch (e) {
                throw new Error("Seed Value (Raw) must be valid JSON");
            }
        } else {
            const rows = document.querySelectorAll('.seed-value-field-row');
            if (rows.length === 0) return null;
            
            const obj = {};
            rows.forEach(row => {
                const name = row.querySelector('.seed-field-name').value.trim();
                const type = row.querySelector('.seed-field-type').value;
                const valStr = row.querySelector('.seed-field-value').value;
                
                if (name) {
                    let val = valStr;
                    if (['int', 'int8', 'int16', 'int32', 'int64', 'uint', 'uint8', 'uint16', 'uint32', 'uint64', 'rune'].includes(type)) {
                        val = parseInt(valStr);
                        if (isNaN(val)) val = 0;
                    } else if (['float32', 'float64', 'decimal'].includes(type)) {
                        val = parseFloat(valStr);
                        if (isNaN(val)) val = 0.0;
                    } else if (['complex64', 'complex128'].includes(type)) {
                        // Treat complex as string for now, or parse if user provides "real,imag"
                        val = valStr;
                    } else if (type === 'bool') {
                        val = (valStr.toLowerCase() === 'true' || valStr === '1');
                    } else if (type === 'timestamp') {
                        let t = parseInt(valStr);
                        if (isNaN(t)) {
                            t = Date.parse(valStr);
                            if (isNaN(t)) t = 0;
                        }
                        val = t;
                    } else if (['date', 'datetime', 'time', 'guid', 'timestampz'].includes(type)) {
                        val = valStr;
                    } else if (type === 'blob') {
                        // Convert string to byte array (simple ASCII for now)
                        val = [];
                        for (let i = 0; i < valStr.length; i++) {
                            val.push(valStr.charCodeAt(i));
                        }
                    }
                    obj[name] = val;
                }
            });
            return obj;
        }
    }

    function toggleValueSpec() {
        const valType = document.getElementById('new-store-value-type').value;
        updateArrayCheckboxVisibility(valType, 'new-store-value-is-array');
        
        const simpleInput = document.getElementById('new-store-seed-value-simple');
        const builder = document.getElementById('seed-value-builder');
        const rawInput = document.getElementById('new-store-seed-value');
        const rawOption = document.getElementById('seed-value-raw-option');
        const rawModeCheckbox = document.getElementById('seed-value-raw-mode');

        // If map, show builder or raw json
        if (valType === 'map') {
            if (rawOption) rawOption.style.display = 'block';
            if (rawModeCheckbox && rawModeCheckbox.checked) {
                if (simpleInput) simpleInput.style.display = 'none';
                if (builder) builder.style.display = 'none';
                if (rawInput) rawInput.style.display = 'block';
            } else {
                if (simpleInput) simpleInput.style.display = 'none';
                if (builder) builder.style.display = 'block';
                if (rawInput) rawInput.style.display = 'none';
            }
        } else {
            // Simple type
            if (rawOption) rawOption.style.display = 'none';
            if (simpleInput) simpleInput.style.display = 'block';
            if (builder) builder.style.display = 'none';
            if (rawInput) rawInput.style.display = 'none';
        }
    }

    function saveNewStore() {
        const name = document.getElementById('new-store-name').value.trim();
        const type = document.getElementById('new-store-key-type').value;
        const desc = document.getElementById('new-store-description').value.trim();
        
        let indexSpec = "";
        const celExpression = document.getElementById('cel-expression-value').value;

        if (type === 'map') {
            indexSpec = generateIndexSpecJSON();
            
            // Validation: Map Key must have Index OR CEL, unless bypassed via env var
            if (!ALLOW_INVALID_MAP_KEY) {
                const hasIndex = indexSpec && indexSpec !== "";
                const hasCEL = celExpression && celExpression.trim() !== "";
                
                if (!hasIndex && !hasCEL) {
                    alert("Map Key type requires an Index Specification OR a CEL Expression.");
                    return;
                }
            }
        }

        const advancedMode = document.getElementById('new-store-advanced-mode').checked;
        let slotLength = parseInt(document.getElementById('new-store-slot-length').value);
        if (isNaN(slotLength) || slotLength < 2) slotLength = 2;
        if (slotLength > 10000) slotLength = 10000;

        const isUnique = document.getElementById('new-store-is-unique').checked;
        const dataSize = parseInt(document.getElementById('new-store-data-size').value);
        let cacheDuration = parseInt(document.getElementById('new-store-cache-duration').value);
        if (isNaN(cacheDuration)) cacheDuration = 0;
        let isCacheTTL = document.getElementById('new-store-cache-ttl').checked;
        // celExpression already retrieved above

        // If Data Size is Small (0) or Big (2), cache settings are not applicable/hidden.
        if (dataSize !== 1) {
            cacheDuration = 0;
            isCacheTTL = false;
        }

        if (!name) {
            alert("Store name is required");
            return;
        }

        // Parse Seed Data
        let seedKey = null;
        let seedValue = null;
        
        if (type === 'map') {
            // Build from form
            const rows = document.querySelectorAll('.seed-key-field-row');
            if (rows.length > 0) {
                seedKey = {};
                rows.forEach(row => {
                    const name = row.getAttribute('data-name') || row.getAttribute('data-field');
                    const valStr = row.querySelector('.seed-key-field-value').value;
                    
                    // Find type definition
                    const typeDefRow = Array.from(document.querySelectorAll('.key-field-row')).find(r => r.querySelector('.key-field-name').value.trim() === name);
                    const fieldType = typeDefRow ? typeDefRow.querySelector('.key-field-type').value : 'string';
                    
                    let val = valStr;
                    if (['int', 'int8', 'int16', 'int32', 'int64', 'uint', 'uint8', 'uint16', 'uint32', 'uint64', 'rune'].includes(fieldType)) {
                        val = parseInt(valStr);
                        if (isNaN(val)) val = 0;
                    } else if (['float32', 'float64', 'decimal'].includes(fieldType)) {
                        val = parseFloat(valStr);
                        if (isNaN(val)) val = 0.0;
                    } else if (['complex64', 'complex128'].includes(fieldType)) {
                        val = valStr;
                    } else if (fieldType === 'bool') {
                        val = (valStr.toLowerCase() === 'true' || valStr === '1');
                    } else if (fieldType === 'timestamp') {
                        let t = parseInt(valStr);
                        if (isNaN(t)) {
                            t = Date.parse(valStr);
                            if (isNaN(t)) t = 0;
                        }
                        val = t;
                    } else if (['date', 'datetime', 'time', 'guid', 'timestampz'].includes(fieldType)) {
                        val = valStr;
                    } else if (fieldType === 'blob') {
                        val = [];
                        for (let i = 0; i < valStr.length; i++) {
                            val.push(valStr.charCodeAt(i));
                        }
                    }
                    seedKey[name] = val;
                });
            }
        } else {
            // Simple Key
            const seedKeyStr = document.getElementById('new-store-seed-key').value.trim();
            if (seedKeyStr) {
                if (['int', 'int8', 'int16', 'int32', 'int64', 'uint', 'uint8', 'uint16', 'uint32', 'uint64', 'rune'].includes(type)) {
                    seedKey = parseInt(seedKeyStr);
                    if (isNaN(seedKey)) seedKey = 0;
                } else if (['float32', 'float64', 'decimal'].includes(type)) {
                    seedKey = parseFloat(seedKeyStr);
                    if (isNaN(seedKey)) seedKey = 0.0;
                } else if (['complex64', 'complex128'].includes(type)) {
                    seedKey = seedKeyStr;
                } else if (type === 'bool') {
                    seedKey = (seedKeyStr.toLowerCase() === 'true' || seedKeyStr === '1');
                } else if (type === 'timestamp') {
                    let t = parseInt(seedKeyStr);
                    if (isNaN(t)) {
                        t = Date.parse(seedKeyStr);
                        if (isNaN(t)) t = 0;
                    }
                    seedKey = t;
                } else if (['date', 'datetime', 'time', 'guid', 'timestampz'].includes(type)) {
                    seedKey = seedKeyStr;
                } else if (type === 'blob') {
                    seedKey = [];
                    for (let i = 0; i < seedKeyStr.length; i++) {
                        seedKey.push(seedKeyStr.charCodeAt(i));
                    }
                } else {
                    // Default string or fallback
                    try {
                        seedKey = JSON.parse(seedKeyStr);
                    } catch {
                        seedKey = seedKeyStr;
                    }
                }
            }
        }

        /*
        if (seedKey === null || (typeof seedKey === 'string' && seedKey === '') || (typeof seedKey === 'object' && Object.keys(seedKey).length === 0)) {
             alert("Initial Item Key is required.");
             return;
        }
        */

        try {
            seedValue = generateSeedValueJSON();
        } catch (e) {
            alert(e.message);
            return;
        }

        const isStreaming = document.getElementById('new-store-is-streaming').checked;
        if (isStreaming) {
            // --- Validation for Streaming/Chunked Data ---
            
            // 1. Validate Key Type
            if (type !== 'map') {
                alert("Streaming stores must use a Map key type.");
                return;
            }

            // 2. Validate Value Type
            const valType = document.getElementById('new-store-value-type').value;
            if (valType !== 'blob') {
                alert("Streaming stores must use 'Blob' (Byte Array) as the value type.");
                return;
            }

            // 3. Validate Key Fields
            const keyRows = document.querySelectorAll('.key-field-row');
            let hasChunkIndex = false;
            let chunkIndexType = '';
            let otherFieldCount = 0;

            keyRows.forEach(row => {
                const name = row.querySelector('.key-field-name').value.trim();
                const fType = row.querySelector('.key-field-type').value;
                if (name === 'ChunkIndex') {
                    hasChunkIndex = true;
                    chunkIndexType = fType;
                } else if (name) {
                    otherFieldCount++;
                }
            });

            if (!hasChunkIndex || chunkIndexType !== 'int') {
                alert("Streaming stores must have a 'ChunkIndex' field of type 'int' in the Key.");
                return;
            }
            if (otherFieldCount < 1) {
                alert("Streaming stores must have at least one other field in the Key (besides ChunkIndex).");
                return;
            }

            // 4. Validate Index Spec
            const indexRows = document.querySelectorAll('.index-field-row');
            if (indexRows.length === 0) {
                alert("Streaming stores must have an Index defined.");
                return;
            }

            const lastIndexRow = indexRows[indexRows.length - 1];
            const lastIndexField = lastIndexRow.querySelector('.index-field-select').value;

            if (lastIndexField !== 'ChunkIndex') {
                alert("For Streaming stores, 'ChunkIndex' must be the LAST field in the Index.");
                return;
            }
            
            // Ensure at least one other field is indexed (ChunkIndex + Other = 2+)
            if (indexRows.length < 2) {
                 alert("Streaming stores must index both the ChunkIndex and the identifier field(s).");
                 return;
            }
        }

        const payload = {
            database: currentDatabase,
            store: name,
            description: desc,
            key_type: type,
            keyIsArray: document.getElementById('new-store-key-is-array').checked,
            value_type: document.getElementById('new-store-value-type').value,
            valueIsArray: document.getElementById('new-store-value-is-array').checked,
            index_spec: indexSpec,
            cel_expression: celExpression,
            slot_length: slotLength,
            is_unique: isUnique,
            data_size: dataSize,
            cache_duration: cacheDuration,
            is_cache_ttl: isCacheTTL,
            seed_key: seedKey,
            seed_value: seedValue,
            adminToken: window.currentAdminToken || ""
        };

        fetch('/api/store/add', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(async res => {
            if (!res.ok) {
                const text = await res.text();
                throw new Error(text || res.statusText);
            }
            return res.json();
        })
        .then(data => {
            if (data.status === 'ok') {
                closeAddStoreModal();
                // Refresh store list and select the new store
                selectDatabase(currentDatabase, true, name);
            } else {
                alert("Error: " + (data.error || "Unknown error"));
            }
        })
        .catch(err => {
            alert("Error: " + err.message);
        });
    }

    // --- CEL Editing Logic ---
    function openCELModal() {
        const modal = document.getElementById('cel-modal');
        const input = document.getElementById('cel-expression-input');
        const helpText = document.getElementById('cel-help-text');
        
        // Check if New Store Modal is open
        const addStoreModal = document.getElementById('add-store-modal');
        const isNewStore = addStoreModal && addStoreModal.style.display === 'flex';

        if (isNewStore) {
            input.value = document.getElementById('cel-expression-value').value;
            
            // Generate Help Content for New Store
            let helpContent = '';
            let generatedExpr = null;
            
            // 1. Try to generate from UI Index Spec
            const indexRows = document.querySelectorAll('.index-field-row');
            if (indexRows.length > 0) {
                const fields = [];
                indexRows.forEach(row => {
                    const field = row.querySelector('.index-field-select').value;
                    const order = row.querySelector('.index-field-order').value;
                    if (field) {
                        fields.push({
                            field_name: field,
                            ascending_sort_order: order === 'asc'
                        });
                    }
                });

                if (fields.length > 0) {
                    // Recursive function to build the ternary chain
                    function buildExpr(index) {
                        if (index >= fields.length) return "0";
                        
                        const f = fields[index];
                        const name = f.field_name;
                        const isAsc = f.ascending_sort_order;
                        
                        const lessVal = isAsc ? "-1" : "1";
                        const greaterVal = isAsc ? "1" : "-1";
                        
                        return `mapX['${name}'] < mapY['${name}'] ? ${lessVal} : mapX['${name}'] > mapY['${name}'] ? ${greaterVal} : (${buildExpr(index + 1)})`;
                    }
                    
                    generatedExpr = buildExpr(0);
                }
            }

            // 2. Generate Help Text based on Key Fields
            const keyRows = document.querySelectorAll('.key-field-row');
            const keyFields = [];
            keyRows.forEach(row => {
                const name = row.querySelector('.key-field-name').value.trim();
                if (name) keyFields.push(name);
            });

            if (keyFields.length > 0) {
                helpContent += `<div style="margin-bottom:5px;"><strong>Available Fields (mapX/mapY):</strong> ${keyFields.map(f => `<code>${f}</code>`).join(', ')}</div>`;
                
                if (generatedExpr) {
                    helpContent += `
                        <div style="margin-bottom:10px;">
                            <strong>Generated from Index Spec:</strong>
                            <div style="font-size: 0.85em; color: var(--text-muted); margin-bottom: 2px;">Equivalent CEL for current index configuration:</div>
                            <code style="display:block; padding:5px; background:var(--input-bg); border:1px solid var(--border-color); margin-top:3px; cursor:pointer; user-select:all; white-space: pre-wrap;" 
                                onclick="document.getElementById('cel-expression-input').value = this.innerText">${generatedExpr}</code>
                        </div>
                        <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 10px 0;">
                    `;
                } else {
                    const fieldName = keyFields[0];
                    const sampleExpr = `mapX['${fieldName}'] < mapY['${fieldName}'] ? -1 : mapX['${fieldName}'] > mapY['${fieldName}'] ? 1 : 0`;
                    
                    helpContent += `
                        <div><strong>Sample Expression (Click to use):</strong></div>
                        <code style="display:block; padding:5px; background:var(--input-bg); border:1px solid var(--border-color); margin-top:3px; cursor:pointer; user-select:all;" 
                              onclick="document.getElementById('cel-expression-input').value = this.innerText">${sampleExpr}</code>
                    `;
                }
            } else {
                 if (!helpContent) {
                     helpContent = '<div>Define Key Fields or Index Spec to see suggestions.</div>';
                 }
            }

            if (helpContent) {
                helpText.innerHTML = helpContent;
                helpText.style.display = 'block';
            } else {
                helpText.style.display = 'none';
            }

            modal.style.display = 'flex';
            return;
        }

        if (!currentStoreInfo) return;

        input.value = currentStoreInfo.celExpression || '';

        let helpContent = '';

        // 1. Generate from Index Spec if available
        if (currentStoreInfo.indexSpec && currentStoreInfo.indexSpec.index_fields && currentStoreInfo.indexSpec.index_fields.length > 0) {
             const fields = currentStoreInfo.indexSpec.index_fields;
             
             // Recursive function to build the ternary chain
             function buildExpr(index) {
                 if (index >= fields.length) return "0";
                 
                 const f = fields[index];
                 const name = f.field_name;
                 const isAsc = f.ascending_sort_order;
                 
                 // Standard: X < Y ? -1 : X > Y ? 1 : Next
                 // Desc:    X < Y ? 1 : X > Y ? -1 : Next
                 
                 const lessVal = isAsc ? "-1" : "1";
                 const greaterVal = isAsc ? "1" : "-1";
                 
                 return `mapX['${name}'] < mapY['${name}'] ? ${lessVal} : mapX['${name}'] > mapY['${name}'] ? ${greaterVal} : (${buildExpr(index + 1)})`;
             }
             
             // Remove outer parens if they exist from recursion (optional cleanup)
             let generatedExpr = buildExpr(0);
             
             helpContent += `
                <div style="margin-bottom:10px;">
                    <strong>Generated from Index Spec:</strong>
                    <div style="font-size: 0.85em; color: var(--text-muted); margin-bottom: 2px;">Equivalent CEL for current index configuration:</div>
                    <code style="display:block; padding:5px; background:var(--input-bg); border:1px solid var(--border-color); margin-top:3px; cursor:pointer; user-select:all; white-space: pre-wrap;" 
                          onclick="document.getElementById('cel-expression-input').value = this.innerText">${generatedExpr}</code>
                </div>
                <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 10px 0;">
             `;
        }

        // 2. Generate Help Text based on sample key
        if (currentStoreInfo.sampleKey && typeof currentStoreInfo.sampleKey === 'object') {
            const fields = Object.keys(currentStoreInfo.sampleKey);
            if (fields.length > 0) {
                const fieldName = fields[0];
                // Sample expression using the first field
                const sampleExpr = `mapX['${fieldName}'] < mapY['${fieldName}'] ? -1 : mapX['${fieldName}'] > mapY['${fieldName}'] ? 1 : 0`;
                
                helpContent += `
                    <div style="margin-bottom:5px;"><strong>Available Fields (mapX/mapY):</strong> ${fields.map(f => `<code>${f}</code>`).join(', ')}</div>
                    <div><strong>Sample Expression (Click to use):</strong></div>
                    <code style="display:block; padding:5px; background:var(--input-bg); border:1px solid var(--border-color); margin-top:3px; cursor:pointer; user-select:all;" 
                          onclick="document.getElementById('cel-expression-input').value = this.innerText">${sampleExpr}</code>
                `;
            }
        } else {
             // If no sample key, maybe show generic help if no index spec either
             if (!helpContent) {
                 helpContent = '<div>No sample data or index specification available to generate suggestions.</div>';
             }
        }

        if (helpContent) {
            helpText.innerHTML = helpContent;
            helpText.style.display = 'block';
        } else {
            helpText.style.display = 'none';
        }

        modal.style.display = 'flex';
    }

    function closeCELModal() {
        document.getElementById('cel-modal').style.display = 'none';
    }

    function saveCELExpression() {
        const input = document.getElementById('cel-expression-input');
        const celExpr = input.value;

        // Check if New Store Modal is open
        const addStoreModal = document.getElementById('add-store-modal');
        const isNewStore = addStoreModal && addStoreModal.style.display === 'flex';

        if (isNewStore) {
            document.getElementById('cel-expression-value').value = celExpr;
            const preview = document.getElementById('cel-expression-preview');
            if (celExpr) {
                preview.textContent = celExpr;
                preview.style.color = 'var(--text-color)';
            } else {
                preview.textContent = "(No expression defined - using default sorting)";
                preview.style.color = 'var(--text-muted)';
            }
            closeCELModal();
            return;
        }

        fetch('/api/store/update', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                database: currentDatabase,
                storeName: currentStore,
                celExpression: celExpr
            })
        })
        .then(async res => {
            if (!res.ok) {
                const text = await res.text();
                if (text.includes("Cannot update") && text.includes("structure")) {
                    const token = prompt("Structural changes detected. Please enter Admin Token to override:");
                    if (token) {
                        return fetch('/api/store/update', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                database: currentDatabase,
                                storeName: currentStore,
                                celExpression: celExpr,
                                adminToken: token
                            })
                        }).then(async res2 => {
                            if (!res2.ok) {
                                const text2 = await res2.text();
                                throw new Error(text2 || res2.statusText);
                            }
                            return res2.json();
                        });
                    }
                }
                throw new Error(text || res.statusText);
            }
            return res.json(); // Expect JSON now
        })
        .then(data => {
            closeCELModal();
            // Refresh store info
            currentStoreInfo.celExpression = celExpr;
            if (data && data.warning) {
                alert('CEL Expression updated successfully.\n\nWARNING: ' + data.warning);
            } else {
                alert('CEL Expression updated successfully.');
            }
        })
        .catch(err => {
            alert("Error updating CEL Expression: " + err);
        });
    }

    window.onbeforeunload = function() {
        const btn = document.getElementById('btn-save');
        if (btn && !btn.disabled) {
            return "You have unsaved changes.";
        }
    };

    // --- Draggable Chat Toggle Button Logic ---
    document.addEventListener('DOMContentLoaded', function() {
        const btn = document.getElementById('chat-toggle-btn');
        let isDraggingBtn = false;
        let hasMoved = false;
        let mouseOffsetX = 0;
        let mouseOffsetY = 0;
        let startX = 0;
        let startY = 0;

        // Prevent context menu on the button
        btn.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });

        btn.addEventListener('mousedown', function(e) {
            // Only Right Click (button 2) for dragging
            if (e.button !== 2) return;
            
            isDraggingBtn = true;
            hasMoved = false;
            startX = e.clientX;
            startY = e.clientY;
            
            // Calculate offset
            const rect = btn.getBoundingClientRect();
            mouseOffsetX = e.clientX - rect.left;
            mouseOffsetY = e.clientY - rect.top;
            
            // Switch to explicit positioning
            btn.style.left = rect.left + 'px';
            btn.style.top = rect.top + 'px';
            btn.style.right = 'auto';
            btn.style.bottom = 'auto';
            
            e.preventDefault(); // Prevent text selection
        });

        document.addEventListener('mousemove', function(e) {
            if (!isDraggingBtn) return;
            
            if (!hasMoved) {
                const dist = Math.sqrt(Math.pow(e.clientX - startX, 2) + Math.pow(e.clientY - startY, 2));
                // Threshold of 5 pixels to distinguish Click vs Drag
                if (dist > 5) {
                    hasMoved = true;
                    document.body.style.cursor = 'move';
                } else {
                    return; // Do not move yet
                }
            }

            // Only move if we have passed the threshold
            btn.style.left = (e.clientX - mouseOffsetX) + 'px';
            btn.style.top = (e.clientY - mouseOffsetY) + 'px';
        });

        document.addEventListener('mouseup', function(e) {
            if (isDraggingBtn) {
                isDraggingBtn = false;
                document.body.style.cursor = 'default';
            }
        });

        // Left Click to Toggle
        btn.addEventListener('click', function(e) {
            toggleChatWidget(true);
        });

        // Global Escape Key Handler for Modals
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                // Args Modal (Check first)
                const argsModal = document.getElementById('args-modal');
                if (argsModal && argsModal.style.display === 'flex') {
                    closeArgsModal();
                    return;
                }

                // CEL Modal (Check first as it can be on top of Add Store)
                const celModal = document.getElementById('cel-modal');
                if (celModal && celModal.style.display === 'flex') {
                    closeCELModal();
                    return;
                }

                // Add Store Modal
                const addStoreModal = document.getElementById('add-store-modal');
                if (addStoreModal && addStoreModal.style.display === 'flex') {
                    closeAddStoreModal();
                    return;
                }

                // Code Modal
                const codeModal = document.getElementById('code-modal');
                if (codeModal && codeModal.style.display === 'flex') {
                    codeModal.style.display = 'none';
                    return;
                }

                // Column Modal
                const colModal = document.getElementById('column-modal');
                if (colModal && colModal.style.display === 'flex') {
                    colModal.style.display = 'none';
                    return;
                }

                // Script Modal
                const scriptModal = document.getElementById('script-modal');
                if (scriptModal && scriptModal.style.display !== 'none') {
                    closeScriptModal();
                    return;
                }
            }
        });
    });

    // Setup Wizard Logic
    let currentWizardStep = 1;

    function toggleSetupConnectionField() {
        const type = document.getElementById('setup-db-type').value;
        const group = document.getElementById('setup-conn-group');
        const input = document.getElementById('setup-db-conn');
        
        if (type === 'redis') {
            group.style.display = 'block';
            input.placeholder = 'localhost:6379';
        } else if (type === 'cassandra') {
            group.style.display = 'block';
            input.placeholder = 'localhost:9042';
        } else {
            group.style.display = 'none';
        }
    }

    function showSetupWizard() {
        document.getElementById('setup-wizard').style.display = 'flex';
        updateWizardStep();
    }

    function updateWizardStep() {
        // Update Steps
        document.querySelectorAll('.wizard-step').forEach(el => el.classList.remove('active'));
        document.getElementById(`step-${currentWizardStep}`).classList.add('active');

        // Update Dots
        for (let i = 1; i <= 3; i++) {
            const dot = document.getElementById(`dot-${i}`);
            dot.classList.remove('active', 'completed');
            if (i === currentWizardStep) dot.classList.add('active');
            if (i < currentWizardStep) dot.classList.add('completed');
        }

        // Update Buttons
        document.getElementById('wizard-prev').style.visibility = currentWizardStep === 1 ? 'hidden' : 'visible';
        const nextBtn = document.getElementById('wizard-next');
        nextBtn.textContent = currentWizardStep === 3 ? 'Finish' : 'Next';

        // Populate Summary on Step 3
        if (currentWizardStep === 3) {
            const regPath = document.getElementById('setup-reg-path').value;
            const port = document.getElementById('setup-port').value;
            const dbName = document.getElementById('setup-db-name').value;
            const dbPath = document.getElementById('setup-db-path').value;
            const dbType = document.getElementById('setup-db-type').value;
            const dbConn = document.getElementById('setup-db-conn').value;
            const populateDemo = document.getElementById('setup-populate-demo').checked;

            let summaryHtml = `
                <strong>System Registry:</strong> ${regPath}<br>
                <strong>Port:</strong> ${port}<br>
                <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 10px 0;">
                <strong>New Database:</strong> ${dbName}<br>
                <strong>Path:</strong> ${dbPath}<br>
                <strong>Type:</strong> ${dbType}<br>
            `;

            if (dbType !== 'filesystem' && dbConn) {
                summaryHtml += `<strong>Connection:</strong> ${dbConn}<br>`;
            }

            summaryHtml += `<strong>Demo Data:</strong> ${populateDemo ? 'Yes' : 'No'}`;
            document.getElementById('setup-summary').innerHTML = summaryHtml;
        }
    }

    function wizardNext() {
        if (currentWizardStep < 3) {
            // Validation
            if (currentWizardStep === 1) {
                const path = document.getElementById('setup-reg-path').value;
                if (!path) return alert("Please enter a registry path");
                // Validate path via API
                fetch('/api/validate-path', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({path: path})
                }).then(res => {
                    if (!res.ok) return alert("Invalid path");
                    currentWizardStep++;
                    updateWizardStep();
                });
                return;
            }
            currentWizardStep++;
            updateWizardStep();
        } else {
            finishSetup();
        }
    }

    function wizardPrev() {
        if (currentWizardStep > 1) {
            currentWizardStep--;
            updateWizardStep();
        }
    }

    function finishSetup() {
        const regPath = document.getElementById('setup-reg-path').value;
        const port = parseInt(document.getElementById('setup-port').value);
        const dbName = document.getElementById('setup-db-name').value;
        const dbPath = document.getElementById('setup-db-path').value;
        const dbType = document.getElementById('setup-db-type').value;
        const dbConn = document.getElementById('setup-db-conn').value;
        const populateDemo = document.getElementById('setup-populate-demo').checked;

        const nextBtn = document.getElementById('wizard-next');
        nextBtn.disabled = true;
        nextBtn.textContent = "Setting up...";

        // 1. Save Config
        fetch('/api/config/save', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                registry_path: regPath,
                port: port
            })
        })
        .then(res => {
            if (!res.ok) throw new Error("Failed to save config");
            
            // 2. Init Database
            return fetch('/api/db/init', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    name: dbName,
                    path: dbPath,
                    type: dbType,
                    connection: dbConn,
                    populate_demo: populateDemo
                })
            });
        })
        .then(res => {
            if (!res.ok) throw new Error("Failed to initialize database");
            
            // 3. Reload
            alert("Setup Complete! Reloading...");
            window.location.reload();
        })
        .catch(err => {
            alert("Error: " + err.message);
            nextBtn.disabled = false;
            nextBtn.textContent = "Finish";
        });
    }

    // --- Preferences Logic ---
    function showPreferences() {
        const modal = document.getElementById('preferences-modal');
        const mobileMode = localStorage.getItem('sop_ui_mobile_mode') || 'app';
        document.getElementById('pref-mobile-mode').value = mobileMode;
        modal.style.display = 'flex';
    }

    function closePreferences() {
        document.getElementById('preferences-modal').style.display = 'none';
    }

    function savePreferences() {
        const mobileMode = document.getElementById('pref-mobile-mode').value;
        localStorage.setItem('sop_ui_mobile_mode', mobileMode);
        closePreferences();
        applyPreferences();
    }

    function applyPreferences() {
        // Default to 'app' (Auto 2) if not set
        const mobileMode = localStorage.getItem('sop_ui_mobile_mode') || 'app';
        const isMobile = window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        let useAI = false;
        let lockAI = false;

        if (mobileMode === 'app') {
            // Auto 2: AI Only on Mobile
            if (isMobile) {
                useAI = true;
                lockAI = true;
            }
        } else if (mobileMode === 'hybrid') {
            // Auto 1: AI Default on Mobile, but can minimize
            if (isMobile) {
                useAI = true;
                lockAI = false;
            }
        } else if (mobileMode === 'desktop') {
            // Desktop Mode: Manual toggle only
            useAI = false;
            lockAI = false;
        }

        const widget = document.getElementById('chat-widget');
        const minimizeBtn = widget.querySelector('.minimize-btn');
        const resetBtn = widget.querySelector('.reset-btn');

        if (useAI) {
            // Auto-open chat if not already open
            if (!widget.classList.contains('active')) {
                toggleChatWidget(true);
            }
        }

        // On Mobile "App Mode", hide window controls to enforce the "App" feel
        if (lockAI && isMobile) {
            if (minimizeBtn) minimizeBtn.style.display = 'none';
            if (resetBtn) resetBtn.style.display = 'none';
        } else {
            if (minimizeBtn) minimizeBtn.style.display = '';
            if (resetBtn) resetBtn.style.display = '';
        }
    }

    // Apply preferences on load
    document.addEventListener('DOMContentLoaded', applyPreferences);
</script>
{{end}}
