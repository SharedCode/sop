<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOP Data Manager</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --sidebar-bg: #f4f4f4;
            --border-color: #ddd;
            --hover-bg: #e0e0e0;
            --active-bg: #007bff;
            --active-text: #ffffff;
            --table-header-bg: #f2f2f2;
            --table-row-even: #f9f9f9;
            --table-row-hover: #e6e6e6;
            --table-row-selected: #cce5ff;
            --pre-bg: #f8f8f8;
            --input-bg: #ffffff;
            --input-border: #ddd;
            --button-bg: #007bff;
            --button-text: #ffffff;
            --button-hover: #0056b3;
            --success-bg: #28a745;
            --danger-bg: #dc3545;
            --key-color: #155724;
            --text-muted: #555;
            --detail-panel-bg: #fff;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #1e1e1e;
                --text-color: #d4d4d4;
                --sidebar-bg: #252526;
                --border-color: #3e3e42;
                --hover-bg: #37373d;
                --active-bg: #007bff;
                --active-text: #ffffff;
                --table-header-bg: #2d2d2d;
                --table-row-even: #252526;
                --table-row-hover: #2a2d2e;
                --table-row-selected: #094771;
                --pre-bg: #1e1e1e;
                --input-bg: #3c3c3c;
                --input-border: #3e3e42;
                --button-bg: #0e639c;
                --button-text: #ffffff;
                --button-hover: #1177bb;
                --success-bg: #4caf50;
                --danger-bg: #f14c4c;
                --key-color: #9cdcfe;
                --text-muted: #aaa;
                --detail-panel-bg: #1e1e1e;
            }
        }

        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; display: flex; height: 100vh; background-color: var(--bg-color); color: var(--text-color); }
        #sidebar { width: 250px; min-width: 150px; max-width: 50%; background: var(--sidebar-bg); border-right: 1px solid var(--border-color); padding: 6px 7px; display: flex; flex-direction: column; flex-shrink: 0; box-sizing: border-box; }
        #resizer { width: 5px; background: var(--border-color); cursor: col-resize; user-select: none; transition: background 0.2s; flex-shrink: 0; }
        #resizer:hover, #resizer.resizing { background: var(--active-bg); }
        #detail-resizer { width: 5px; background: var(--border-color); cursor: col-resize; user-select: none; transition: background 0.2s; flex-shrink: 0; display: none; }
        #detail-resizer:hover, #detail-resizer.resizing { background: var(--active-bg); }
        #main { flex: 1; padding: 6px 7px; overflow-y: auto; display: flex; flex-direction: column; min-width: 0; }
        h1, h2 { margin-top: 0; margin-bottom: 10px; }
        h3 { margin-top: 0; margin-bottom: 10px; }
        ul { list-style: none; padding: 9px 0 0 0; margin: 0; }
        li { padding: 4px 12px; cursor: pointer; border-radius: 4px; margin-bottom: 4px; }
        li:hover { background: var(--hover-bg); }
        li.active { background: var(--active-bg); color: var(--active-text); }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; table-layout: fixed; border: 1px solid var(--border-color); }
        th, td { text-align: left; padding: 6px 12px; border: 1px solid var(--border-color); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        th { position: relative; background-color: var(--table-header-bg); text-transform: capitalize; }
        th.th-key { color: var(--key-color); font-weight: bold; }
        th.th-val { }
        .col-resizer { position: absolute; right: 0; top: 0; bottom: 0; width: 5px; cursor: col-resize; user-select: none; }
        .col-resizer:hover { background: var(--active-bg); }
        tr:nth-child(even) { background-color: var(--table-row-even); }
        tr:hover { background-color: var(--table-row-hover); cursor: pointer; }
        tr.selected-row { background-color: var(--table-row-selected) !important; }
        #detail-panel { width: 400px; border-left: 1px solid var(--border-color); padding: 0; background: var(--detail-panel-bg); display: none; overflow-y: hidden; box-sizing: border-box; flex-shrink: 0; flex-direction: column; }
        pre { background: var(--pre-bg); padding: 10px; border-radius: 4px; overflow-x: auto; color: var(--text-color); font-size: 12px; font-family: Consolas, "Courier New", monospace; }
        .toolbar { display: flex; gap: 10px; margin-bottom: 20px; }
        input[type="text"], textarea { padding: 8px; border: 1px solid var(--input-border); border-radius: 4px; flex: 1; background-color: var(--input-bg); color: var(--text-color); }
        button { padding: 8px 16px; background: var(--button-bg); color: var(--button-text); border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: var(--button-hover); }
        button:disabled { background: var(--border-color); cursor: not-allowed; }
        
        /* Tabs */
        .tabs { display: flex; border-bottom: 1px solid var(--border-color); background: var(--sidebar-bg); }
        .tab { padding: 10px 15px; cursor: pointer; border-right: 1px solid var(--border-color); font-weight: bold; font-size: 13px; color: var(--text-muted); }
        .tab:hover { background: var(--hover-bg); }
        .tab.active { background: var(--detail-panel-bg); color: var(--active-bg); border-bottom: 2px solid var(--active-bg); margin-bottom: -1px; }
        .tab-content { display: none; flex: 1; overflow-y: auto; padding: 10px; }
        .tab-content.active { display: flex; flex-direction: column; }

        /* Chat Interface */
        .chat-widget {
            position: fixed;
            /* Initial position will be set by JS */
            width: 400px;
            height: 500px;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
            flex-direction: column;
            z-index: 1000;
            overflow: hidden;
            min-width: 300px;
            min-height: 300px;
            box-sizing: border-box;
        }
        
        .chat-widget * {
            box-sizing: border-box;
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 12px;
            height: 12px;
            cursor: nwse-resize;
            z-index: 1002;
            background: linear-gradient(135deg, transparent 50%, var(--text-muted) 50%);
            border-bottom-right-radius: 8px;
        }

        .chat-widget.active {
            display: flex;
        }

        .chat-header {
            padding: 10px 15px;
            background: var(--sidebar-bg);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            cursor: move;
            user-select: none;
        }

        .chat-controls button {
            background: none;
            border: none;
            color: var(--text-muted);
            padding: 0 5px;
            font-size: 16px;
            cursor: pointer;
        }

        .chat-controls button:hover {
            color: var(--text-color);
            background: none;
        }

        .chat-toggle-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: var(--active-bg);
            color: white;
            border: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: transform 0.2s;
        }

        .chat-toggle-btn:hover {
            transform: scale(1.05);
            background: var(--button-hover);
        }

        #chat-history { 
            flex: 1; 
            overflow-y: auto; 
            overflow-x: hidden;
            padding: 15px; 
            background: var(--bg-color); 
            scroll-behavior: smooth; 
            display: flex; 
            flex-direction: column; 
        }
        .chat-message { 
            display: block; 
            width: fit-content; 
            margin-bottom: 10px; 
            padding: 10px; 
            border-radius: 4px; 
            max-width: calc(100% - 7px); 
            font-size: 13px; 
            line-height: 1.5; 
            flex-shrink: 0; 
            word-wrap: break-word; 
            overflow-wrap: anywhere; 
        }
        .chat-message.user { background-color: #007bff; color: white; align-self: flex-end; margin-left: auto; text-align: left; border: 1px solid #0056b3; }
        .chat-message.ai { background: var(--pre-bg); color: var(--text-color); align-self: flex-start; margin-right: auto; border: 1px solid var(--border-color); }
        .chat-input-area { display: flex; gap: 5px; flex-shrink: 0; padding: 10px; border-top: 1px solid var(--border-color); background: var(--sidebar-bg); }
        #chat-input { height: 40px; resize: none; }
        #tab-chat { overflow-y: hidden; height: auto; flex: 1; display: flex; flex-direction: column; }

        /* Utility Classes */
        .btn-success { background-color: var(--success-bg) !important; color: white; }
        .btn-danger { background-color: var(--danger-bg) !important; color: white; }
        .error-text { color: var(--danger-bg); }
        .form-label { font-weight: bold; font-size: 12px; color: var(--text-muted); }
        .form-input { padding: 5px; border: 1px solid var(--input-border); border-radius: 3px; background-color: var(--input-bg); color: var(--text-color); }
        .pre-block { margin-top: 5px; background: var(--pre-bg); padding: 5px; color: var(--text-color); }
        
        .option-system {
            color: var(--danger-bg);
            font-weight: bold;
        }
    </style>
</head>
<body>

<div id="sidebar">
    <div style="flex: 1; overflow-y: auto; padding-right: 2px;">
        <div id="database-section" style="display: none; margin-bottom: 12px;">
            <h2 style="margin-bottom: 7px;">Databases</h2>
            <select id="database-select" onchange="selectDatabase(this.value)" style="width: 100%; padding: 5px;">
                <option>Loading...</option>
            </select>
        </div>
        <h2 style="margin-bottom: 2px;">Stores</h2>
        <ul id="store-list" style="margin-bottom: 12px;">
            <li>Select a database...</li>
        </ul>
        
        <hr style="margin: 12px 0; border: 0; border-top: 1px solid var(--border-color);">
        
        <div id="db-options-section" style="display: none;">
            <h3 style="margin-bottom: 7px;">Database Options</h3>
            <div id="db-options-content" style="font-size: 12px; color: var(--text-muted); overflow-x: auto;">
                Loading...
            </div>
        </div>
    </div>
</div>

<div id="resizer"></div>

<div id="main">
    <h1 id="current-store-title">Select a Store</h1>
    
    <div class="toolbar" id="toolbar" style="display:none;">
        <input type="text" id="search-input" placeholder="Search keys...">
        <button onclick="loadItems('search')" title="Search for items in the store based on the key or index fields.">Search</button>
        <button onclick="showAdd()" class="btn-success" title="Add a new item to the store.">Add Item</button>
    </div>

    <div id="pagination-top" style="display:none; margin-bottom: 2px; gap: 10px; justify-content: center;">
        <button onclick="firstPage()" tabindex="0" title="Go to the first page of items.">First</button>
        <button onclick="prevPage()" tabindex="0" title="Go to the previous page of items.">Previous</button>
        <button onclick="nextPage()" tabindex="0" title="Go to the next page of items.">Next</button>
        <button onclick="lastPage()" tabindex="0" title="Go to the last page of items.">Last</button>
    </div>

    <div id="data-grid"></div>
    
    <div id="pagination" style="display:none; margin-top: 10px; gap: 10px; justify-content: center;">
        <button onclick="firstPage()" tabindex="0" title="Go to the first page of items.">First</button>
        <button onclick="prevPage()" tabindex="0" title="Go to the previous page of items.">Previous</button>
        <button onclick="nextPage()" tabindex="0" title="Go to the next page of items.">Next</button>
        <button onclick="lastPage()" tabindex="0" title="Go to the last page of items.">Last</button>
    </div>
</div>

<div id="detail-resizer"></div>

<div id="detail-panel">
    <div class="tabs">
        <div class="tab active" onclick="switchTab('details')" id="tab-btn-details">Item Details</div>
    </div>
    <div id="tab-details" class="tab-content active">
        <div id="json-viewer"></div>
    </div>
</div>

<script>
    let currentDatabase = null;
    let currentStore = null;
    let firstKey = null;
    let lastKey = null;
    let currentStoreInfo = null;
    let currentItemKey = null;
    let currentItems = [];
    let currentKeyColumnWidth = '45%';
    let columnWidths = [];

    // Load Databases on Start
    fetch('/api/databases')
        .then(res => res.json())
        .then(databases => {
            const select = document.getElementById('database-select');
            select.innerHTML = '';
            if (!databases || databases.length === 0) {
                const opt = document.createElement('option');
                opt.textContent = "No databases found";
                select.appendChild(opt);
                return;
            }
            
            // Show database switcher only if we have multiple databases
            if (databases.length > 1) {
                document.getElementById('database-section').style.display = 'block';
            }

            const userDBs = databases.filter(db => !db.is_system);
            const systemDBs = databases.filter(db => db.is_system);

            userDBs.forEach(db => {
                const opt = document.createElement('option');
                opt.value = db.name;
                opt.textContent = db.name + (db.mode === 'clustered' ? ' (Clustered)' : '');
                select.appendChild(opt);
            });

            if (systemDBs.length > 0) {
                if (userDBs.length > 0) {
                    const separator = document.createElement('option');
                    separator.disabled = true;
                    separator.textContent = "──────────";
                    select.appendChild(separator);
                }

                systemDBs.forEach(db => {
                    const opt = document.createElement('option');
                    opt.value = db.name;
                    opt.textContent = "⚠️ " + db.name + " (System)";
                    opt.className = "option-system";
                    // Inline style for better compatibility across browsers/OS
                    opt.style.color = "var(--danger-bg)"; 
                    opt.style.fontWeight = "bold";
                    select.appendChild(opt);
                });
            }

            // Select first user DB by default, or first system DB if no user DBs
            if (userDBs.length > 0) {
                selectDatabase(userDBs[0].name);
            } else if (systemDBs.length > 0) {
                selectDatabase(systemDBs[0].name);
            }
        })
        .catch(err => {
            console.error(err);
            document.getElementById('database-select').innerHTML = '<option>Error loading databases</option>';
        });

    function selectDatabase(name) {
        if (currentDatabase === name) return;

        // Check for unsaved changes
        if (!closeDetail()) {
            // Revert selection
            const select = document.getElementById('database-select');
            if (select && currentDatabase) {
                select.value = currentDatabase;
            }
            return;
        }

        currentDatabase = name;
        currentStore = null;
        document.getElementById('store-list').innerHTML = '<li>Loading...</li>';
        document.getElementById('current-store-title').textContent = 'Select a Store';
        document.getElementById('data-grid').innerHTML = '';
        document.getElementById('toolbar').style.display = 'none';
        document.getElementById('pagination').style.display = 'none';
        document.getElementById('pagination-top').style.display = 'none';
        
        // Reset DB Options
        document.getElementById('db-options-section').style.display = 'none';
        document.getElementById('db-options-content').innerHTML = 'Loading...';
        
        fetch(`/api/stores?database=${encodeURIComponent(name)}`)
            .then(res => res.json())
            .then(stores => {
                const list = document.getElementById('store-list');
                list.innerHTML = '';
                if (!stores || stores.length === 0) {
                    list.innerHTML = '<li>No stores found</li>';
                    return;
                }
                stores.forEach(store => {
                    const li = document.createElement('li');
                    li.textContent = store.charAt(0).toUpperCase() + store.slice(1);
                    li.onclick = () => selectStore(store, li);
                    list.appendChild(li);
                });
            })
            .catch(err => {
                const list = document.getElementById('store-list');
                list.innerHTML = `<li class="error-text">Error: ${err.message}</li>`;
            });

        // Fetch DB Options
        fetch(`/api/db/options?database=${encodeURIComponent(name)}`)
            .then(res => res.json())
            .then(opts => {
                const section = document.getElementById('db-options-section');
                const content = document.getElementById('db-options-content');
                section.style.display = 'block';
                
                let html = '';
                
                // Display Mode (Type)
                // L2CacheType: 2=Redis (Clustered), others (0=NoCache, 1=InMemory) = Standalone
                const typeStr = (opts.cache_type === 2) ? "Clustered" : "Standalone";
                html += `<div style="margin-bottom: 5px;"><strong>Type:</strong> ${typeStr}</div>`;

                if (opts.stores_folders && opts.stores_folders.length > 0) {
                    html += '<strong>Stores Folders:</strong><ul style="margin: 5px 0; padding-left: 20px; list-style-type: disc;">';
                    opts.stores_folders.forEach(f => {
                        html += `<li style="cursor: default; padding: 2px 0;">${f}</li>`;
                    });
                    html += '</ul>';
                }
                
                if (opts.erasure_config && Object.keys(opts.erasure_config).length > 0) {
                    html += '<details><summary style="cursor: pointer; font-weight: bold; margin-bottom: 5px;">Erasure Config</summary><pre style="margin: 0; font-size: 10px; overflow-x: visible;">' + JSON.stringify(opts.erasure_config, null, 2) + '</pre></details>';
                }

                if (opts.redis_config) {
                    html += '<details><summary style="cursor: pointer; font-weight: bold; margin-bottom: 5px;">Redis Config</summary><pre style="margin: 0; font-size: 10px; overflow-x: visible;">' + JSON.stringify(opts.redis_config, null, 2) + '</pre></details>';
                }
                
                if (!html) {
                    html = 'No specific options found.';
                }
                content.innerHTML = html;
            })
            .catch(err => {
                console.error("Failed to fetch DB options", err);
                document.getElementById('db-options-content').innerHTML = '<span class="error-text">Failed to load options</span>';
                document.getElementById('db-options-section').style.display = 'block';
            });
    }

    function selectStore(name, element) {
        if (currentStore === name) return;

        // Close detail panel as it may be showing data from previous store
        if (!closeDetail()) return;

        currentStore = name;
        columnWidths = []; // Reset column widths
        
        // Highlight active
        document.querySelectorAll('#sidebar li').forEach(el => el.classList.remove('active'));
        element.classList.add('active');

        // Fetch Store Info
        fetch(`/api/store/info?database=${encodeURIComponent(currentDatabase)}&name=${encodeURIComponent(name)}`)
            .then(res => res.json())
            .then(info => {
                currentStoreInfo = info;
                // Use description if available, otherwise name
                let displayTitle = info.description ? info.description : info.name;
                if (!info.description && displayTitle) {
                    displayTitle = displayTitle.charAt(0).toUpperCase() + displayTitle.slice(1);
                }
                document.getElementById('current-store-title').textContent = displayTitle;

                buildSearchUI(info);
                loadItems('first');
            });
    }

    function buildSearchUI(info) {
        const toolbar = document.getElementById('toolbar');
        toolbar.innerHTML = ''; // Clear existing
        toolbar.style.display = 'flex';
        toolbar.style.flexWrap = 'wrap';

        // Helper to trigger search
        const triggerSearch = () => {
            loadItems('search').then(items => {
                if (items && items.length > 0) {
                    const firstRow = document.querySelector('#items-table tbody tr');
                    if (firstRow) {
                        showDetail(firstRow, items[0], false);
                        firstRow.scrollIntoView({ block: 'nearest' });
                    }
                }
            });
        };

        if (info.indexSpec && info.indexSpec.index_fields) {
            // Complex Key with Index Spec
            info.indexSpec.index_fields.forEach(field => {
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `search-field-${field.field_name}`;
                input.placeholder = `${field.field_name} (${field.ascending_sort_order ? 'Asc' : 'Desc'})`;
                input.style.marginRight = '5px';
                input.style.flex = '1 1 150px'; // Allow wrapping
                input.tabIndex = 0;
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') triggerSearch();
                });
                toolbar.appendChild(input);
            });
        } else if (info.sampleKey && typeof info.sampleKey === 'object' && info.sampleKey !== null) {
            // Inferred Complex Key from Sample
            // Sort keys to be deterministic
            const keys = Object.keys(info.sampleKey).sort();
            keys.forEach(key => {
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `search-field-${key}`;
                input.placeholder = key;
                input.style.marginRight = '5px';
                input.style.flex = '1 1 150px'; // Allow wrapping
                input.tabIndex = 0;
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') triggerSearch();
                });
                toolbar.appendChild(input);
            });
        } else {
            // Primitive Key or no spec
            const input = document.createElement('input');
            input.type = 'text';
            input.id = 'search-input';
            input.placeholder = 'Search keys...';
            input.style.flex = '1';
            input.tabIndex = 0;
            toolbar.appendChild(input);
        }

        const btn = document.createElement('button');
        btn.textContent = 'Search';
        btn.title = "Search for items in the store based on the key or index fields.";
        btn.onclick = triggerSearch;
        btn.tabIndex = 0;
        toolbar.appendChild(btn);

        // Add Enter key support for simple search input
        const simpleInput = document.getElementById('search-input');
        if (simpleInput) {
            simpleInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') btn.click();
            });
        }

        const refreshBtn = document.createElement('button');
        refreshBtn.textContent = 'Refresh';
        refreshBtn.title = "Refreshes the selected store's currently displayed data. Useful when wanting to fetch latest data from the database";
        refreshBtn.onclick = () => loadItems('current', firstKey);
        refreshBtn.style.marginLeft = '10px';
        refreshBtn.tabIndex = 0;
        toolbar.appendChild(refreshBtn);

        // Only show Add Item for non-registry stores (Macros are too complex to add manually)
        if (info.description !== "AI Models Registry") {
            const addBtn = document.createElement('button');
            addBtn.textContent = 'Add Item';
            addBtn.title = "Add a new item to the store.";
            addBtn.onclick = () => showAdd();
            addBtn.classList.add('btn-success');
            addBtn.style.marginLeft = '10px';
            addBtn.tabIndex = 0;
            toolbar.appendChild(addBtn);
        }
    }

    function loadItems(action = 'first', refKey = null, keepPanel = false) {
        if (!currentStore || !currentDatabase) return;

        const btn = document.getElementById('btn-save');
        if (btn && !btn.disabled) {
             if (!confirm("You have unsaved changes. Loading new items will discard them. Continue?")) {
                 return Promise.reject("Cancelled by user");
             }
             // User confirmed discard. Force close to reset state.
             closeDetail(true);
             keepPanel = false;
        }

        // Check if panel is open to preserve it
        const panel = document.getElementById('detail-panel');
        const wasOpen = (panel.style.display === 'block' || panel.style.display === 'flex');
        
        // If keepPanel is explicitly true (e.g. from saveItem), we respect it.
        // Otherwise, we default to closing it UNLESS it was already open (for navigation).
        // However, for pagination (action != 'current'), we might want to keep it open 
        // but we can't show the "same" item. 
        // The user request is: "on Page navigation... it should not auto close so user can compare item details with preview of another record on the grid."
        // This implies the detail pane should stay open showing the *old* item until the user selects a *new* one.
        
        // So we should NOT closeDetail() here if wasOpen is true.
        // But we need to make sure we don't have a stale "selected-row" highlight that points to a row that no longer exists.
        
        // if (!keepPanel) {
        //    closeDetail(true);
        // }
        
        let url = `/api/store/items?database=${encodeURIComponent(currentDatabase)}&name=${encodeURIComponent(currentStore)}&_=${new Date().getTime()}`;
        
        if (action === 'search') {
             let query = "";
             if (currentStoreInfo && currentStoreInfo.indexSpec && currentStoreInfo.indexSpec.index_fields) {
                 // Construct JSON object from fields
                 const queryObj = {};
                 let hasValue = false;
                 currentStoreInfo.indexSpec.index_fields.forEach(field => {
                     const val = document.getElementById(`search-field-${field.field_name}`).value;
                     if (val) {
                         // Try to parse number if possible, else string
                         const numVal = Number(val);
                         queryObj[field.field_name] = isNaN(numVal) ? val : numVal;
                         hasValue = true;
                     }
                 });
                 if (hasValue) {
                     query = JSON.stringify(queryObj);
                 }
             } else if (currentStoreInfo && currentStoreInfo.sampleKey && typeof currentStoreInfo.sampleKey === 'object') {
                 // Construct JSON object from inferred fields
                 const queryObj = {};
                 let hasValue = false;
                 const keys = Object.keys(currentStoreInfo.sampleKey).sort();
                 keys.forEach(key => {
                     const el = document.getElementById(`search-field-${key}`);
                     if (el) {
                         const val = el.value;
                         if (val) {
                             // Try to parse number if possible, else string
                             const numVal = Number(val);
                             queryObj[key] = isNaN(numVal) ? val : numVal;
                             hasValue = true;
                         }
                     }
                 });
                 if (hasValue) {
                     query = JSON.stringify(queryObj);
                 }
             } else {
                 query = document.getElementById('search-input').value;
             }
             
             if (query) {
                url += `&q=${encodeURIComponent(query)}`;
             } else {
                 // If search is empty, treat as first
                 action = 'first';
                 url += `&action=${action}`;
             }
        } else {
             url += `&action=${action}`;
             if (refKey) {
                 const keyStr = typeof refKey === 'object' ? JSON.stringify(refKey) : refKey;
                 url += `&key=${encodeURIComponent(keyStr)}`;
             }
        }

        return fetch(url)
            .then(res => res.json())
            .then(items => {
                // Save current column widths before rebuilding
                const existingTable = document.getElementById('items-table');
                if (existingTable) {
                    const ths = existingTable.querySelectorAll('th');
                    if (ths.length > 0) {
                        columnWidths = Array.from(ths).map(th => th.style.width);
                    }
                }

                const grid = document.getElementById('data-grid');
                const pagination = document.getElementById('pagination');
                const paginationTop = document.getElementById('pagination-top');
                
                if (!items || items.length === 0) {
                    if (action === 'next') {
                        return items;
                    }
                    currentItems = [];
                    grid.innerHTML = '<p>No items found. <button onclick="loadItems(\'first\')" title="Go to the first page of items.">Go to First</button></p>';
                    pagination.style.display = 'none';
                    paginationTop.style.display = 'none';
                    firstKey = null;
                    lastKey = null;
                    return items;
                }

                currentItems = items;

                // Update keys
                firstKey = items[0].key;
                lastKey = items[items.length - 1].key;
                
                // Show pagination
                pagination.style.display = 'flex';
                paginationTop.style.display = 'flex';

                // --- DYNAMIC TABLE GENERATION ---
                let keyCols = [];
                let valCols = [];
                
                // Determine Key Columns
                if (currentStoreInfo && currentStoreInfo.indexSpec && currentStoreInfo.indexSpec.index_fields) {
                    // Priority 1: Use Index Spec for order
                    keyCols = currentStoreInfo.indexSpec.index_fields.map(f => f.field_name);
                    
                    // If we have data, append any extra fields not in index spec
                    if (items.length > 0) {
                        const sampleKey = items[0].key;
                        if (typeof sampleKey === 'object' && sampleKey !== null) {
                            const dataKeys = Object.keys(sampleKey);
                            dataKeys.forEach(k => {
                                if (!keyCols.includes(k)) {
                                    keyCols.push(k);
                                }
                            });
                        }
                    }
                } else if (items.length > 0) {
                    // Priority 2: Infer from data
                    const sampleKey = items[0].key;
                    if (typeof sampleKey === 'object' && sampleKey !== null) {
                        keyCols = Object.keys(sampleKey).sort();
                    }
                    
                    // Fallback: check if it's a JSON string
                    if ((!keyCols || keyCols.length === 0) && typeof sampleKey === 'string' && sampleKey.trim().startsWith('{')) {
                        try {
                            const parsed = JSON.parse(sampleKey);
                            if (typeof parsed === 'object' && parsed !== null) {
                                keyCols = Object.keys(parsed).sort();
                            }
                        } catch(e) {}
                    }

                    if (!keyCols || keyCols.length === 0) {
                        keyCols = ['Key'];
                    }
                } else {
                    // Fallback
                    keyCols = ['Key'];
                }

                // Determine Value Columns
                if (items.length > 0) {
                    const sampleVal = items[0].value;
                    if (typeof sampleVal === 'object' && sampleVal !== null) {
                        valCols = Object.keys(sampleVal);
                    } else {
                        valCols = ['Value'];
                    }
                } else {
                    valCols = ['Value'];
                }

                let html = '<table id="items-table"><thead><tr>';
                
                // Key Headers
                keyCols.forEach((col, index) => {
                     let style = '';
                     if (columnWidths[index]) style = `style="width: ${columnWidths[index]}"`;
                     html += `<th class="th-key" ${style}>${col} <div class="col-resizer" onmousedown="initColResize(event)"></div></th>`;
                });
                
                // Value Headers
                let valOffset = keyCols.length;
                valCols.forEach((col, index) => {
                     let style = '';
                     if (columnWidths[valOffset + index]) style = `style="width: ${columnWidths[valOffset + index]}"`;
                     html += `<th class="th-val" ${style}>${col} <div class="col-resizer" onmousedown="initColResize(event)"></div></th>`;
                });
                
                html += '</tr></thead><tbody>';
                
                items.forEach(item => {
                    // Escape single quotes for the onclick attribute
                    const itemJson = JSON.stringify(item).replace(/'/g, "&#39;");
                    html += `<tr onclick='showDetail(this, ${itemJson})'>`;
                    
                    // Key Cells
                    if (keyCols.length === 1 && keyCols[0] === 'Key') {
                         const val = typeof item.key === 'object' ? JSON.stringify(item.key) : item.key;
                         html += `<td title="${String(val).replace(/"/g, '&quot;')}">${val}</td>`;
                    } else {
                        keyCols.forEach(col => {
                            let keyObj = item.key;
                            if (typeof keyObj === 'string' && keyObj.trim().startsWith('{')) {
                                try { keyObj = JSON.parse(keyObj); } catch(e){}
                            }
                            
                            let val = (keyObj && typeof keyObj === 'object') ? keyObj[col] : '';
                            if (typeof val === 'object') val = JSON.stringify(val);
                            html += `<td title="${String(val).replace(/"/g, '&quot;')}">${val}</td>`;
                        });
                    }
                    
                    // Value Cells
                    if (valCols.length === 1 && valCols[0] === 'Value') {
                         const val = typeof item.value === 'object' ? JSON.stringify(item.value) : item.value;
                         html += `<td title="${String(val).replace(/"/g, '&quot;')}">${val}</td>`;
                    } else {
                        valCols.forEach(col => {
                            let val = item.value ? item.value[col] : '';
                            if (typeof val === 'object') val = JSON.stringify(val);
                            html += `<td title="${String(val).replace(/"/g, '&quot;')}">${val}</td>`;
                        });
                    }
                    
                    html += '</tr>';
                });
                html += '</tbody></table>';
                grid.innerHTML = html;
                return items;
            });
    }

    function firstPage() { loadItems('first'); }
    function lastPage() { loadItems('last'); }
    function nextPage() { loadItems('next', lastKey); }
    function prevPage() { loadItems('prev', firstKey); }

    let currentItemValue = null;

    function showDetail(row, item, autoOpen = true) {
        // Check for unsaved changes if panel is open
        const panel = document.getElementById('detail-panel');
        const wasOpen = (panel.style.display === 'block' || panel.style.display === 'flex');

        if (wasOpen) {
             const btn = document.getElementById('btn-save');
             if (btn && !btn.disabled) {
                 if (!confirm("You have unsaved changes. Are you sure you want to discard them?")) {
                     return;
                 }
             }
        }

        // Highlight selected row
        if (row) {
            document.querySelectorAll('#items-table tr').forEach(tr => tr.classList.remove('selected-row'));
            row.classList.add('selected-row');
        }

        currentItemKey = item.key;
        currentItemValue = item.value;
        
        // If panel was closed and autoOpen is false, just return (after setting currentItemKey and highlight)
        if (!wasOpen && !autoOpen) {
            return;
        }

        const viewer = document.getElementById('json-viewer');
        
        const keyStr = typeof item.key === 'object' ? JSON.stringify(item.key, null, 2) : item.key;
        
        let valueHtml = '';
        if (typeof item.value === 'object' && item.value !== null) {
            // Form View
            valueHtml = '<div id="value-form" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; padding-right: 2px;">';
            const keys = Object.keys(item.value);
            if (keys.length === 0) {
                 valueHtml += '<em>Empty Object</em>';
            }
            keys.forEach(key => {
                let val = item.value[key];
                let displayVal = val;
                if (typeof val === 'object') {
                    displayVal = JSON.stringify(val);
                }
                // Escape quotes for attribute
                const safeVal = String(displayVal).replace(/"/g, '&quot;');
                
                valueHtml += `
                    <div class="form-group" style="display: flex; flex-direction: column;">
                        <label class="form-label">${key}</label>
                        <input type="text" class="value-input form-input" data-key="${key}" value="${safeVal}" 
                            oninput="document.getElementById('btn-save').disabled = false;">
                    </div>
                `;
            });
            valueHtml += '</div>';
        } else {
            // Primitive View (Textarea)
            const valStr = JSON.stringify(item.value, null, 2);
            valueHtml = `<textarea id="edit-value" oninput="document.getElementById('btn-save').disabled = false;" style="width: 100%; height: 300px; font-family: monospace; margin-top: 5px;" class="form-input">${valStr}</textarea>`;
        }

        viewer.innerHTML = `
            <div style="margin-bottom: 10px;">
                <strong>Key:</strong>
                <pre class="pre-block">${keyStr}</pre>
            </div>
            <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                <strong>Value:</strong>
                <button onclick="closeDetail()" style="padding: 2px 8px; font-size: 12px;" title="Close the item details panel.">Close</button>
            </div>
            <div style="margin-bottom: 10px;">
                ${valueHtml}
            </div>
            <div style="display: flex; gap: 10px;">
                <button id="btn-save" onclick="saveItem()" disabled title="Save changes to the item.">Save</button>
                <button onclick="deleteItem()" class="btn-danger" title="Delete this item from the store.">Delete</button>
            </div>
        `;
        document.getElementById('detail-resizer').style.display = 'block';
        panel.style.display = 'flex';
    }

    function saveItem() {
        if (!currentStore || currentItemKey === null) return;

        let newVal;
        const form = document.getElementById('value-form');
        
        if (form) {
            // Reconstruct object from form
            newVal = Array.isArray(currentItemValue) ? [] : {};
            const inputs = form.querySelectorAll('.value-input');
            
            inputs.forEach(input => {
                const key = input.getAttribute('data-key');
                const rawVal = input.value;
                const originalVal = currentItemValue[key];
                
                // Type conversion
                let finalVal = rawVal;
                if (typeof originalVal === 'number') {
                    finalVal = Number(rawVal);
                } else if (typeof originalVal === 'boolean') {
                    finalVal = (rawVal.toLowerCase() === 'true');
                } else if (typeof originalVal === 'object' && originalVal !== null) {
                    try {
                        finalVal = JSON.parse(rawVal);
                    } catch {
                        // Fallback to string if parse fails
                        finalVal = rawVal;
                    }
                }
                
                newVal[key] = finalVal;
            });
        } else {
            const valText = document.getElementById('edit-value').value;
            try {
                newVal = JSON.parse(valText);
            } catch (e) {
                alert("Invalid JSON in Value field");
                return;
            }
        }

        const payload = {
            database: currentDatabase,
            store: currentStore,
            key: currentItemKey,
            value: newVal
        };

        const btn = document.getElementById('btn-save');
        const originalText = btn.textContent;
        btn.textContent = "Saving...";
        btn.disabled = true;

        fetch('/api/store/item/update', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(res => {
            if (!res.ok) return res.text().then(t => { throw new Error(t) });
            return res.json();
        })
        .then(() => {
            // Success: Keep button disabled (greyed out) to indicate saved state
            btn.textContent = "Save";
            btn.disabled = true;
            
            // Update local state so subsequent edits work correctly
            currentItemValue = newVal;

            // Refresh the grid in background to show updated values
            return loadItems('current', firstKey, true).then(newItems => {
                // Re-highlight the saved item
                if (newItems && newItems.length > 0) {
                    const savedKeyStr = JSON.stringify(currentItemKey);
                    const targetIndex = newItems.findIndex(item => JSON.stringify(item.key) === savedKeyStr);
                    
                    if (targetIndex >= 0) {
                        const rows = document.querySelectorAll('#items-table tbody tr');
                        if (rows && rows[targetIndex]) {
                            // Just highlight, don't re-open detail as it's already open
                            document.querySelectorAll('#items-table tr').forEach(tr => tr.classList.remove('selected-row'));
                            rows[targetIndex].classList.add('selected-row');
                        }
                    }
                }
            });
        })
        .catch(err => {
            const msg = "Update failed: " + err.message + "\n\n" +
                        "Another user may have modified this record (Swarm conflict).\n" +
                        "Please refresh the data to see the latest changes.";
            alert(msg);
            btn.textContent = "Save";
            btn.disabled = false; // Re-enable so user can try again
        });
    }

    function deleteItem() {
        if (!currentStore || currentItemKey === null) return;
        showConfirm("Are you sure you want to delete this item?", () => {
            performDelete();
        });
    }

    function performDelete() {
        const payload = {
            database: currentDatabase,
            store: currentStore,
            key: currentItemKey
        };

        fetch('/api/store/item/delete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(res => {
            if (!res.ok) return res.text().then(t => { throw new Error(t) });
            return res.json();
        })
        .then(() => {
            // Find index of deleted item to determine next selection
            let targetIndex = -1;
            if (currentItems && currentItems.length > 0) {
                // We need to compare keys carefully (objects vs primitives)
                const deletedKeyStr = JSON.stringify(currentItemKey);
                targetIndex = currentItems.findIndex(item => JSON.stringify(item.key) === deletedKeyStr);
            }

            loadItems('current', firstKey).then(newItems => {
                if (!newItems || newItems.length === 0) {
                    closeDetail();
                    return;
                }
                
                // Try to select item at same index, or last item if index out of bounds
                if (targetIndex >= 0) {
                    if (targetIndex >= newItems.length) {
                        targetIndex = newItems.length - 1;
                    }
                    // We need to find the row element to pass to showDetail for highlighting
                    // Since we just reloaded, we can find it by index in the table
                    const rows = document.querySelectorAll('#items-table tbody tr');
                    if (rows && rows[targetIndex]) {
                        showDetail(rows[targetIndex], newItems[targetIndex], false);
                    } else {
                        showDetail(null, newItems[targetIndex], false);
                    }
                } else {
                    // Fallback to first item if we couldn't track index
                    const rows = document.querySelectorAll('#items-table tbody tr');
                    if (rows && rows[0]) {
                        showDetail(rows[0], newItems[0], false);
                    } else {
                        showDetail(null, newItems[0], false);
                    }
                }
            });
        })
        .catch(err => {
            alert("Delete failed: " + err.message);
        });
    }

    let currentConfirmHandler = null;

    function closeConfirmModal() {
        document.getElementById('confirm-modal').style.display = 'none';
        if (currentConfirmHandler) {
            document.removeEventListener('keydown', currentConfirmHandler, true);
            currentConfirmHandler = null;
        }
    }

    function showConfirm(message, onConfirm) {
        const modal = document.getElementById('confirm-modal');
        const msgEl = document.getElementById('confirm-message');
        const okBtn = document.getElementById('confirm-ok');
        const cancelBtn = document.getElementById('confirm-cancel');

        msgEl.textContent = message;
        modal.style.display = 'flex';

        // Setup click handlers
        okBtn.onclick = () => {
            closeConfirmModal();
            onConfirm();
        };
        cancelBtn.onclick = () => {
            closeConfirmModal();
        };

        // Remove existing handler if any (safety)
        if (currentConfirmHandler) {
            document.removeEventListener('keydown', currentConfirmHandler, true);
        }

        // Define new handler
        currentConfirmHandler = function(e) {
            const isTab = e.key === 'Tab';
            const isEscape = e.key === 'Escape';
            const isLeft = e.key === 'ArrowLeft';
            const isRight = e.key === 'ArrowRight';
            const isEnter = e.key === 'Enter';

            if (isEscape) {
                e.preventDefault();
                e.stopImmediatePropagation();
                closeConfirmModal();
                return;
            }

            if (isTab || isLeft || isRight) {
                e.preventDefault();
                e.stopImmediatePropagation();
                
                const activeEl = document.activeElement;
                
                // Toggle logic:
                // If on Cancel -> Go to OK
                // If on OK -> Go to Cancel
                // If anywhere else -> Go to Cancel (Safe default)
                if (activeEl === cancelBtn) {
                    okBtn.focus();
                } else {
                    cancelBtn.focus();
                }
            }
            
            if (isEnter) {
                e.preventDefault();
                e.stopImmediatePropagation();
                // Trigger click on the focused element if it's one of our buttons
                if (document.activeElement === okBtn || document.activeElement === cancelBtn) {
                    document.activeElement.click();
                }
            }
        };

        // Add key handler
        document.addEventListener('keydown', currentConfirmHandler, true);

        // Force focus to Cancel button
        requestAnimationFrame(() => {
            cancelBtn.focus();
        });
    }

    function showAdd() {
        const modal = document.getElementById('add-modal');
        const keyContainer = document.getElementById('add-key-container');
        const valContainer = document.getElementById('add-value-container');
        const keyModeToggle = document.getElementById('add-key-mode-toggle');
        const valModeToggle = document.getElementById('add-value-mode-toggle');
        
        keyContainer.innerHTML = '';
        valContainer.innerHTML = '';
        keyModeToggle.checked = false;
        valModeToggle.checked = false;

        // --- Build Key UI ---
        let keySchema = [];
        // 1. Infer from data first (most accurate for full struct)
        if (currentItems && currentItems.length > 0 && typeof currentItems[0].key === 'object' && currentItems[0].key !== null) {
            keySchema = Object.keys(currentItems[0].key);
        } 
        // 2. Fallback to IndexSpec
        else if (currentStoreInfo && currentStoreInfo.indexSpec && currentStoreInfo.indexSpec.index_fields) {
            keySchema = currentStoreInfo.indexSpec.index_fields.map(f => f.field_name);
        }
        // 3. Fallback to Sample Key
        else if (currentStoreInfo && currentStoreInfo.sampleKey && typeof currentStoreInfo.sampleKey === 'object') {
            keySchema = Object.keys(currentStoreInfo.sampleKey).sort();
        }

        if (keySchema.length > 0) {
            // Complex Key Form
            keySchema.forEach(fieldName => {
                const div = document.createElement('div');
                div.style.marginBottom = '5px';
                div.innerHTML = `
                    <label style="display:block; font-size:12px; font-weight:bold;">${fieldName}</label>
                    <input type="text" class="add-key-field" data-name="${fieldName}" style="width:100%; padding:5px; border:1px solid var(--input-border); border-radius:3px; background: var(--input-bg); color: var(--text-color); box-sizing: border-box;">
                `;
                keyContainer.appendChild(div);
            });
        } else {
            // Simple Key or Unknown Schema -> JSON Mode
            keyModeToggle.checked = true;
            renderAddKeyJson();
        }

        // --- Build Value UI ---
        // Try to infer schema from first item
        let useForm = false;
        if (currentItems && currentItems.length > 0) {
            const sampleVal = currentItems[0].value;
            if (typeof sampleVal === 'object' && sampleVal !== null) {
                useForm = true;
                const keys = Object.keys(sampleVal);
                keys.forEach(k => {
                    const div = document.createElement('div');
                    div.style.marginBottom = '5px';
                    div.innerHTML = `
                        <label style="display:block; font-size:12px; font-weight:bold;">${k}</label>
                        <input type="text" class="add-value-field" data-name="${k}" style="width:100%; padding:5px; border:1px solid var(--input-border); border-radius:3px; background: var(--input-bg); color: var(--text-color); box-sizing: border-box;">
                    `;
                    valContainer.appendChild(div);
                });
            }
        }

        if (!useForm) {
            // Fallback to JSON
            valModeToggle.checked = true;
            renderAddValueJson();
        }

        // Reset position to center
        const modalContent = document.getElementById('add-modal-content');
        if (modalContent) {
            modalContent.style.top = '50%';
            modalContent.style.left = '50%';
            modalContent.style.transform = 'translate(-50%, -50%)';
            modalContent.style.margin = '0';
        }

        modal.style.display = 'block';
    }

    function toggleAddKeyMode() {
        const isJson = document.getElementById('add-key-mode-toggle').checked;
        const container = document.getElementById('add-key-container');
        
        if (isJson) {
            // Switch to JSON
            let currentObj = {};
            const inputs = container.querySelectorAll('.add-key-field');
            if (inputs.length > 0) {
                inputs.forEach(inp => {
                    const k = inp.getAttribute('data-name');
                    currentObj[k] = parseInputVal(inp.value);
                });
                renderAddKeyJson(JSON.stringify(currentObj, null, 2));
            } else {
                renderAddKeyJson();
            }
        } else {
            // Switch to Form
            const textarea = document.getElementById('add-key-json');
            let obj = {};
            if (textarea) {
                try {
                    obj = JSON.parse(textarea.value);
                } catch {
                    alert("Invalid JSON or Primitive value, cannot switch to Form view.");
                    document.getElementById('add-key-mode-toggle').checked = true;
                    return;
                }
            }
            
            if (typeof obj === 'object' && obj !== null) {
                container.innerHTML = '';
                Object.keys(obj).forEach(k => {
                    const div = document.createElement('div');
                    div.style.marginBottom = '5px';
                    div.innerHTML = `
                        <label style="display:block; font-size:12px; font-weight:bold;">${k}</label>
                        <input type="text" class="add-key-field" data-name="${k}" value="${String(obj[k]).replace(/"/g, '&quot;')}" style="width:100%; padding:5px; border:1px solid var(--input-border); border-radius:3px; background: var(--input-bg); color: var(--text-color); box-sizing: border-box;">
                    `;
                    container.appendChild(div);
                });
            } else {
                alert("Value is not an object, cannot use Form view.");
                document.getElementById('add-key-mode-toggle').checked = true;
            }
        }
    }

    function renderAddKeyJson(content = '') {
        const container = document.getElementById('add-key-container');
        container.innerHTML = `<textarea id="add-key-json" placeholder="Key (JSON or String)" style="width:100%; height:60px; padding:5px; font-family:monospace; border:1px solid var(--input-border); border-radius:3px; background: var(--input-bg); color: var(--text-color); box-sizing: border-box;">${content}</textarea>`;
    }

    function toggleAddValueMode() {
        const isJson = document.getElementById('add-value-mode-toggle').checked;
        const container = document.getElementById('add-value-container');
        
        if (isJson) {
            // Switch to JSON
            // Try to harvest current values from form if they exist
            let currentObj = {};
            const inputs = container.querySelectorAll('.add-value-field');
            if (inputs.length > 0) {
                inputs.forEach(inp => {
                    const k = inp.getAttribute('data-name');
                    currentObj[k] = parseInputVal(inp.value);
                });
                renderAddValueJson(JSON.stringify(currentObj, null, 2));
            } else {
                renderAddValueJson();
            }
        } else {
            // Switch to Form
            // Try to parse JSON
            const textarea = document.getElementById('add-value-json');
            let obj = {};
            if (textarea) {
                try {
                    obj = JSON.parse(textarea.value);
                } catch {
                    alert("Invalid JSON, cannot switch to Form view.");
                    document.getElementById('add-value-mode-toggle').checked = true;
                    return;
                }
            }
            
            // Render Form
            container.innerHTML = '';
            if (typeof obj === 'object' && obj !== null) {
                Object.keys(obj).forEach(k => {
                    const div = document.createElement('div');
                    div.style.marginBottom = '5px';
                    div.innerHTML = `
                        <label style="display:block; font-size:12px; font-weight:bold;">${k}</label>
                        <input type="text" class="add-value-field" data-name="${k}" value="${String(obj[k]).replace(/"/g, '&quot;')}" style="width:100%; padding:5px; border:1px solid var(--input-border); border-radius:3px; background: var(--input-bg); color: var(--text-color); box-sizing: border-box;">
                    `;
                    container.appendChild(div);
                });
            } else {
                // Primitive value?
                alert("Value is not an object, cannot use Form view.");
                document.getElementById('add-value-mode-toggle').checked = true;
                renderAddValueJson(textarea ? textarea.value : '');
            }
        }
    }

    function renderAddValueJson(content = '') {
        const container = document.getElementById('add-value-container');
        container.innerHTML = `<textarea id="add-value-json" style="width:100%; height:200px; padding:5px; font-family:monospace; border:1px solid var(--input-border); border-radius:3px; background: var(--input-bg); color: var(--text-color); box-sizing: border-box;">${content}</textarea>`;
    }

    function parseInputVal(val) {
        if (val === '') return val;
        if (!isNaN(Number(val))) return Number(val);
        if (val.toLowerCase() === 'true') return true;
        if (val.toLowerCase() === 'false') return false;
        return val;
    }

    function closeAdd() {
        document.getElementById('add-modal').style.display = 'none';
    }

    function addItem() {
        if (!currentStore) return;

        let key, val;

        // --- Construct Key ---
        const keyFields = document.querySelectorAll('.add-key-field');
        if (keyFields.length > 0) {
            // Complex Key Form
            key = {};
            keyFields.forEach(inp => {
                key[inp.getAttribute('data-name')] = parseInputVal(inp.value);
            });
        } else {
            // JSON/Simple Mode
            let keyText = "";
            const keyJsonInput = document.getElementById('add-key-json');
            const keySimpleInput = document.getElementById('add-key-simple');
            
            if (keyJsonInput) keyText = keyJsonInput.value;
            else if (keySimpleInput) keyText = keySimpleInput.value;

            keyText = keyText.trim();
            if (keyText.startsWith('{') || keyText.startsWith('[')) {
                try {
                    key = JSON.parse(keyText);
                } catch (e) {
                    alert("Invalid JSON in Key field: " + e.message);
                    return;
                }
            } else {
                // Try to parse as number if it looks like one
                if (keyText !== "" && !isNaN(Number(keyText))) {
                    key = Number(keyText);
                } else {
                    key = keyText;
                }
            }
        }

        // --- Construct Value ---
        const valFields = document.querySelectorAll('.add-value-field');
        if (valFields.length > 0) {
            // Form Mode
            val = {};
            valFields.forEach(inp => {
                val[inp.getAttribute('data-name')] = parseInputVal(inp.value);
            });
        } else {
            // JSON Mode
            const valText = document.getElementById('add-value-json').value;
            try {
                val = JSON.parse(valText);
            } catch (e) {
                alert("Invalid JSON in Value field: " + e.message);
                return;
            }
        }

        // --- Validation ---

        // 1. Check IndexSpecification Requirements (Critical)
        if (currentStoreInfo && currentStoreInfo.indexSpec && currentStoreInfo.indexSpec.index_fields) {
            if (typeof key !== 'object' || key === null) {
                alert("Error: This store requires a structured key (JSON object) to match its Index Specification.");
                return;
            }
            
            const missingIndexFields = [];
            currentStoreInfo.indexSpec.index_fields.forEach(field => {
                if (key[field.field_name] === undefined) {
                    missingIndexFields.push(field.field_name);
                }
            });

            if (missingIndexFields.length > 0) {
                alert(`Error: The key is missing required index fields:\n${missingIndexFields.join(', ')}\n\nThese fields are required for the database comparer to function.`);
                return;
            }
        }

        // 2. Check for missing fields in Key based on sample (Warning)
        if (currentItems && currentItems.length > 0) {
            const sampleKey = currentItems[0].key;
            if (typeof sampleKey === 'object' && sampleKey !== null && typeof key === 'object' && key !== null) {
                const sampleFields = Object.keys(sampleKey);
                const newFields = Object.keys(key);
                const missing = sampleFields.filter(k => !newFields.includes(k));
                
                if (missing.length > 0) {
                    if (!confirm(`Warning: The key is missing the following fields found in other items:\n${missing.join(', ')}\n\nThis might cause sorting or retrieval issues.\nDo you want to proceed?`)) {
                        return;
                    }
                }
            }
            // Check for type mismatch (Primitive vs Object)
            const sampleType = typeof sampleKey;
            const newType = typeof key;
            if (sampleType !== newType) {
                 if (!confirm(`Warning: Key type mismatch.\nExpected: ${sampleType}\nGot: ${newType}\n\nDo you want to proceed?`)) {
                    return;
                }
            }
        }

        const payload = {
            database: currentDatabase,
            store: currentStore,
            key: key,
            value: val
        };

        fetch('/api/store/item/add', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(res => {
            if (!res.ok) return res.text().then(t => { throw new Error(t) });
            return res.json();
        })
        .then(() => {
            closeAdd();
            if (!currentItems || currentItems.length <= 1) {
                loadItems('first');
            } else {
                loadItems('current', firstKey);
            }
        })
        .catch(err => {
            alert("Add failed: " + err.message);
        });
    }
    document.getElementById('detail-resizer').style.display = 'none';
    
    function closeDetail(force = false) {
        const btn = document.getElementById('btn-save');
        if (!force && btn && !btn.disabled) {
            if (!confirm("You have unsaved changes. Are you sure you want to discard them?")) {
                return false;
            }
        }
        // Reset state
        if (btn) btn.disabled = true;
        currentItemKey = null;
        currentItemValue = null;

        document.getElementById('detail-panel').style.display = 'none';
        document.getElementById('detail-resizer').style.display = 'none';
        return true;
    }

    // Resizer Logic
    const sidebar = document.getElementById('sidebar');
    const resizer = document.getElementById('resizer');

    // Mouse Events
    resizer.addEventListener('mousedown', (e) => {
        e.preventDefault();
        document.addEventListener('mousemove', resize);
        document.addEventListener('mouseup', stopResize);
        resizer.classList.add('resizing');
        document.body.style.cursor = 'col-resize';
    });

    // Touch Events (for Mobile)
    resizer.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling while dragging
        document.addEventListener('touchmove', resize, { passive: false });
        document.addEventListener('touchend', stopResize);
        resizer.classList.add('resizing');
    }, { passive: false });

    function resize(e) {
        let clientX;
        if (e.type.startsWith('touch')) {
            clientX = e.touches[0].clientX;
        } else {
            clientX = e.clientX;
        }

        const newWidth = clientX;
        // Basic constraints - relaxed for mobile
        if (newWidth > 50 && newWidth < window.innerWidth - 50) {
            sidebar.style.width = newWidth + 'px';
        }
    }

    function stopResize() {
        document.removeEventListener('mousemove', resize);
        document.removeEventListener('mouseup', stopResize);
        document.removeEventListener('touchmove', resize);
        document.removeEventListener('touchend', stopResize);
        resizer.classList.remove('resizing');
        document.body.style.cursor = 'default';
    }

    // Detail Panel Resizer
    const detailPanel = document.getElementById('detail-panel');
    const detailResizer = document.getElementById('detail-resizer');

    detailResizer.addEventListener('mousedown', (e) => {
        e.preventDefault();
        document.addEventListener('mousemove', resizeDetail);
        document.addEventListener('mouseup', stopResizeDetail);
        detailResizer.classList.add('resizing');
        document.body.style.cursor = 'col-resize';
    });

    function resizeDetail(e) {
        const newWidth = window.innerWidth - e.clientX;
        if (newWidth > 200 && newWidth < window.innerWidth - 100) {
            detailPanel.style.width = newWidth + 'px';
        }
    }

    function stopResizeDetail() {
        document.removeEventListener('mousemove', resizeDetail);
        document.removeEventListener('mouseup', stopResizeDetail);
        detailResizer.classList.remove('resizing');
        document.body.style.cursor = 'default';
    }

    // Column Resizing
    let colResizingTh = null;
    let colStartX, colStartWidth;

    function initColResize(e) {
        e.stopPropagation();
        colResizingTh = e.target.parentElement;
        colStartX = e.clientX;
        colStartWidth = parseFloat(window.getComputedStyle(colResizingTh).width);
        document.addEventListener('mousemove', doColResize, false);
        document.addEventListener('mouseup', stopColResize, false);
    }
    function doColResize(e) {
        if (colResizingTh) {
            const newWidth = colStartWidth + (e.clientX - colStartX);
            if (newWidth > 50) {
                colResizingTh.style.width = newWidth + 'px';
            }
        }
    }
    function stopColResize(e) {
        colResizingTh = null;
        document.removeEventListener('mousemove', doColResize, false);
        document.removeEventListener('mouseup', stopColResize, false);
    }

    // Keyboard Navigation
    document.addEventListener('keydown', function(e) {
        // Handle Escape for Add Modal
        if (e.key === 'Escape') {
            const addModal = document.getElementById('add-modal');
            if (addModal && addModal.style.display !== 'none') {
                closeAdd();
                e.preventDefault();
                return;
            }
        }

        // Only handle if not typing in an input or textarea
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        // If modal is open, do not handle grid navigation
        if (document.getElementById('confirm-modal').style.display === 'flex') return;
        if (document.getElementById('add-modal').style.display === 'flex') return;

        const selectedRow = document.querySelector('#items-table tr.selected-row');
        
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (selectedRow) {
                const nextRow = selectedRow.nextElementSibling;
                if (nextRow) {
                    const index = nextRow.sectionRowIndex;
                    if (currentItems[index]) {
                        showDetail(nextRow, currentItems[index], false);
                    }
                    nextRow.scrollIntoView({ block: 'nearest' });
                }
            } else {
                // Select first row if none selected
                const firstRow = document.querySelector('#items-table tbody tr');
                if (firstRow) {
                    const index = firstRow.sectionRowIndex;
                    if (currentItems[index]) {
                        showDetail(firstRow, currentItems[index], false);
                    }
                    firstRow.scrollIntoView({ block: 'nearest' });
                }
            }
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (selectedRow) {
                const prevRow = selectedRow.previousElementSibling;
                if (prevRow) {
                    const index = prevRow.sectionRowIndex;
                    if (currentItems[index]) {
                        showDetail(prevRow, currentItems[index], false);
                    }
                    prevRow.scrollIntoView({ block: 'nearest' });
                }
            }
        } else if (e.key === 'Delete' || e.key === 'Backspace') {
            if (selectedRow && currentItemKey !== null) {
                deleteItem();
            }
        } else if (e.key === 'Enter') {
            if (selectedRow) {
                e.preventDefault();
                const index = selectedRow.sectionRowIndex;
                if (currentItems[index]) {
                    showDetail(selectedRow, currentItems[index], true);
                }
            }
        } else if (e.key === 'Escape') {
            e.preventDefault();
            closeDetail();
        }
    });

    // --- Chat & Tabs Logic ---

    function toggleProviderSelect() {
        const agent = document.getElementById('agent-select').value;
        const providerSelect = document.getElementById('provider-select');
        // Show provider select only for RAG agents (doctor, sql_admin)
        if (agent === 'doctor' || agent === 'sql_admin') {
            providerSelect.style.display = 'inline-block';
        } else {
            providerSelect.style.display = 'none';
        }
    }

    function switchTab(tabName) {
        // Update Tabs
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.getElementById(`tab-btn-${tabName}`).classList.add('active');

        // Update Content
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById(`tab-${tabName}`).classList.add('active');
    }

    function toggleChatWidget() {
        const widget = document.getElementById('chat-widget');
        const btn = document.getElementById('chat-toggle-btn');
        
        if (widget.classList.contains('active')) {
            widget.classList.remove('active');
            btn.style.display = 'flex';
        } else {
            // Initialize position if not set (first open)
            if (!widget.style.top && !widget.style.left && !widget.style.right && !widget.style.bottom) {
                // Default to bottom right, but using top/left for resize compatibility
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const width = 400;
                const height = 500;
                
                widget.style.left = (viewportWidth - width - 20) + 'px';
                widget.style.top = (viewportHeight - height - 80) + 'px';
            }
            
            widget.classList.add('active');
            btn.style.display = 'none';
            // Focus input when opening
            setTimeout(() => document.getElementById('chat-input').focus(), 100);
        }
    }

    // --- Draggable Chat Widget Logic ---
    document.addEventListener('DOMContentLoaded', function() {
        const widget = document.getElementById('chat-widget');
        const header = widget.querySelector('.chat-header');
        let isDragging = false;
        let dragStartX, dragStartY;

        header.addEventListener('mousedown', function(e) {
            // Ignore if clicking controls or select
            if (e.target.closest('.chat-controls') || e.target.closest('select')) return;
            
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            
            // Change cursor style globally to indicate dragging
            document.body.style.cursor = 'move';
        });

        document.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            e.preventDefault();
            
            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;
            
            // Use top/left for positioning
            const rect = widget.getBoundingClientRect();
            widget.style.left = (rect.left + deltaX) + 'px';
            widget.style.top = (rect.top + deltaY) + 'px';
            
            // Clear right/bottom if they exist to avoid conflicts
            widget.style.right = 'auto';
            widget.style.bottom = 'auto';
            
            dragStartX = e.clientX;
            dragStartY = e.clientY;
        });

        document.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                document.body.style.cursor = 'default';
            }
        });

        // --- Resize Logic ---
        const resizeHandle = widget.querySelector('.resize-handle');
        let isResizing = false;
        let resizeStartX, resizeStartY, startWidth, startHeight;

        if (resizeHandle) {
            resizeHandle.addEventListener('mousedown', function(e) {
                e.stopPropagation(); // Prevent drag
                e.preventDefault(); // Prevent selection
                isResizing = true;
                resizeStartX = e.clientX;
                resizeStartY = e.clientY;
                startWidth = widget.offsetWidth;
                startHeight = widget.offsetHeight;
                document.body.style.cursor = 'nwse-resize';
            });
        }

        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            e.preventDefault();
            
            const deltaX = e.clientX - resizeStartX;
            const deltaY = e.clientY - resizeStartY;
            
            widget.style.width = Math.max(300, startWidth + deltaX) + 'px';
            widget.style.height = Math.max(300, startHeight + deltaY) + 'px';
        });

        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = 'default';
            }
        });
    });

    // --- Draggable Add Modal Logic (Event Delegation) ---
    (function() {
        let isDragging = false;
        let dragStartX, dragStartY;
        let initialLeft, initialTop;
        let activeModalContent = null;

        document.addEventListener('mousedown', function(e) {
            const header = e.target.closest('#add-modal-header');
            if (!header) return;
            
            const modalContent = document.getElementById('add-modal-content');
            if (!modalContent) return;

            isDragging = true;
            activeModalContent = modalContent;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            
            // If we are centered via transform, we need to switch to explicit top/left
            const rect = modalContent.getBoundingClientRect();
            modalContent.style.transform = 'none';
            modalContent.style.left = rect.left + 'px';
            modalContent.style.top = rect.top + 'px';
            modalContent.style.margin = '0';
            
            initialLeft = rect.left;
            initialTop = rect.top;
            
            document.body.style.cursor = 'move';
            e.preventDefault(); // Prevent text selection
        });

        document.addEventListener('mousemove', function(e) {
            if (!isDragging || !activeModalContent) return;
            e.preventDefault();
            
            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;
            
            activeModalContent.style.left = (initialLeft + deltaX) + 'px';
            activeModalContent.style.top = (initialTop + deltaY) + 'px';
        });

        document.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                activeModalContent = null;
                document.body.style.cursor = 'default';
            }
        });
    })();

    let chatAbortController = null;
    let chatHistory = [];
    let historyIndex = -1;

    function jsonToCSV(input) {
        try {
            let items;
            if (typeof input === 'string') {
                items = JSON.parse(input);
            } else {
                items = input;
            }

            if (!Array.isArray(items) || items.length === 0) {
                console.log("jsonToCSV: Input is not an array or empty");
                return typeof input === 'string' ? input : JSON.stringify(input);
            }

            console.log("jsonToCSV: Parsed " + items.length + " items");
            if (items.length > 0) {
                console.log("First item structure:", JSON.stringify(items[0]));
            }

            // Determine headers
            let keyIsMap = false;
            let valueIsMap = false;
            let keyFields = new Set();
            let valueFields = new Set();

            items.forEach(item => {
                if (typeof item.key === 'object' && item.key !== null) {
                    keyIsMap = true;
                    Object.keys(item.key).forEach(k => keyFields.add(k));
                }
                if (typeof item.value === 'object' && item.value !== null) {
                    valueIsMap = true;
                    Object.keys(item.value).forEach(k => valueFields.add(k));
                }
            });

            let headers = [];
            let kFieldsArr = Array.from(keyFields).sort();
            let vFieldsArr = Array.from(valueFields).sort();

            if (keyIsMap) {
                kFieldsArr.forEach(k => headers.push(k.charAt(0).toUpperCase() + k.slice(1)));
            } else {
                headers.push("Key");
            }

            if (valueIsMap) {
                vFieldsArr.forEach(v => headers.push(v.charAt(0).toUpperCase() + v.slice(1)));
            } else {
                headers.push("Value");
            }

            let csv = headers.join(", ") + "\n";

            items.forEach(item => {
                let row = [];
                if (keyIsMap) {
                    kFieldsArr.forEach(k => {
                        row.push(item.key[k] !== undefined ? item.key[k] : "");
                    });
                } else {
                    row.push(item.key);
                }

                if (valueIsMap) {
                    vFieldsArr.forEach(v => {
                        row.push(item.value[v] !== undefined ? item.value[v] : "");
                    });
                } else {
                    row.push(item.value);
                }
                csv += row.join(", ") + "\n";
            });

            return csv;
        } catch (e) {
            console.error("Failed to convert JSON to CSV", e);
            return typeof input === 'string' ? input : JSON.stringify(input);
        }
    }

    function processMacroTrace(trace, format) {
        let output = "";
        console.log("Processing Macro Trace. Steps:", trace.length);
        
        trace.forEach((step, index) => {
            console.log(`Step ${index} type: ${step.type}`);
            if (step.type === 'command') {
                // Optionally show the command being executed
                // output += `> ${step.command}\n`;
                
                if (step.result) {
                    let resultDisplay = step.result;
                    if (format === 'csv') {
                        try {
                            console.log(`Step ${index} result (first 50 chars):`, step.result.substring(0, 50));
                            // The result might be a JSON string of an array
                            const parsedResult = JSON.parse(step.result);
                            console.log(`Step ${index} parsed result type:`, typeof parsedResult, "Is Array:", Array.isArray(parsedResult));
                            
                            if (Array.isArray(parsedResult)) {
                                const csv = jsonToCSV(parsedResult);
                                console.log(`Step ${index} CSV conversion result (first 50 chars):`, csv.substring(0, 50));
                                // Only use CSV if it looks like CSV (has headers)
                                if (csv.includes(',')) {
                                    resultDisplay = csv;
                                }
                            }
                        } catch (e) {
                            console.error(`Step ${index} JSON parse error:`, e);
                            // Keep original if not parseable
                        }
                    }
                    output += resultDisplay + "\n";
                }
            } else if (step.type === 'say') {
                output += step.result + "\n";
            } else if (step.type === 'error') {
                output += `Error: ${step.error}\n`;
            } else if (step.type === 'ask') {
                output += `${step.prompt}\n`;
            }
        });
        
        return output.trim();
    }

    function sendChatMessage() {
        const input = document.getElementById('chat-input');
        const sendBtn = document.getElementById('chat-send-btn');
        
        // Check if we are in "Stop" mode
        if (chatAbortController) {
            chatAbortController.abort();
            chatAbortController = null;
            if (sendBtn) sendBtn.textContent = 'Send';
            appendChatMessage('ai', 'Request cancelled by user.');
            return;
        }

        const message = input.value.trim();
        const agentSelect = document.getElementById('agent-select');
        const agent = agentSelect ? agentSelect.value : 'db_admin';
        const providerSelect = document.getElementById('provider-select');
        const provider = providerSelect ? providerSelect.value : '';
        const formatSelect = document.getElementById('format-select');
        const format = formatSelect ? formatSelect.value : 'csv';

        if (!message) return;

        // Save to history
        chatHistory.push(message);
        historyIndex = -1; // Reset index

        // Add User Message
        appendChatMessage('user', message);
        input.value = '';

        // Use double requestAnimationFrame to ensure the browser paints the user message
        // before we start the network operation. This is more reliable than setTimeout.
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                // Show Loading
                const loadingId = appendChatMessage('ai', 'Thinking...');
                
                // Setup AbortController
                chatAbortController = new AbortController();
                if (sendBtn) sendBtn.textContent = 'Stop';

                fetch('/api/ai/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        message: message,
                        database: currentDatabase,
                        store: currentStore,
                        agent: agent,
                        provider: provider,
                        format: format
                    }),
                    signal: chatAbortController.signal
                })
                .then(res => res.json())
                .then(data => {
                    // Remove Loading
                    const loadingEl = document.getElementById(loadingId);
                    if (loadingEl) loadingEl.remove();

                    if (data.error) {
                        appendChatMessage('ai', 'Error: ' + data.error);
                    } else {
                        let responseText = data.response;
                        
                        // Client-side formatting
                        console.log("Format:", format);
                        
                        // Check if response is a Macro Trace (JSON Array of Steps)
                        let isMacroTrace = false;
                        try {
                            // Try to parse the whole response as JSON
                            const parsed = JSON.parse(responseText);
                            // Heuristic: Array of objects with 'type' field
                            if (Array.isArray(parsed) && parsed.length > 0 && parsed[0].type) {
                                console.log("Detected Macro Trace");
                                responseText = processMacroTrace(parsed, format);
                                isMacroTrace = true;
                            }
                        } catch (e) {
                            // Not a JSON trace
                        }

                        if (!isMacroTrace && format === 'csv') {
                            let newResponse = "";
                            let currentIndex = 0;
                            const text = responseText;
                            
                            while (currentIndex < text.length) {
                                // Find start of JSON array
                                const start = text.indexOf('[', currentIndex);
                                if (start === -1) {
                                    newResponse += text.substring(currentIndex);
                                    break;
                                }
                                
                                // Find matching closing bracket
                                let balance = 0;
                                let end = -1;
                                for (let i = start; i < text.length; i++) {
                                    if (text[i] === '[') balance++;
                                    else if (text[i] === ']') balance--;
                                    
                                    if (balance === 0) {
                                        end = i;
                                        break;
                                    }
                                }
                                
                                if (end !== -1) {
                                    // We found a balanced block [ ... ]
                                    const potentialJson = text.substring(start, end + 1);
                                    let replacement = potentialJson;
                                    let isJson = false;
                                    
                                    try {
                                        // Heuristic: only parse if it looks like an array of objects or empty array
                                        if (potentialJson.includes('{') || potentialJson.includes('[]')) {
                                            const parsed = JSON.parse(potentialJson);
                                            if (Array.isArray(parsed) && parsed.length > 0) {
                                                replacement = "\n" + jsonToCSV(parsed) + "\n";
                                                isJson = true;
                                            }
                                        }
                                    } catch (e) {
                                        // Not JSON, ignore
                                    }
                                    
                                    // Append text before this block
                                    let preText = text.substring(currentIndex, start);
                                    
                                    if (isJson) {
                                        // Clean up trailing markdown code block start from preText
                                        // e.g. "Here is data:\n```json\n" -> "Here is data:\n"
                                        preText = preText.replace(/```[a-z]*\s*$/, '');
                                    }
                                    
                                    newResponse += preText + replacement;
                                    
                                    // Advance index
                                    currentIndex = end + 1;
                                    
                                    if (isJson) {
                                        // Check if the next characters are the closing markdown ```
                                        // We need to peek ahead
                                        const remaining = text.substring(currentIndex);
                                        const match = remaining.match(/^\s*```/);
                                        if (match) {
                                            currentIndex += match[0].length;
                                        }
                                    }
                                } else {
                                    // Unbalanced, just append everything remaining
                                    newResponse += text.substring(currentIndex);
                                    break;
                                }
                            }
                            responseText = newResponse;
                        }


                        appendChatMessage('ai', responseText);
                        
                        // If the AI performed an action (like search), we might want to refresh the grid
                        if (data.action === 'refresh') {
                            loadItems('current', firstKey);
                        }
                    }
                })
                .catch(err => {
                    const loadingEl = document.getElementById(loadingId);
                    if (loadingEl) loadingEl.remove();
                    
                    if (err.name === 'AbortError') {
                        // Handled by the abort click logic mostly, but ensures cleanup
                    } else {
                        appendChatMessage('ai', 'Error: ' + err.message);
                    }
                })
                .finally(() => {
                    chatAbortController = null;
                    if (sendBtn) sendBtn.textContent = 'Send';
                });
            });
        });
    }

    function handleChatKeydown(e) {
        const input = document.getElementById('chat-input');
        
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendChatMessage();
        } else if (e.key === 'ArrowUp') {
            // Only navigate history if cursor is at start or single line
            if (chatHistory.length > 0) {
                e.preventDefault();
                if (historyIndex === -1) {
                    historyIndex = chatHistory.length - 1;
                } else if (historyIndex > 0) {
                    historyIndex--;
                }
                input.value = chatHistory[historyIndex];
            }
        } else if (e.key === 'ArrowDown') {
            if (historyIndex !== -1) {
                e.preventDefault();
                if (historyIndex < chatHistory.length - 1) {
                    historyIndex++;
                    input.value = chatHistory[historyIndex];
                } else {
                    historyIndex = -1;
                    input.value = '';
                }
            }
        }
    }

    function appendChatMessage(role, text) {
        console.log("Appending message:", role, text); // Debug Log
        const history = document.getElementById('chat-history');
        const div = document.createElement('div');
        div.className = `chat-message ${role}`;
        div.id = 'msg-' + new Date().getTime();
        
        // Simple markdown-like parsing for code blocks
        if (text.includes('```')) {
            text = text.replace(/```([\s\S]*?)```/g, '<pre>$1</pre>');
        }
        
        div.innerHTML = text.replace(/\n/g, '<br>');
        history.appendChild(div);
        
        console.log("Message appended to history. History child count:", history.children.length); // Debug Log

        // Auto-scroll to bottom
        requestAnimationFrame(() => {
            history.scrollTop = history.scrollHeight;
        });
        
        return div.id;
    }

    // Hook into showDetail to ensure we see the details tab
    const originalShowDetail = showDetail;
    showDetail = function(row, item, autoOpen) {
        originalShowDetail(row, item, autoOpen);
        
        // Only switch to details tab if we are explicitly opening/selecting (e.g. click)
        // If autoOpen is false (navigation), preserve the current tab (e.g. if user is in Chat)
        if (autoOpen === undefined || autoOpen === true) {
            switchTab('details');
        }
    };

    function toggleProviderSelect() {
        // No-op since we removed the agent select dropdown logic
    }
</script>

<div id="add-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1100;">
    <div id="add-modal-content" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background:var(--bg-color); color:var(--text-color); padding:20px; border-radius:5px; width:600px; max-width:90%; max-height: 90vh; display: flex; flex-direction: column; border: 1px solid var(--border-color); box-shadow: 0 4px 12px rgba(0,0,0,0.2);">
        <h3 id="add-modal-header" style="margin-top:0; margin-bottom: 10px; cursor: move; user-select: none;">Add New Item</h3>
        
        <div style="overflow-y: auto; flex: 1; padding-right: 0;">
            <h4 style="margin-bottom: 5px; margin-top: 0;">Key</h4>
            <div style="margin-bottom: 5px; font-size: 12px; color: var(--text-muted);">
                <label><input type="checkbox" id="add-key-mode-toggle" onchange="toggleAddKeyMode()"> Edit as JSON</label>
            </div>
            <div id="add-key-container" style="margin-bottom:15px;"></div>

            <h4 style="margin-bottom: 5px;">Value</h4>
            <div style="margin-bottom: 5px; font-size: 12px; color: var(--text-muted);">
                <label><input type="checkbox" id="add-value-mode-toggle" onchange="toggleAddValueMode()"> Edit as JSON</label>
            </div>
            <div id="add-value-container"></div>
        </div>

        <div style="display:flex; justify-content:flex-end; gap:10px; margin-top: 20px;">
            <button onclick="closeAdd()" title="Cancel adding a new item.">Cancel</button>
            <button onclick="addItem()" style="background:#28a745; color:white;" title="Add the new item to the store.">Add</button>
        </div>
    </div>
</div>

<div id="confirm-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); justify-content:center; align-items:center; z-index:2000;">
    <div style="background:var(--bg-color); color:var(--text-color); padding:20px; border-radius:5px; width:400px; max-width:90%; box-shadow: 0 4px 6px rgba(0,0,0,0.1); border: 1px solid var(--border-color);">
        <h3 style="margin-top:0;">Confirm Action</h3>
        <p id="confirm-message" style="margin: 20px 0;">Are you sure?</p>
        <div style="display:flex; justify-content:flex-end; gap:10px;">
            <button id="confirm-cancel" style="padding: 5px 15px; background: var(--button-bg); color: var(--button-text);" title="Cancel the action.">Cancel</button>
            <button id="confirm-ok" style="background:var(--danger-bg); color:white; padding: 5px 15px;" title="Confirm deletion.">Delete</button>
        </div>
    </div>
</div>

<script>
    window.onbeforeunload = function() {
        const btn = document.getElementById('btn-save');
        if (btn && !btn.disabled) {
            return "You have unsaved changes.";
        }
    };
</script>

<!-- Floating Chat Widget -->
<div id="chat-widget" class="chat-widget">
    <div class="chat-header">
        <div style="display: flex; align-items: center; gap: 8px;">
            <span>AI Assistant</span>
            <select id="provider-select" style="padding: 2px; border-radius: 3px; border: 1px solid #ccc; font-size: 11px; font-weight: normal; color: #333;" onclick="event.stopPropagation()" title="Select AI Provider">
                <option value="">Default (Local)</option>
                <option value="ollama">Ollama (Local AI)</option>
                <option value="gemini">Gemini (Cloud)</option>
                <option value="chatgpt">ChatGPT (Cloud)</option>
            </select>
            <select id="format-select" style="padding: 2px; border-radius: 3px; border: 1px solid #ccc; font-size: 11px; font-weight: normal; color: #333;" onclick="event.stopPropagation()" title="Response Format">
                <option value="csv">CSV</option>
                <option value="json">JSON</option>
            </select>
            <!-- Hidden Agent Select (Hardcoded to sql_admin) -->
            <input type="hidden" id="agent-select" value="sql_admin">
        </div>
        <div class="chat-controls">
            <button class="minimize-btn" onclick="toggleChatWidget()">_</button>
        </div>
    </div>
    <div id="chat-history">
        <div class="chat-message ai">Hello! I am your SOP Data Assistant. How can I help you today?</div>
    </div>
    <div class="chat-input-area">
        <textarea id="chat-input" placeholder="Ask about your data (e.g., 'Find users in New York')..." onkeydown="handleChatKeydown(event)"></textarea>
        <button id="chat-send-btn" onclick="sendChatMessage()">Send</button>
    </div>
    <div class="resize-handle"></div>
</div>

<button id="chat-toggle-btn" class="chat-toggle-btn" onclick="toggleChatWidget()">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
    </svg>
</button>

</body>
</html>
