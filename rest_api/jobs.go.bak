package main

import (
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"

	"blackicedata.com/hive"
	"blackicedata.com/hive/jobs"
)

type jobsRestApi struct{}

/*
Job management:
  - Add new Job
  - Get Job detail
  - Update Job
  - Delete Job
  - List Jobs

  - Should we support user to be able to view run logs ? (perhaps later)
*/

func NewJobsRestApi() *jobsRestApi {
	return &jobsRestApi{}
}

// GetJobs godoc
// @Summary GetJobs returns list of jobs
// @Schemes
// @Description GetJobs responds with the list of all jobs as JSON.
// @Tags Jobs
// @Accept json
// @Produce json
// @Failure 404 {object} map[string]any
// @Success 200 {object} []jobs.Job
// @Router /jobs [get]
// @Security Bearer
func (jra *jobsRestApi) GetJobs(c *gin.Context) {
	res := jobs.Database.JobsRepository.FetchAll(c)
	if res.Error != nil || len(res.Details) == 0 {
		c.IndentedJSON(http.StatusNotFound, gin.H{"message": "fetching jobs list failed"})
	}
	jobs := make([]jobs.Job, len(res.Details))
	for i := range res.Details {
		jobs[i] = res.Details[i].Payload.Value
	}
	c.IndentedJSON(http.StatusOK, jobs)
}

// PostJob godoc
// @Summary PostJob adds a job
// @Schemes
// @Description PostJob adds a job from JSON received in the request body.
// @Tags Jobs
// @Accept json
// @Produce json
// @Param		message	body		jobs.Job		true	"Job Data"
// @Failure 400 {object} map[string]any
// @Success 201 {object} jobs.Job
// @Router /jobs [post]
// @Security Bearer
func (jra *jobsRestApi) PostJob(c *gin.Context) {
	var newJob jobs.Job

	// Call BindJSON to bind the received JSON to newJob.
	if err := c.BindJSON(&newJob); err != nil {
		c.IndentedJSON(http.StatusBadRequest, gin.H{"message": "failed to extract job data from request"})
		return
	}

	// Add the new job to the repository.
	jobs.Database.JobsRepository.Add(c, hive.KeyValuePair[string, jobs.Job]{
		Key:   newJob.Name,
		Value: newJob,
	})
	c.IndentedJSON(http.StatusCreated, newJob)
}

// GetJobByName godoc
// @Summary GetJobsByName returns job with a given name
// @Schemes
// @Description GetJobByName locates the job whose Name value matches the name parameter sent by the client, then returns that job as a response.
// @Tags Jobs
// @Accept json
// @Produce json
// @Param			name	path		string		true	"Name of job to fetch"    minlength(1)  maxlength(16)
// @Failure 404 {object} map[string]any
// @Success 200 {object} jobs.Job
// @Router /jobs/{name} [get]
// @Security Bearer
func (jra *jobsRestApi) GetJobByName(c *gin.Context) {
	name := c.Param("name")

	// Loop through the list of jobs, looking for
	// a job whose ID value matches the parameter.
	res := jobs.Database.JobsRepository.Fetch(c, name)
	if res.Error == nil && len(res.Details) == 1 {
		c.IndentedJSON(http.StatusOK, res.Details[0].Payload.Value)
		return
	}
	c.IndentedJSON(http.StatusNotFound, gin.H{"message": fmt.Sprintf("failed to fetch job with name %s", name)})
}

// DeleteJobByName godoc
// @Summary DeleteJobByName deletes job with a given name
// @Schemes
// @Description DeleteJobByName locates the job whose Name value matches the name parameter sent by the client, then deletes that job.
// @Tags Jobs
// @Accept json
// @Produce json
// @Param			name	path		string		true	"Name of job to delete"    minlength(1)  maxlength(16)
// @Failure 404 {object} map[string]any
// @Success 200 {object} map[string]any
// @Router /jobs/{name} [delete]
// @Security Bearer
func (jra *jobsRestApi) DeleteJobByName(c *gin.Context) {
	name := c.Param("name")

	// Delete the job with Name.
	res := jobs.Database.JobsRepository.Remove(c, name)
	if res.Error == nil {
		c.IndentedJSON(http.StatusOK, gin.H{"message": fmt.Sprintf("job with name %s was deleted", name)})
		return
	}
	c.IndentedJSON(http.StatusNotFound, gin.H{"message": fmt.Sprintf("failed to remove job with name %s", name)})
}
