-- NOTE: Experimental Cassandra table definitions. Kept in case useful in the future
-- when we implement "data driver" that uses Cassandra, more likely not to happen. :)
-- Will delete below items and this file soon enough.

create keyspace btree with replication = {'class':'SimpleStrategy', 'replication_factor':1};

create table data_blocks (
    n_id UUID,
    db_id int,
    data blob
)

create table item_value(
    id UUID Primary Key,
    -- value datablocks(chunks)
    chunks <list<blob>>,
    -- if set, contains all other "block physical IDs" (UUID) storing the rest of data.
    -- otherwise, data fit into a single blob (stored in v_block).
    v_b_ids frozen <set<UUID>>,
    is_del boolean,
);

-- TODO: this is for the long-teram, v3+ implementation. See Redis based transaction for the V2 timeline.
-- transaction_sandbox contains transaction specific management actions on store's items.
-- This is used for long lived transactions that span days. Redis is used for the real 
-- transaction "activities".
create table transaction_sandbox(
    -- Transaction ID (tid)
    tid UUID,
    store text,
    timestamp TIMESTAMP,

    -- read lock on kvp, add, update, delete
    act int,
    -- current value version, should be same if act=update,delete
    vrsn int,

    -- current item node's logical Id(c_lid) & slot index(c_si). Useful for non-unique B-Tree
    -- to aid in navigating & finding the current item to be updated.
    -- Only used in update & delete action. Also used in inter-transaction "rule"
    -- enforcement, e.g. - update on same item across transactions is not allowed.
    c_lid UUID,
    c_si int,

    -- current key/value pair
    c_kv tuple<blob,blob>,
    -- new key/value pair
    n_kv tuple<blob,blob>,
    is_del boolean,
    Primary Key((store, tid), seq)
);
